//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace Rcl.Interop
{
    using Rosidl.Runtime.Interop;
    using System.Runtime.InteropServices;

    internal static unsafe partial class RclCommon
    {
        /// <summary>
        /// Used to specify if the context can only communicate through localhost.
        /// </summary>
        public enum rmw_localhost_only_t : int
        {
            /// <summary>
            /// Uses ROS_LOCALHOST_ONLY environment variable.
            /// </summary>
            RMW_LOCALHOST_ONLY_DEFAULT = unchecked((int)0),

            /// <summary>
            /// Forces using only localhost.
            /// </summary>
            RMW_LOCALHOST_ONLY_ENABLED = unchecked((int)1),

            /// <summary>
            /// Forces disabling localhost only.
            /// </summary>
            RMW_LOCALHOST_ONLY_DISABLED = unchecked((int)2),
        }

        public enum rmw_security_enforcement_policy_t : int
        {
            RMW_SECURITY_ENFORCEMENT_PERMISSIVE,

            RMW_SECURITY_ENFORCEMENT_ENFORCE,
        }

        /// <summary>
        /// The severity levels of log messages / loggers.
        /// </summary>
        public enum RCUTILS_LOG_SEVERITY : int
        {
            /// <summary>
            /// The unset log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_UNSET = unchecked((int)0),

            /// <summary>
            /// The debug log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_DEBUG = unchecked((int)10),

            /// <summary>
            /// The info log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_INFO = unchecked((int)20),

            /// <summary>
            /// The warn log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_WARN = unchecked((int)30),

            /// <summary>
            /// The error log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_ERROR = unchecked((int)40),

            /// <summary>
            /// The fatal log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_FATAL = unchecked((int)50),
        }

        /// <summary>
        /// Endpoint enumeration type
        /// </summary>
        public enum rmw_endpoint_type_t : int
        {
            /// <summary>
            /// Endpoint type has not yet been set
            /// </summary>
            RMW_ENDPOINT_INVALID = unchecked((int)0),

            /// <summary>
            /// Creates and publishes messages to the ROS topic
            /// </summary>
            RMW_ENDPOINT_PUBLISHER,

            /// <summary>
            /// Listens for and receives messages from a topic
            /// </summary>
            RMW_ENDPOINT_SUBSCRIPTION,
        }

        public enum rmw_qos_reliability_policy_t : int
        {
            /// <summary>
            /// Implementation specific default
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT,

            /// <summary>
            /// Guarantee that samples are delivered, may retry multiple times.
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_RELIABLE,

            /// <summary>
            /// Attempt to deliver samples, but some may be lost if the network is not robust
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,

            /// <summary>
            /// Reliability policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_UNKNOWN,
        }

        /// <summary>
        /// QoS history enumerations describing how samples endure
        /// </summary>
        public enum rmw_qos_history_policy_t : int
        {
            /// <summary>
            /// Implementation default for history policy
            /// </summary>
            RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT,

            /// <summary>
            /// Only store up to a maximum number of samples, dropping oldest once max is exceeded
            /// </summary>
            RMW_QOS_POLICY_HISTORY_KEEP_LAST,

            /// <summary>
            /// Store all samples, subject to resource limits
            /// </summary>
            RMW_QOS_POLICY_HISTORY_KEEP_ALL,

            /// <summary>
            /// History policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_HISTORY_UNKNOWN,
        }

        /// <summary>
        /// QoS durability enumerations describing how samples persist
        /// </summary>
        public enum rmw_qos_durability_policy_t : int
        {
            /// <summary>
            /// Impplementation specific default
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT,

            /// <summary>
            /// The rmw publisher is responsible for persisting samples for “late-joining” subscribers
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL,

            /// <summary>
            /// Samples are not persistent
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_VOLATILE,

            /// <summary>
            /// Durability policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_UNKNOWN,
        }

        /// <summary>
        /// QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.
        /// For a subscriber, these are its requirements for its topic's publishers.
        /// Suppress syntax errors, as cppcheck does not seem to handle enumerator attributes.
        /// cppcheck-suppress syntaxError
        /// </summary>
        public enum rmw_qos_liveliness_policy_t : int
        {
            /// <summary>
            /// Implementation specific default
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = unchecked((int)0),

            /// <summary>
            /// The signal that establishes a Topic is alive comes from the ROS rmw layer.
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = unchecked((int)1),

            RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = unchecked((int)2),

            /// <summary>
            /// The signal that establishes a Topic is alive is at the Topic level. Only publishing a message
            /// on the Topic or an explicit signal from the application to assert liveliness on the Topic
            /// will mark the Topic as being alive.
            /// Using `3` for backwards compatibility.
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = unchecked((int)3),

            /// <summary>
            /// Liveliness policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_UNKNOWN = unchecked((int)4),
        }

        /// <summary>
        /// Time source type, used to indicate the source of a time measurement.
        /// </summary>
        /// <remarks>
        /// RCL_ROS_TIME will report the latest value reported by a ROS time source, or
        /// if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.
        /// For more information about ROS time sources, refer to the design document:
        /// http://design.ros2.org/articles/clock_and_time.htmlRCL_SYSTEM_TIME reports the same value as the system clock.RCL_STEADY_TIME reports a value from a monotonically increasing clock.
        /// </remarks>
        public enum rcl_clock_type_t : int
        {
            RCL_CLOCK_UNINITIALIZED = unchecked((int)0),

            RCL_ROS_TIME,

            RCL_SYSTEM_TIME,

            RCL_STEADY_TIME,
        }

        /// <summary>
        /// Enumeration to describe the type of time jump.
        /// </summary>
        public enum rcl_clock_change_t : int
        {
            /// <summary>
            /// The source before and after the jump is ROS_TIME.
            /// </summary>
            RCL_ROS_TIME_NO_CHANGE = unchecked((int)1),

            /// <summary>
            /// The source switched to ROS_TIME from SYSTEM_TIME.
            /// </summary>
            RCL_ROS_TIME_ACTIVATED = unchecked((int)2),

            /// <summary>
            /// The source switched to SYSTEM_TIME from ROS_TIME.
            /// </summary>
            RCL_ROS_TIME_DEACTIVATED = unchecked((int)3),

            /// <summary>
            /// The source before and after the jump is SYSTEM_TIME.
            /// </summary>
            RCL_SYSTEM_TIME_NO_CHANGE = unchecked((int)4),
        }

        public enum rcl_publisher_event_type_t : int
        {
            RCL_PUBLISHER_OFFERED_DEADLINE_MISSED,

            RCL_PUBLISHER_LIVELINESS_LOST,

            RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS,
        }

        public enum rcl_subscription_event_type_t : int
        {
            RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED,

            RCL_SUBSCRIPTION_LIVELINESS_CHANGED,

            RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS,
        }

        public struct rcutils_log_location_t
        {
            /// <summary>
            /// The name of the function containing the log call.
            /// </summary>
            public byte* function_name;

            /// <summary>
            /// The name of the source file containing the log call.
            /// </summary>
            public byte* file_name;

            /// <summary>
            /// The line number containing the log call.
            /// </summary>
            public size_t line_number;
        }

        /// <summary>
        /// Encapsulation of an allocator.
        /// </summary>
        /// <remarks>
        /// The default allocator uses malloc(), free(), calloc(), and realloc().
        /// It can be obtained using rcutils_get_default_allocator().The allocator should be trivially copyable.
        /// Meaning that the struct should continue to work after being assignment
        /// copied into a new struct.
        /// Specifically the object pointed to by the state pointer should remain valid
        /// until all uses of the allocator have been made.
        /// Particular care should be taken when giving an allocator to functions like
        /// rcutils_*_init() where it is stored within another object and used later.
        /// Developers should note that, while the fields of a const-qualified allocator
        /// struct cannot be modified, the state of the allocator can be modified.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_allocator_t
        {
            /// <summary>
            /// Allocate memory, given a size and the `state` pointer.
            /// An error should be indicated by returning `NULL`.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclCommon.size_t, void*, void*> allocate;

            /// <summary>
            /// Deallocate previously allocated memory, mimicking free().
            /// Also takes the `state` pointer.
            /// </summary>
            public delegate* unmanaged[Cdecl]<void*, void*, void> deallocate;

            /// <summary>
            /// Reallocate if possible, otherwise it deallocates and allocates.
            /// </summary>
            /// <remarks>
            /// Also takes the `state` pointer.If unsupported then do deallocate and then allocate.
            /// This should behave as realloc() does, as opposed to posix's
            /// [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given
            /// by pointer will not be free'd automatically if realloc() fails.
            /// For reallocf-like behavior use rcutils_reallocf().
            /// This function must be able to take an input pointer of `NULL` and succeed.
            /// </remarks>
            public delegate* unmanaged[Cdecl]<void*, RclCommon.size_t, void*, void*> reallocate;

            /// <summary>
            /// Allocate memory with all elements set to zero, given a number of elements and their size.
            /// An error should be indicated by returning `NULL`.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclCommon.size_t, RclCommon.size_t, void*, void*> zero_allocate;

            /// <summary>
            /// Implementation defined state storage.
            /// </summary>
            /// <remarks>
            /// This is passed as the final parameter to other allocator functions.
            /// Note that the contents of the state can be modified even in const-qualified
            /// allocator objects.
            /// </remarks>
            public void* state;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct size_t : IEquatable<size_t>
        {
            public size_t(nuint value) => this.Value = value;

            public readonly nuint Value;

            public bool Equals(size_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is size_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator nuint(size_t from) => from.Value;

            public static implicit operator size_t(nuint from) => new size_t(from);

            public static bool operator ==(size_t left, size_t right) => left.Equals(right);

            public static bool operator !=(size_t left, size_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_security_options_t
        {
            public RclCommon.rmw_security_enforcement_policy_t enforce_security;

            public sbyte* security_root_path;
        }

        /// <summary>
        /// Options structure used during rmw_init().
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_init_options_t
        {
            /// <summary>
            /// Locally (process local) unique ID that represents this init/shutdown cycle.
            /// </summary>
            /// <remarks>
            /// This should be set by the caller of `rmw_init()` to a number that is
            /// unique within this process.
            /// It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.
            /// </remarks>
            public ulong instance_id;

            /// <summary>
            /// Implementation identifier, used to ensure two different implementations are not being mixed.
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// ROS domain id
            /// </summary>
            public RclCommon.size_t domain_id;

            /// <summary>
            /// Security options
            /// </summary>
            public RclCommon.rmw_security_options_t security_options;

            /// <summary>
            /// Enable localhost only
            /// </summary>
            public RclCommon.rmw_localhost_only_t localhost_only;

            /// <summary>
            /// Enclave, name used to find security artifacts in a sros2 keystore.
            /// </summary>
            public sbyte* enclave;

            /// <summary>
            /// TODO(wjwwood): replace with rmw_allocator_t when that refactor happens
            /// Allocator used during internal allocation of init options, if needed.
            /// </summary>
            public RclCommon.rcutils_allocator_t allocator;

            /// <summary>
            /// Implementation defined init options.
            /// May be NULL if there are no implementation defined options.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Initialization context structure which is used to store init specific information.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_context_t
        {
            /// <summary>
            /// Locally (process local) unique ID that represents this init/shutdown cycle.
            /// </summary>
            public ulong instance_id;

            /// <summary>
            /// Implementation identifier, used to ensure two different implementations are not being mixed.
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Options used to initialize the context.
            /// </summary>
            public RclCommon.rmw_init_options_t options;

            /// <summary>
            /// Implementation defined context information.
            /// May be NULL if there is no implementation defined context information.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Struct wrapping a fixed-size c string used for returning the formatted error string.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_error_string_t
        {
            public fixed sbyte str[1024];
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_string_array_t
        {
            public RclCommon.size_t size;

            public sbyte** data;

            public RclCommon.rcutils_allocator_t allocator;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_uint8_array_t
        {
            public byte* buffer;

            public RclCommon.size_t buffer_length;

            public RclCommon.size_t buffer_capacity;

            public RclCommon.rcutils_allocator_t allocator;
        }


        /// <summary>
        /// Allocation of memory for an rmw publisher
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_publisher_allocation_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this allocation
            /// </summary>
            public void* data;
        }

        /// <summary>
        /// Allocation of memory for an rmw subscription
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_subscription_allocation_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this allocation
            /// </summary>
            public void* data;
        }

        /// <summary>
        /// An rmw service request identifier
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_request_id_t
        {
            /// <summary>
            /// The guid of the writer associated with this request
            /// </summary>
            public fixed sbyte writer_guid[16];

            /// <summary>
            /// Sequence number of this service
            /// </summary>
            public long sequence_number;
        }

        /// <summary>
        /// Struct representing a time point for rmw
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_time_t
        {
            /// <summary>
            /// Seconds since the epoch
            /// </summary>
            public ulong sec;

            /// <summary>
            /// Nanoseconds component of this time point
            /// </summary>
            public ulong nsec;
        }

        /// <summary>
        /// Meta-data for a service-related take.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_service_info_t
        {
            public RclCommon.rcl_time_point_value_t source_timestamp;

            public RclCommon.rcl_time_point_value_t received_timestamp;

            public RclCommon.rmw_request_id_t request_id;
        }

        /// <summary>
        /// A single point in time, measured in nanoseconds since the Unix epoch.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_time_point_value_t : IEquatable<rcl_time_point_value_t>
        {
            public rcl_time_point_value_t(long value) => this.Value = value;

            public readonly long Value;

            public bool Equals(rcl_time_point_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_time_point_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator long(rcl_time_point_value_t from) => from.Value;

            public static implicit operator rcl_time_point_value_t(long from) => new rcl_time_point_value_t(from);

            public static bool operator ==(rcl_time_point_value_t left, rcl_time_point_value_t right) => left.Equals(right);

            public static bool operator !=(rcl_time_point_value_t left, rcl_time_point_value_t right) => !left.Equals(right);
        }

        /// <summary>
        /// ROS MiddleWare quality of service profile.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_qos_profile_t
        {
            public RclCommon.rmw_qos_history_policy_t history;

            /// <summary>
            /// Size of the message queue.
            /// </summary>
            public RclCommon.size_t depth;

            /// <summary>
            /// Reliabiilty QoS policy setting
            /// </summary>
            public RclCommon.rmw_qos_reliability_policy_t reliability;

            /// <summary>
            /// Durability QoS policy setting
            /// </summary>
            public RclCommon.rmw_qos_durability_policy_t durability;

            /// <summary>
            /// The period at which messages are expected to be sent/received
            /// </summary>
            public RclCommon.rmw_time_t deadline;

            /// <summary>
            /// The age at which messages are considered expired and no longer valid
            /// </summary>
            public RclCommon.rmw_time_t lifespan;

            /// <summary>
            /// Liveliness QoS policy setting
            /// </summary>
            public RclCommon.rmw_qos_liveliness_policy_t liveliness;

            /// <summary>
            /// The time within which the RMW node or publisher must show that it is alive
            /// </summary>
            public RclCommon.rmw_time_t liveliness_lease_duration;

            /// <summary>
            /// If true, any ROS specific namespacing conventions will be circumvented.
            /// </summary>
            /// <remarks>
            /// In the case of DDS and topics, for example, this means the typical
            /// ROS specific prefix of `rt` would not be applied as described here:http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefixThis might be useful when trying to directly connect a native DDS topic
            /// with a ROS 2 topic.
            /// </remarks>
            public bool avoid_ros_namespace_conventions;
        }

        /// <summary>
        /// ROS graph ID of the topic
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_gid_t
        {
            /// <summary>
            /// Name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Bype data Gid value
            /// </summary>
            public fixed byte data[24];
        }

        /// <summary>
        /// QoS Liveliness Changed information provided by a subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_liveliness_changed_status_t
        {
            /// <summary>
            /// The total number of currently active Publishers which publish to the topic associated with
            /// the Subscription.
            /// This count increases when a newly matched Publisher asserts its liveliness for the first time
            /// or when a Publisher previously considered to be not alive reasserts its liveliness.
            /// The count decreases when a Publisher considered alive fails to assert its liveliness and
            /// becomes not alive, whether because it was deleted normally or for some other reason.
            /// </summary>
            public int alive_count;

            /// <summary>
            /// The total count of current Publishers which publish to the topic associated with the
            /// Subscription that are no longer asserting their liveliness.
            /// This count increases when a Publisher considered alive fails to assert its liveliness and
            /// becomes not alive for some reason other than the normal deletion of that Publisher.
            /// It decreases when a previously not alive Publisher either reasserts its liveliness or is
            /// deleted normally.
            /// </summary>
            public int not_alive_count;

            /// <summary>
            /// The change in the alive_count since the status was last read.
            /// </summary>
            public int alive_count_change;

            /// <summary>
            /// The change in the not_alive_count since the status was last read.
            /// </summary>
            public int not_alive_count_change;
        }

        /// <summary>
        /// QoS Requested Deadline Missed information provided by a subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_requested_deadline_missed_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of missed deadlines detected for any instance read by the
            /// subscription.
            /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
            /// by one for each instance for which data was not received.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The incremental number of deadlines detected since the status was read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// QoS Liveliness Lost information provided by a publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_liveliness_lost_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of times that a previously-alive Publisher became not alive due to
            /// a failure to actively signal its liveliness within its offered liveliness period.
            /// This count does not change when an already not alive Publisher simply remains not alive for
            /// another liveliness period.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The change in total_count since the last time the status was last read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// QoS Deadline Missed information provided by a publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_offered_deadline_missed_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed
            /// to provide data.
            /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
            /// by one.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The change in total_count since the last time the status was last read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// Array of bool values
        /// </summary>
        /// <remarks>
        ///  rcl_bool_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_bool_array_t
        {
            /// <summary>
            /// Array with bool values
            /// </summary>
            public bool* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclCommon.size_t size;
        }

        /// <summary>
        /// Array of int64_t values
        /// </summary>
        /// <remarks>
        ///  rcl_int64_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_int64_array_t
        {
            /// <summary>
            /// Array with int64 values
            /// </summary>
            public long* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclCommon.size_t size;
        }

        /// <summary>
        /// Array of double values
        /// </summary>
        /// <remarks>
        ///  rcl_double_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_double_array_t
        {
            /// <summary>
            /// Array with double values
            /// </summary>
            public double* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclCommon.size_t size;
        }

        /// <summary>
        /// Array of byte values
        /// </summary>
        /// <remarks>
        ///  rcl_byte_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_byte_array_t
        {
            /// <summary>
            /// Array with uint8_t values
            /// </summary>
            public byte* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclCommon.size_t size;
        }

        /// <summary>
        /// variant_t stores the value of a parameter
        /// </summary>
        /// <remarks>
        /// Only one pointer in this struct will store the value rcl_variant_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_variant_t
        {
            /// <summary>
            /// If bool, gets stored here
            /// </summary>
            public bool* bool_value;

            /// <summary>
            /// If integer, gets stored here
            /// </summary>
            public long* integer_value;

            /// <summary>
            /// If double, gets stored here
            /// </summary>
            public double* double_value;

            /// <summary>
            /// If string, gets stored here
            /// </summary>
            public sbyte* string_value;

            /// <summary>
            /// If array of bytes
            /// </summary>
            public RclCommon.rcl_byte_array_t* byte_array_value;

            /// <summary>
            /// If array of bool's
            /// </summary>
            public RclCommon.rcl_bool_array_t* bool_array_value;

            /// <summary>
            /// If array of integers
            /// </summary>
            public RclCommon.rcl_int64_array_t* integer_array_value;

            /// <summary>
            /// If array of doubles
            /// </summary>
            public RclCommon.rcl_double_array_t* double_array_value;

            /// <summary>
            /// If array of strings
            /// </summary>
            public RclCommon.rcutils_string_array_t* string_array_value;
        }

        /// <summary>
        /// node_params_t stores all the parameters(key:value) of a single node
        /// </summary>
        /// <remarks>
        ///  rcl_node_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_node_params_t
        {
            /// <summary>
            /// Array of parameter names (keys)
            /// </summary>
            public sbyte** parameter_names;

            /// <summary>
            /// Array of coressponding parameter values
            /// </summary>
            public RclCommon.rcl_variant_t* parameter_values;

            /// <summary>
            /// Number of parameters in the node
            /// </summary>
            public RclCommon.size_t num_params;
        }

        /// <summary>
        /// stores all the parameters of all nodes of a process
        /// </summary>
        /// <remarks>
        ///  rcl_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_params_t
        {
            /// <summary>
            /// List of names of the node
            /// </summary>
            public sbyte** node_names;

            /// <summary>
            /// Array of parameters
            /// </summary>
            public RclCommon.rcl_node_params_t* @params;

            /// <summary>
            /// Number of nodes
            /// </summary>
            public RclCommon.size_t num_nodes;

            /// <summary>
            /// Allocator used
            /// </summary>
            public RclCommon.rcutils_allocator_t allocator;
        }

        /// <summary>
        /// Hold output of parsing command line arguments.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_arguments_t
        {
            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Encapsulation of init options and implementation defined init options.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_init_options_t
        {
            /// <summary>
            /// Implementation specific pointer.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Encapsulates the non-global state of an init/shutdown cycle.
        /// </summary>
        /// <remarks>
        /// The context is used in the creation of top level entities like nodes and
        /// guard conditions, as well as to shutdown a specific instance of init.Here is a diagram of a typical context's lifecycle:```
        /// +---------------+
        /// |               |
        /// +--&gt; uninitialized +---&gt; rcl_get_zero_initialized_context() +
        /// |  |               |                                        |
        /// |  +---------------+                                        |
        /// |                                                           |
        /// |           +-----------------------------------------------+
        /// |           |
        /// |  +--------v---------+                +-----------------------+
        /// |  |                  |                |                       |
        /// |  | zero-initialized +-&gt; rcl_init() +-&gt; initialized and valid +-&gt; rcl_shutdown() +
        /// |  |                  |                |                       |                  |
        /// |  +------------------+                +-----------------------+                  |
        /// |                                                                                 |
        /// |               +-----------------------------------------------------------------+
        /// |               |
        /// |  +------------v------------+
        /// |  |                         |
        /// |  | initialized but invalid +---&gt; finalize all entities, then rcl_context_fini() +
        /// |  |                         |                                                    |
        /// |  +-------------------------+                                                    |
        /// |                                                                                 |
        /// +---------------------------------------------------------------------------------+
        /// ```A declared but not defined `rcl_context_t` instance is considered to be
        /// "uninitialized", and passing an uninitialized context to any functions will
        /// result in undefined behavior.
        /// Some functions, like `rcl_init()` require the context instance to be
        /// zero initialized (all members set to "zero" state) before use.Zero initialization of an `rcl_context_t` should be done with
        /// `rcl_get_zero_initialized_context()`, which ensures the context is in a safe
        /// state for initialization with `rcl_init()`.Initialization of an `rcl_context_t` should be done with `rcl_init()`, after
        /// which the context is considered both initialized and valid.
        /// After initialization it can be used in the creation of other entities like
        /// nodes and guard conditions.At any time the context can be invalidated by calling `rcl_shutdown()` on
        /// the `rcl_context_t`, after which the context is still initialized but now
        /// invalid.Invalidation indicates to other entities that the context was shutdown, but
        /// is still accessible for use during cleanup of themselves.After being invalidated, and after all of the entities which used it have
        /// been finalized, the context should be finalized with `rcl_context_fini()`.Finalizing the context while entities which have copies of it have not yet
        /// been finalized is undefined behavior.
        /// Therefore, the context's lifetime (between calls to `rcl_init()` and
        /// `rcl_context_fini()`) should exceed the lifetime of all entities which use
        /// it directly (e.g. nodes and guard conditions) or indirectly (e.g.
        /// subscriptions and topics).
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_context_t
        {
            /// <summary>
            /// Global arguments for all nodes which share this context.
            /// Typically generated by the parsing of argc/argv in `rcl_init()`.
            /// </summary>
            public RclCommon.rcl_arguments_t global_arguments;

            /// <summary>
            /// Implementation specific pointer.
            /// </summary>
            public IntPtr impl;

            /// <summary>
            /// Private storage for instance ID atomic.
            /// </summary>
            /// <remarks>
            /// Accessing the instance id should be done using the function
            /// `rcl_context_get_instance_id()` because the instance id's type is an
            /// atomic and needs to be accessed properly to ensure safety.The instance id should not be changed manually - doing so is undefined
            /// behavior.The instance id cannot be protected within the `impl` pointer's type
            /// because it needs to be accessible even when the context is zero
            /// initialized and therefore `impl` is `NULL`.
            /// Specifically, storing the instance id in the `impl` would introduce a
            /// race condition between accessing it and finalizing the context.
            /// Additionally, C11 atomics (i.e. "stdatomic.h") cannot be used directly
            /// here in the case that this header is included into a C++ program.
            /// See this paper for an effort to make this possible in the future:
            /// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html
            /// </remarks>
            public ulong instance_id_storage; // public fixed byte instance_id_storage[8];
        }

        /// <summary>
        /// Encapsulation of an allocator.
        /// </summary>
        /// <remarks>
        /// The default allocator uses malloc(), free(), calloc(), and realloc().
        /// It can be obtained using rcutils_get_default_allocator().The allocator should be trivially copyable.
        /// Meaning that the struct should continue to work after being assignment
        /// copied into a new struct.
        /// Specifically the object pointed to by the state pointer should remain valid
        /// until all uses of the allocator have been made.
        /// Particular care should be taken when giving an allocator to functions like
        /// rcutils_*_init() where it is stored within another object and used later.
        /// Developers should note that, while the fields of a const-qualified allocator
        /// struct cannot be modified, the state of the allocator can be modified.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_allocator_t : IEquatable<rcl_allocator_t>
        {
            public rcl_allocator_t(RclCommon.rcutils_allocator_t value) => this.Value = value;

            public readonly RclCommon.rcutils_allocator_t Value;

            public bool Equals(rcl_allocator_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_allocator_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclCommon.rcutils_allocator_t(rcl_allocator_t from) => from.Value;

            public static implicit operator rcl_allocator_t(RclCommon.rcutils_allocator_t from) => new rcl_allocator_t(from);

            public static bool operator ==(rcl_allocator_t left, rcl_allocator_t right) => left.Equals(right);

            public static bool operator !=(rcl_allocator_t left, rcl_allocator_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Handle for a rcl guard condition.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_guard_condition_t
        {
            /// <summary>
            /// Context associated with this guard condition.
            /// </summary>
            public RclCommon.rcl_context_t* context;

            /// <summary>
            /// Pointer to the guard condition implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Node.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_node_t
        {
            /// <summary>
            /// Context associated with this node.
            /// </summary>
            public RclCommon.rcl_context_t* context;

            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_publisher_t
        {
            /// <summary>
            /// Pointer to the publisher implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_subscription_t
        {
            /// <summary>
            /// Pointer to the subscription implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Client.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_client_t
        {
            /// <summary>
            /// Pointer to the client implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Options available for a rcl_client_t.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_client_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the client.
            /// </summary>
            public RclCommon.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the client, used for incidental allocations.
            /// For default behavior (malloc/free), use: rcl_get_default_allocator()
            /// </summary>
            public RclCommon.rcl_allocator_t allocator;
        }

        /// <summary>
        /// Options available for a rcl guard condition.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_guard_condition_options_t
        {
            /// <summary>
            /// Custom allocator for the guard condition, used for internal allocations.
            /// </summary>
            public RclCommon.rcl_allocator_t allocator;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Service.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_service_t
        {
            /// <summary>
            /// Pointer to the service implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Options available for a rcl service.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_service_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the service.
            /// </summary>
            public RclCommon.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the service, used for incidental allocations.
            /// For default behavior (malloc/free), see: rcl_get_default_allocator()
            /// </summary>
            public RclCommon.rcl_allocator_t allocator;
        }

        /// <summary>
        /// A duration of time, measured in nanoseconds and its source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_duration_t
        {
            /// <summary>
            /// Duration in nanoseconds and its source.
            /// </summary>
            public long nanoseconds;
        }

        /// <summary>
        /// Struct to describe a jump in time.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_time_jump_t
        {
            /// <summary>
            /// Indicate whether or not the source of time changed.
            /// </summary>
            public RclCommon.rcl_clock_change_t clock_change;

            /// <summary>
            /// The new time minus the last time before the jump.
            /// </summary>
            public RclCommon.rcl_duration_t delta;
        }

        /// <summary>
        /// Describe the prerequisites for calling a time jump callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_jump_threshold_t
        {
            /// <summary>
            /// True to call callback when the clock type changes.
            /// </summary>
            public bool on_clock_change;

            /// <summary>
            /// A positive duration indicating the minimum jump forwards to be considered exceeded, or zero
            /// to disable.
            /// </summary>
            public RclCommon.rcl_duration_t min_forward;

            /// <summary>
            /// A negative duration indicating the minimum jump backwards to be considered exceeded, or zero
            /// to disable.
            /// </summary>
            public RclCommon.rcl_duration_t min_backward;
        }

        /// <summary>
        /// Struct to describe an added callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_jump_callback_info_t
        {
            /// <summary>
            /// Callback to fucntion.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclCommon.rcl_time_jump_t*, bool, void*, void> callback;

            /// <summary>
            /// Threshold to decide when to call the callback.
            /// </summary>
            public RclCommon.rcl_jump_threshold_t threshold;

            /// <summary>
            /// Pointer passed to the callback.
            /// </summary>
            public void* user_data;
        }

        /// <summary>
        /// Encapsulation of a time source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_clock_t
        {
            /// <summary>
            /// Clock type
            /// </summary>
            public RclCommon.rcl_clock_type_t type;

            /// <summary>
            /// An array of added jump callbacks.
            /// </summary>
            public RclCommon.rcl_jump_callback_info_t* jump_callbacks;

            /// <summary>
            /// Number of callbacks in jump_callbacks.
            /// </summary>
            public RclCommon.size_t num_jump_callbacks;

            /// <summary>
            /// Pointer to get_now function
            /// </summary>
            public delegate* unmanaged[Cdecl]<void*, RclCommon.rcl_time_point_value_t*, rcl_ret_t> get_now;

            /// <summary>
            /// void (*set_now) (rcl_time_point_value_t);
            /// Clock storage
            /// </summary>
            public void* data;

            /// <summary>
            /// Custom allocator used for internal allocations.
            /// </summary>
            public RclCommon.rcl_allocator_t allocator;
        }

        /// <summary>
        /// A single point in time, measured in nanoseconds, the reference point is based on the source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_time_point_t
        {
            /// <summary>
            /// Nanoseconds of the point in time
            /// </summary>
            public RclCommon.rcl_time_point_value_t nanoseconds;

            /// <summary>
            /// Clock type of the point in time
            /// </summary>
            public RclCommon.rcl_clock_type_t clock_type;
        }

        /// <summary>
        /// Structure which encapsulates a ROS Timer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_timer_t
        {
            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Structure which encapsulates a ROS QoS event handle.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_event_t
        {
            /// <summary>
            /// Pointer to the event implementation
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Container for subscription's, guard condition's, etc to be waited on.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_wait_set_t
        {
            /// <summary>
            /// Storage for subscription pointers.
            /// </summary>
            public RclCommon.rcl_subscription_t** subscriptions;

            /// <summary>
            /// Number of subscriptions
            /// </summary>
            public RclCommon.size_t size_of_subscriptions;

            /// <summary>
            /// Storage for guard condition pointers.
            /// </summary>
            public RclCommon.rcl_guard_condition_t** guard_conditions;

            /// <summary>
            /// Number of guard_conditions
            /// </summary>
            public RclCommon.size_t size_of_guard_conditions;

            /// <summary>
            /// Storage for timer pointers.
            /// </summary>
            public RclCommon.rcl_timer_t** timers;

            /// <summary>
            /// Number of timers
            /// </summary>
            public RclCommon.size_t size_of_timers;

            /// <summary>
            /// Storage for client pointers.
            /// </summary>
            public RclCommon.rcl_client_t** clients;

            /// <summary>
            /// Number of clients
            /// </summary>
            public RclCommon.size_t size_of_clients;

            /// <summary>
            /// Storage for service pointers.
            /// </summary>
            public RclCommon.rcl_service_t** services;

            /// <summary>
            /// Number of services
            /// </summary>
            public RclCommon.size_t size_of_services;

            /// <summary>
            /// Storage for event pointers.
            /// </summary>
            public RclCommon.rcl_event_t** events;

            /// <summary>
            /// Number of events
            /// </summary>
            public RclCommon.size_t size_of_events;

            /// <summary>
            /// Implementation specific storage.
            /// </summary>
            public IntPtr impl;
        }

        /// <summary>
        /// Associative array of topic or service names and types.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_names_and_types_t
        {
            /// <summary>
            /// Array of names
            /// </summary>
            public RclCommon.rcutils_string_array_t names;

            /// <summary>
            /// Dynamic array of arrays of type names, with the same length as `names`
            /// </summary>
            public RclCommon.rcutils_string_array_t* types;
        }

        /// <summary>
        /// A data structure that encapsulates the node name, node namespace,
        /// topic_type, gid, and qos_profile of publishers and subscriptions
        /// for a topic.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_topic_endpoint_info_t
        {
            /// <summary>
            /// Name of the node
            /// </summary>
            public byte* node_name;

            /// <summary>
            /// Namespace of the node
            /// </summary>
            public byte* node_namespace;

            /// <summary>
            /// The associated topic type
            /// </summary>
            public byte* topic_type;

            /// <summary>
            /// The endpoint type
            /// </summary>
            public RclCommon.rmw_endpoint_type_t endpoint_type;

            /// <summary>
            /// The GID of the endpoint
            /// </summary>
            public fixed byte endpoint_gid[24];

            /// <summary>
            /// QoS profile of the endpoint
            /// </summary>
            public RclCommon.rmw_qos_profile_t qos_profile;
        }

        /// <summary>
        /// Array of topic endpoint information
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_topic_endpoint_info_array_t
        {
            /// <summary>
            /// Size of the array.
            /// </summary>
            public RclCommon.size_t size;

            /// <summary>
            /// Contiguous storage for topic endpoint information elements.
            /// </summary>
            public RclCommon.rmw_topic_endpoint_info_t* info_array;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_context_instance_id_t : IEquatable<rcl_context_instance_id_t>
        {
            public rcl_context_instance_id_t(ulong value) => this.Value = value;

            public readonly ulong Value;

            public bool Equals(rcl_context_instance_id_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_context_instance_id_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator ulong(rcl_context_instance_id_t from) => from.Value;

            public static implicit operator rcl_context_instance_id_t(ulong from) => new rcl_context_instance_id_t(from);

            public static bool operator ==(rcl_context_instance_id_t left, rcl_context_instance_id_t right) => left.Equals(right);

            public static bool operator !=(rcl_context_instance_id_t left, rcl_context_instance_id_t right) => !left.Equals(right);
        }

        /// <summary>
        /// A data structure that encapsulates the node name, node namespace,
        /// topic_type, gid, and qos_profile of publishers and subscriptions
        /// for a topic.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_topic_endpoint_info_t : IEquatable<rcl_topic_endpoint_info_t>
        {
            public rcl_topic_endpoint_info_t(RclCommon.rmw_topic_endpoint_info_t value) => this.Value = value;

            public readonly RclCommon.rmw_topic_endpoint_info_t Value;

            public bool Equals(rcl_topic_endpoint_info_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_topic_endpoint_info_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclCommon.rmw_topic_endpoint_info_t(rcl_topic_endpoint_info_t from) => from.Value;

            public static implicit operator rcl_topic_endpoint_info_t(RclCommon.rmw_topic_endpoint_info_t from) => new rcl_topic_endpoint_info_t(from);

            public static bool operator ==(rcl_topic_endpoint_info_t left, rcl_topic_endpoint_info_t right) => left.Equals(right);

            public static bool operator !=(rcl_topic_endpoint_info_t left, rcl_topic_endpoint_info_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Return a properly initialized rcutils_allocator_t with default values.
        /// </summary>
        /// <remarks>
        /// This defaults to:- allocate = wraps malloc()
        /// - deallocate = wraps free()
        /// - reallocate = wraps realloc()
        /// - zero_allocate = wraps calloc()
        /// - state = `NULL`&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcutils_allocator_t rcutils_get_default_allocator();

        /// <summary>
        /// Return `true` if the error is set, otherwise `false`.
        /// </summary>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_error_is_set();

        /// <summary>
        /// Return the error message followed by `, at 
        /// &lt;file
        /// &gt;:
        /// &lt;line
        /// &gt;` if set, else "error not set".
        /// </summary>
        /// <returns>The current error string, with file and line number, or "error not set" if not set.</returns>
        /// <remarks>
        /// This function is "safe" because it returns a copy of the current error
        /// string or one containing the string "error not set" if no error was set.
        /// This ensures that the copy is owned by the calling thread and is therefore
        /// never invalidated by other error handling calls, and that the C string
        /// inside is always valid and null terminated.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcutils_error_string_t rcutils_get_error_string();

        /// <summary>
        /// Reset the error state by clearing any previously set error state.
        /// </summary>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern void rcutils_reset_error();
      
        /// <summary>
        /// Finalize a string array, reclaiming all resources.
        /// </summary>
        /// <param name="string_array">object to be finalized</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function reclaims any memory owned by the string array, including the
        /// strings it references.The allocator used to initialize the string array is used to deallocate each
        /// string in the array and the array of strings itself.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcutils_string_array_fini(RclCommon.rcutils_string_array_t* string_array);

        /// <summary>
        /// Return a rcl_arguments_t struct with members initialized to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_arguments_t rcl_get_zero_initialized_arguments();

        /// <summary>
        /// Parse command line arguments into a structure usable by code.
        /// </summary>
        /// <param name="argc">The number of arguments in argv.</param>
        /// <param name="args_output">A structure that will contain the result of parsing.
        /// Must be zero initialized before use.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="argv">The values of the arguments.</param>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or</returns>
        /// <returns>`RCL_RET_OK` if the arguments were parsed successfully, or</returns>
        /// <remarks>
        /// ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double
        /// dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.
        /// Successfully parsed remap rules are stored in the order they were given in `argv`.
        /// If given arguments `{"__ns:=/foo", "__ns:=/bar"}` then the namespace used by nodes in this
        /// process will be `/foo` and not `/bar`.Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`
        /// or `-p name:=value`.The default log level will be parsed as `--log-level level`, where `level` is a name
        /// representing one of the log levels in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`,
        /// `warn`, not case sensitive.
        /// If multiple of these rules are found, the last one parsed will be used.If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by
        /// anything but a valid remap rule, parsing will fail immediately.If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_get_zero_initialized_arguments()"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_parse_arguments(int argc, byte** argv, RclCommon.rcl_allocator_t allocator, RclCommon.rcl_arguments_t* args_output);

        /// <summary>
        /// Return the number of arguments that were not ROS specific arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of unparsed arguments, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_count_unparsed(RclCommon.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of indices to non ROS specific arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="output_unparsed_indices">An allocated array of indices into the original argv array.
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no unparsed args then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.
        /// This function populates an array of indices to these arguments in the original argv array.
        /// Since the first argument is always assumed to be a process name, the list will always contain
        /// the index 0.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_get_unparsed(RclCommon.rcl_arguments_t* args, RclCommon.rcl_allocator_t allocator, int** output_unparsed_indices);

        /// <summary>
        /// Return the number of ROS specific arguments that were not successfully parsed.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of unparsed ROS specific arguments, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_count_unparsed_ros(RclCommon.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of indices to unknown ROS specific arguments that were left unparsed.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="output_unparsed_ros_indices">An allocated array of indices into the original argv array.
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no unparsed ROS specific arguments then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Some ROS specific arguments may not have been recognized, or were not intended to be
        /// parsed by rcl.
        /// This function populates an array of indices to these arguments in the original argv array.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_get_unparsed_ros(RclCommon.rcl_arguments_t* args, RclCommon.rcl_allocator_t allocator, int** output_unparsed_ros_indices);

        /// <summary>
        /// Return the number of parameter yaml files given in the arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of yaml files, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_param_files_count(RclCommon.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of yaml parameter file paths specified on the command line.
        /// </summary>
        /// <param name="arguments">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="parameter_files">An allocated array of paramter file names.
        /// This array must be deallocated by the caller using the given allocator.
        /// The output is NULL if there were no paramter files.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_get_param_files(RclCommon.rcl_arguments_t* arguments, RclCommon.rcl_allocator_t allocator, sbyte*** parameter_files);

        /// <summary>
        /// Return all parameter overrides parsed from the command line.
        /// </summary>
        /// <param name="arguments">An arguments structure that has been parsed.</param>
        /// <param name="parameter_overrides">Parameter overrides as parsed from command line arguments.
        /// This structure must be finalized by the caller.
        /// The output is NULL if no parameter overrides were parsed.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Parameter overrides are parsed directly from command line arguments and
        /// parameter files provided in the command line.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_get_param_overrides(RclCommon.rcl_arguments_t* arguments, RclCommon.rcl_params_t** parameter_overrides);

        /// <summary>
        /// Return a list of arguments with ROS-specific arguments removed.
        /// </summary>
        /// <param name="argv">The argument vector</param>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="nonros_argc">The count of arguments that aren't ROS-specific</param>
        /// <param name="nonros_argv">An allocated array of arguments that aren't ROS-specific
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no non-ROS args, then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Some arguments may not have been intended as ROS arguments.
        /// This function populates an array of the aruments in a new argv array.
        /// Since the first argument is always assumed to be a process name, the list
        /// will always contain the first value from the argument vector.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_remove_ros_arguments(byte** argv, RclCommon.rcl_arguments_t* args, RclCommon.rcl_allocator_t allocator, int* nonros_argc, byte*** nonros_argv);

        /// <summary>
        /// Copy one arguments structure into another.
        /// </summary>
        /// <param name="args">The structure to be copied.
        /// Its allocator is used to copy memory into the new structure.</param>
        /// <param name="args_out">A zero-initialized arguments structure to be copied into.</param>
        /// <returns>`RCL_RET_OK` if the structure was copied successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_copy(RclCommon.rcl_arguments_t* args, RclCommon.rcl_arguments_t* args_out);

        /// <summary>
        /// Reclaim resources held inside rcl_arguments_t structure.
        /// </summary>
        /// <param name="args">The structure to be deallocated.</param>
        /// <returns>`RCL_RET_OK` if the memory was successfully freed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_arguments_fini(RclCommon.rcl_arguments_t* args);

        /// <summary>
        /// Return a zero initialized rcl_init_options_t struct.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_init_options_t rcl_get_zero_initialized_init_options();

        /// <summary>
        /// Initialize given init_options with the default values and implementation specific values.
        /// </summary>
        /// <param name="init_options">object to be setup</param>
        /// <param name="allocator">to be used during setup and during initialization</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if init_options has already be initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given allocator is used, if required, during setup of the init options,
        /// but is also used during initialization.In either case the given allocator is stored in the returned init options.The `impl` pointer should not be changed manually.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init_options_init(RclCommon.rcl_init_options_t* init_options, RclCommon.rcl_allocator_t allocator);

        /// <summary>
        /// Copy the given source init_options to the destination init_options.
        /// </summary>
        /// <param name="src">rcl_init_options_t object to be copied from</param>
        /// <param name="dst">rcl_init_options_t object to be copied into</param>
        /// <returns>`RCL_RET_OK` if the copy is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the dst has already be initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The allocator from the source is used for any allocations and stored in the
        /// destination.The destination should either be zero initialized with
        /// `rcl_get_zero_initialized_init_options()` or should have had
        /// `rcl_init_options_fini()` called on it.
        /// Giving an already initialized init options for the destination will result
        /// in a failure with return code `RCL_RET_ALREADY_INIT`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init_options_copy(RclCommon.rcl_init_options_t* src, RclCommon.rcl_init_options_t* dst);

        /// <summary>
        /// Finalize the given init_options.
        /// </summary>
        /// <param name="init_options">object to be setup</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given init_options must be non-`NULL` and valid, i.e. had
        /// `rcl_init_options_init()` called on it but not this function yet.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init_options_fini(RclCommon.rcl_init_options_t* init_options);

        /// <summary>
        /// Return the domain_id stored in the init options.
        /// </summary>
        /// <param name="init_options">object from which the domain id should be retrieved.</param>
        /// <param name="domain_id">domain id to be set in init_options object.</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid.</returns>
        /// <remarks>
        /// Get the domain id from the specified rcl_init_options_t object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init_options_get_domain_id(RclCommon.rcl_init_options_t* init_options, RclCommon.size_t* domain_id);

        /// <summary>
        /// Set a domain id in the init options provided.
        /// </summary>
        /// <param name="init_options">objects in which to set the specified domain id.</param>
        /// <param name="domain_id">domain id to be set in init_options object.</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid.</returns>
        /// <remarks>
        /// Store the domain id in the specified init_options object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init_options_set_domain_id(RclCommon.rcl_init_options_t* init_options, RclCommon.size_t domain_id);

        /// <summary>
        /// Return the rmw init options which are stored internally.
        /// </summary>
        /// <param name="init_options">object from which the rmw init options should be retrieved</param>
        /// <returns>pointer to the the rcl init options, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - init_options is NULL
        /// - init_options is invalid, e.g. init_options-&gt;impl is NULLIf NULL is returned an error message will have been set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rmw_init_options_t* rcl_init_options_get_rmw_init_options(RclCommon.rcl_init_options_t* init_options);

        /// <summary>
        /// Return the allocator stored in the init_options.
        /// </summary>
        /// <param name="init_options">object from which the allocator should be retrieved</param>
        /// <returns>pointer to the rcl allocator, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - init_options is NULL
        /// - init_options is invalid, e.g. init_options-&gt;impl is NULLIf NULL is returned an error message will have been set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_allocator_t* rcl_init_options_get_allocator(RclCommon.rcl_init_options_t* init_options);

        /// <summary>
        /// Return a zero initialization context object.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_context_t rcl_get_zero_initialized_context();

        /// <summary>
        /// Finalize a context.
        /// </summary>
        /// <param name="context">object to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the shutdown was completed successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The context to be finalized must have been previously initialized with
        /// `rcl_init()`, and then later invalidated with `rcl_shutdown()`.
        /// A zero-initialized context that has not been initialized can be finalized.
        /// If context is `NULL`, then `RCL_RET_INVALID_ARGUMENT` is returned.
        /// If context is zero-initialized, then `RCL_RET_OK` is returned.
        /// If context is initialized and valid (`rcl_shutdown()` was not called on it),
        /// then `RCL_RET_INVALID_ARGUMENT` is returned.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_context_fini(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Return the init options used during initialization for this context.
        /// </summary>
        /// <param name="context">object from which the init options should be retrieved</param>
        /// <returns>pointer to the the init options, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - context is NULL
        /// - context is zero-initialized, e.g. context-&gt;impl is `NULL`If context is uninitialized then that is undefined behavior.If `NULL` is returned an error message will have been set.The options are for reference only, and therefore the returned pointer is
        /// const.
        /// Changing the values in the options is undefined behavior but will likely
        /// have no effect.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_init_options_t* rcl_context_get_init_options(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
        /// </summary>
        /// <param name="context">object from which the instance id should be retrieved</param>
        /// <returns>a unique id specific to this context instance, or</returns>
        /// <returns>`0` if invalid, or</returns>
        /// <returns>`0` if context is `NULL`</returns>
        /// <remarks>
        /// The given context must be non-`NULL`, but does not need to be initialized or valid.
        /// If context is `NULL`, then `0` will be returned.
        /// If context is uninitialized, then it is undefined behavior.The instance ID may be `0` if the context is zero-initialized or if the
        /// context has been invalidated by `rcl_shutdown()`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_context_instance_id_t rcl_context_get_instance_id(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Return `true` if the given context is currently valid, otherwise `false`.
        /// </summary>
        /// <param name="context">object which should be checked for validity</param>
        /// <returns>`true` if valid, otherwise `false`</returns>
        /// <remarks>
        /// If context is `NULL`, then `false` is returned.
        /// If context is zero-initialized, then `false` is returned.
        /// If context is uninitialized, then it is undefined behavior.Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_context_is_valid(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
        /// </summary>
        /// <param name="context">object from which the rmw context should be retrieved.</param>
        /// <returns>pointer to rmw context if valid, otherwise `NULL`</returns>
        /// <remarks>
        /// If context is `NULL`, then `NULL` is returned.
        /// If context is zero-initialized, then `NULL` is returned.
        /// If context is uninitialized, then it is undefined behavior.Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rmw_context_t* rcl_context_get_rmw_context(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Initialization of rcl.
        /// </summary>
        /// <param name="argc">number of strings in argv</param>
        /// <param name="argv">command line arguments; rcl specific arguments are removed</param>
        /// <param name="options">options used during initialization</param>
        /// <param name="context">resulting context object that represents this init</param>
        /// <returns>`RCL_RET_OK` if initialization is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if rcl_init has already been called, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function can be run any number of times, so long as the given context
        /// has been properly prepared.The given `rcl_context_t` must be zero initialized with the function
        /// `rcl_get_zero_initialized_context()` and must not be already initialized
        /// by this function.
        /// If the context is already initialized this function will fail and return the
        /// `RCL_RET_ALREADY_INIT` error code.
        /// A context may be initialized again after it has been finalized with the
        /// `rcl_shutdown()` function and zero initialized again with
        /// `rcl_get_zero_initialized_context()`.The `argc` and `argv` parameters may contain command line arguments for the
        /// program.
        /// rcl specific arguments will be parsed, but not removed.
        /// If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.The `options` argument must be non-`NULL` and must have been initialized
        /// with `rcl_init_options_init()`.
        /// It is unmodified by this function, and the ownership is not transfered to
        /// the context, but instead a copy is made into the context for later reference.
        /// Therefore, the given options need to be cleaned up with
        /// `rcl_init_options_fini()` after this function returns.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_init(int argc, byte** argv, RclCommon.rcl_init_options_t* options, RclCommon.rcl_context_t* context);

        /// <summary>
        /// Shutdown a given rcl context.
        /// </summary>
        /// <param name="context">object to shutdown</param>
        /// <returns>`RCL_RET_OK` if the shutdown was completed successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_SHUTDOWN` if the context is not currently valid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The given context must have been initialized with `rcl_init()`.
        /// If not, this function will fail with `RCL_RET_ALREADY_SHUTDOWN`.When this function is called:
        /// - Any rcl objects created using this context are invalidated.
        /// - Functions called on invalid objects may or may not fail.
        /// - Calls to `rcl_context_is_initialized()` will return `false`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_shutdown(RclCommon.rcl_context_t* context);

        /// <summary>
        /// Determine the default domain ID, based on the environment.
        /// </summary>
        /// <param name="domain_id">Must not be NULL.</param>
        /// <returns>RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,</returns>
        /// <returns>RCL_RET_ERROR in case of an unexpected error, or,</returns>
        /// <returns>RCL_RET_OK.</returns>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_default_domain_id(RclCommon.size_t* domain_id);

        /// <summary>
        /// Copy one options structure into another.
        /// </summary>
        /// <param name="options">The structure to be copied.
        /// Its allocator is used to copy memory into the new structure.</param>
        /// <param name="options_out">An options structure containing default values.</param>
        /// <returns>`RCL_RET_OK` if the structure was copied successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_node_options_copy(void* options, void* options_out);

        /// <summary>
        /// Finalize the given node_options.
        /// </summary>
        /// <param name="options">object to be finalized</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given node_options must be non-`NULL` and valid, i.e. had
        /// `rcl_node_get_default_options()` called on it but not this function yet.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_node_options_fini(void* options);

        /// <summary>
        /// Return a rcl_node_t struct with members initialized to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_node_t rcl_get_zero_initialized_node();

        /// <summary>
        /// Initialize a ROS node.
        /// </summary>
        /// <param name="options">the node options.
        /// The options are deep copied into the node.
        /// The caller is always responsible for freeing memory used options they
        /// pass in.</param>
        /// <param name="node">a preallocated rcl_node_t</param>
        /// <param name="name">the name of the node, must be a valid c-string</param>
        /// <param name="namespace_">the namespace of the node, must be a valid c-string</param>
        /// <param name="context">the context instance with which the node should be
        /// associated</param>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the namespace_ is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the name is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_OK` if the node was initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the node has already be initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <remarks>
        /// Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown
        /// is called or until rcl_node_fini is called on it.After calling, the ROS node object can be used to create other middleware
        /// primitives like publishers, services, parameters, etc.The name of the node must not be NULL and adhere to naming restrictions,
        /// see the rmw_validate_node_name() function for rules.The name of the node cannot coincide with another node of the same name.
        /// If a node of the same name is already in the domain, it will be shutdown.The namespace of the node should not be NULL and should also pass the
        /// rmw_validate_namespace() function's rules.Additionally this function allows namespaces which lack a leading forward
        /// slash.
        /// Because there is no notion of a relative namespace, there is no difference
        /// between a namespace which lacks a forward and the same namespace with a
        /// leasing forward slash.
        /// Therefore, a namespace like ``"foo/bar"`` is automatically changed to
        /// ``"/foo/bar"`` by this function.
        /// Similarly, the namespace ``""`` will implicitly become ``"/"`` which is a
        /// valid namespace.A node contains infrastructure for ROS parameters, which include advertising
        /// publishers and service servers.
        /// This function will create those external parameter interfaces even if
        /// parameters are not used later.The rcl_node_t given must be allocated and zero initialized.
        /// Passing an rcl_node_t which has already had this function called on it, more
        /// recently than rcl_node_fini, will fail.
        /// An allocated rcl_node_t with uninitialized memory is undefined behavior.Expected usage:```c
        /// rcl_context_t context = rcl_get_zero_initialized_context();
        /// // ... initialize the context with rcl_init()
        /// rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// // ... node options customization
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/node_ns", 
        /// &amp;context
        /// , 
        /// &amp;node
        /// _ops);
        /// // ... error handling and then use the node, but eventually deinitialize it:
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// the context handle must be allocated, initialized, and valid
        /// </pre>
        /// <pre>
        /// the node handle must be allocated, zero initialized, and invalid
        /// </pre>
        /// <todo>
        /// TODO(wjwwood):
        /// Parameter infrastructure is currently initialized in the language specific
        /// client library, e.g. rclcpp for C++, but will be initialized here in the
        /// future. When that happens there will be an option to avoid parameter
        /// infrastructure with an option in the rcl_node_options_t struct.
        /// </todo>
        /// <post>
        /// the node handle is valid and can be used in other `rcl_*` functions
        /// </post>
        /// <todo>
        /// TODO(wjwwood): node name uniqueness is no yet enforced
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_node_init(RclCommon.rcl_node_t* node, byte* name, byte* namespace_, RclCommon.rcl_context_t* context, void* options);

        /// <summary>
        /// Finalize a rcl_node_t.
        /// </summary>
        /// <param name="node">rcl_node_t to be finalized</param>
        /// <returns>`RCL_RET_OK` if node was finalized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node pointer is null, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Destroys any automatically created infrastructure and deallocates memory.
        /// After calling, the rcl_node_t can be safely deallocated.All middleware primitives created by the user, e.g. publishers, services, etc,
        /// which were created from this node must be finalized using their respective
        /// `rcl_*_fini()` functions before this is called.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_node_fini(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return `true` if the node is valid, else `false`.
        /// </summary>
        /// <param name="node">rcl_node_t to be validated</param>
        /// <returns>`true` if the node and allocator are valid, otherwise `false`.</returns>
        /// <remarks>
        /// Also return `false` if the node pointer is `NULL` or the allocator is invalid.A node is invalid if:
        /// - the implementation is `NULL` (rcl_node_init not called or failed)
        /// - rcl_shutdown has been called since the node has been initialized
        /// - the node has been finalized with rcl_node_finiThere is a possible validity race condition.Consider:```c
        /// assert(rcl_node_is_valid(node));  // 
        /// &lt;
        /// -- thread 1
        /// rcl_shutdown();                   // 
        /// &lt;
        /// -- thread 2
        /// // use node as if valid           // 
        /// &lt;
        /// -- thread 1
        /// ```In the third line the node is now invalid, even though on the previous line
        /// of thread 1 it was checked to be valid.
        /// This is why this function is considered not thread-safe.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_node_is_valid(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return true if node is valid, except for the context being valid.
        /// </summary>
        /// <remarks>
        /// This is used in clean up functions that need to access the node, but do not
        /// need use any functions with the context.It is identical to rcl_node_is_valid except it ignores the state of the
        /// context associated with the node.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_node_is_valid_except_context(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal name string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_name(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the namespace of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal namespace string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_namespace(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the fully qualified name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>fully qualified name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal namespace and name combined string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_fully_qualified_name(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the rcl node options.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal options struct.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned struct is only valid as long as the given rcl_node_t is valid.
        /// The values in the struct may change if the options of the rcl_node_t changes,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern void* rcl_node_get_options(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the ROS domain ID that the node is using.
        /// </summary>
        /// <param name="node">the handle to the node being queried</param>
        /// <param name="domain_id">storage for the domain id</param>
        /// <returns>`RCL_RET_OK` if node the domain ID was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function returns the ROS domain ID that the node is in.This function should be used to determine what `domain_id` was used rather
        /// than checking the domain_id field in the node options, because if
        /// `RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID` is used when creating the node then
        /// it is not changed after creation, but this function will return the actual
        /// `domain_id` used.The `domain_id` field must point to an allocated `size_t` object to which
        /// the ROS domain ID will be written.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_node_get_domain_id(RclCommon.rcl_node_t* node, RclCommon.size_t* domain_id);

        /// <summary>
        /// Return the associated rcl instance id.
        /// </summary>
        /// <param name="node">pointer to the rcl node</param>
        /// <returns>rcl instance id captured during node init or `0` on error</returns>
        /// <remarks>
        /// This id is stored when rcl_node_init is called and can be compared with the
        /// value returned by rcl_get_instance_id() to check if this node was created in
        /// the current rcl context (since the latest call to rcl_init().This function can fail, and therefore return `0`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)This function will succeed even if rcl_shutdown() has been called
        /// since the node was created.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong rcl_node_get_rcl_instance_id(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return a guard condition which is triggered when the ROS graph changes.
        /// </summary>
        /// <param name="node">pointer to the rcl node</param>
        /// <returns>rcl guard condition handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to an internally held rcl guard condition.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node is invalidThe returned handle is made invalid if the node is finialized or if
        /// rcl_shutdown() is called.The guard condition will be triggered anytime a change to the ROS graph occurs.
        /// A ROS graph change includes things like (but not limited to) a new publisher
        /// advertises, a new subscription is created, a new service becomes available,
        /// a subscription is canceled, etc.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood): link to exhaustive list of graph events
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_guard_condition_t* rcl_node_get_graph_guard_condition(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the logger name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>logger_name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal logger name string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_logger_name(RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return a rcl_publisher_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_publisher_t before passing to
        /// rcl_publisher_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_publisher_t rcl_get_zero_initialized_publisher();

        /// <summary>
        /// Initialize a rcl publisher.
        /// </summary>
        /// <param name="publisher">preallocated publisher structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the topic's type</param>
        /// <param name="topic_name">the name of the topic to publish on</param>
        /// <param name="options">publisher options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if the publisher was initialized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the publisher is already initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_publisher_t, it can be used to publish
        /// messages of the given type to the given topic using rcl_publish().The given rcl_node_t must be valid and the resulting rcl_publisher_t is only
        /// valid as long as the given rcl_node_t remains valid.The rosidl_message_type_support_t is obtained on a per .msg type basis.
        /// When the user defines a ROS message, code is generated which provides the
        /// required rosidl_message_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `std_msgs/String`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _typesupport_cpp/message_type_support.hpp&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.hpp&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// rosidl_typesupport_cpp::get_message_type_support_handle
        /// &lt;std
        /// _msgs::msg::String&gt;();
        /// ```The rosidl_message_type_support_t object contains message type specific
        /// information used to publish messages.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// publisher to allocate space for incidentals, e.g. the topic name string.Expected usage (for C messages):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();
        /// rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();
        /// ret = rcl_publisher_init(
        /// &amp;publisher
        /// , 
        /// &amp;node
        /// , ts, "chatter", 
        /// &amp;publisher
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_publisher_fini(
        /// &amp;publisher
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_publisher_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_deinitialize_node()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publisher_init(RclCommon.rcl_publisher_t* publisher, RclCommon.rcl_node_t* node, MessageTypeSupport* type_support, byte* topic_name, void* options);

        /// <summary>
        /// Finalize a rcl_publisher_t.
        /// </summary>
        /// <param name="publisher">handle to the publisher to be finalized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the publisher</param>
        /// <returns>`RCL_RET_OK` if publisher was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer be advertising that it is publishing
        /// on this topic (assuming this is the only publisher on this topic).After calling, calls to rcl_publish will fail when using this publisher.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publisher_fini(RclCommon.rcl_publisher_t* publisher, RclCommon.rcl_node_t* node);

        /// <summary>
        /// Publish a ROS message on a topic using a publisher.
        /// </summary>
        /// <param name="publisher">handle to the publisher which will do the publishing</param>
        /// <param name="ros_message">type-erased pointer to the ROS message</param>
        /// <param name="allocation">structure pointer, used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was published successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_message
        /// parameter and the type associate with the publisher (via the type support)
        /// match.
        /// Passing a different type to publish produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.Calling rcl_publish() is a potentially blocking call.
        /// When called rcl_publish() will immediately do any publishing related work,
        /// including, but not limited to, converting the message into a different type,
        /// serializing the message, collecting publish statistics, etc.
        /// The last thing it will do is call the underlying middleware's publish
        /// function which may or may not block based on the quality of service settings
        /// given via the publisher options in rcl_publisher_init().
        /// For example, if the reliability is set to reliable, then a publish may block
        /// until space in the publish queue is available, but if the reliability is set
        /// to best effort then it should not block.The ROS message given by the `ros_message` void pointer is always owned by
        /// the calling code, but should remain constant during publish.This function is thread safe so long as access to both the publisher and the
        /// `ros_message` is synchronized.
        /// That means that calling rcl_publish() from multiple threads is allowed, but
        /// calling rcl_publish() at the same time as non-thread safe publisher
        /// functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()
        /// concurrently is not allowed.
        /// Before calling rcl_publish() the message can change and after calling
        /// rcl_publish() the message can change, but it cannot be changed during the
        /// publish call.
        /// The same `ros_message`, however, can be passed to multiple calls of
        /// rcl_publish() simultaneously, even if the publishers differ.
        /// The `ros_message` is unmodified by rcl_publish().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of publishers and messages, see above for more&lt;/i&gt;
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood):
        /// The blocking behavior of publish is a still a point of dispute.
        /// This section should be updated once the behavior is clearly defined.
        /// See: https://github.com/ros2/ros2/issues/255
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publish(RclCommon.rcl_publisher_t* publisher, void* ros_message, RclCommon.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
        /// </summary>
        /// <param name="publisher">handle to the publisher that needs liveliness to be asserted</param>
        /// <returns>`RCL_RET_OK` if the liveliness assertion was completed successfully, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
        /// this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
        /// of the system that this Node is still alive.
        /// This function must be called at least as often as the qos_profile's liveliness_lease_duration&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publisher_assert_liveliness(RclCommon.rcl_publisher_t* publisher);

        /// <summary>
        /// Get the topic name for the publisher.
        /// </summary>
        /// <param name="publisher">pointer to the publisher</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the publisher's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - publisher is `NULL`
        /// - publisher is invalid (never called init, called fini, or invalid node)The returned string is only valid as long as the rcl_publisher_t is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_publisher_get_topic_name(RclCommon.rcl_publisher_t* publisher);

        /// <summary>
        /// Return true if the publisher is valid, otherwise false.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>`true` if `publisher` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `publisher` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_publisher_is_valid(RclCommon.rcl_publisher_t* publisher);

        /// <summary>
        /// Get the number of subscriptions matched to a publisher.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <param name="subscription_count">number of matched subscriptions</param>
        /// <returns>`RCL_RET_OK` if the count was retrieved, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Used to get the internal count of subscriptions matched to a publisher.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] only if the underlying rmw doesn't make use of this feature &lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publisher_get_subscription_count(RclCommon.rcl_publisher_t* publisher, RclCommon.size_t* subscription_count);

        /// <summary>
        /// Get the actual qos settings of the publisher.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>qos struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// Used to get the actual qos settings of the publisher.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the publisher, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.
        /// The returned struct is only valid as long as the rcl_publisher_t is valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rmw_qos_profile_t* rcl_publisher_get_actual_qos(RclCommon.rcl_publisher_t* publisher);


        /// <summary>
        /// Return a rcl_subscription_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_subscription_t before passing to
        /// rcl_subscription_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_subscription_t rcl_get_zero_initialized_subscription();

        /// <summary>
        /// Initialize a ROS subscription.
        /// </summary>
        /// <param name="subscription">preallocated subscription structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the topic's type</param>
        /// <param name="topic_name">the name of the topic</param>
        /// <param name="options">subscription options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if subscription was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the subcription is already initialized, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_subscription_t, it can be used to take
        /// messages of the given type to the given topic using rcl_take().The given rcl_node_t must be valid and the resulting rcl_subscription_t is
        /// only valid as long as the given rcl_node_t remains valid.The rosidl_message_type_support_t is obtained on a per .msg type basis.
        /// When the user defines a ROS message, code is generated which provides the
        /// required rosidl_message_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// ```For C++ a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _runtime_cpp/message_type_support.hpp&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msgs/string.hpp&gt;
        /// using rosidl_typesupport_cpp::get_message_type_support_handle;
        /// const rosidl_message_type_support_t * string_ts =
        /// get_message_type_support_handle
        /// &lt;std
        /// _msgs::msg::String&gt;();
        /// ```The rosidl_message_type_support_t object contains message type specific
        /// information used to publish messages.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when (de)initializing the
        /// subscription to allocate space for incidental things, e.g. the topic
        /// name string.Expected usage (for C messages):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_message_type_support_t * ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();
        /// rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();
        /// ret = rcl_subscription_init(
        /// &amp;subscription
        /// , 
        /// &amp;node
        /// , ts, "chatter", 
        /// &amp;subscription
        /// _ops);
        /// // ... error handling, and when finished deinitialization
        /// ret = rcl_subscription_fini(
        /// &amp;subscription
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_subscription_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// For C a macro can be used (for example `std_msgs/String`):
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_subscription_init(RclCommon.rcl_subscription_t* subscription, RclCommon.rcl_node_t* node, MessageTypeSupport* type_support, byte* topic_name, void* options);

        /// <summary>
        /// Finalize a rcl_subscription_t.
        /// </summary>
        /// <param name="subscription">handle to the subscription to be deinitialized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the subscription</param>
        /// <returns>`RCL_RET_OK` if subscription was deinitialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer be subscribed on this topic
        /// (assuming this is the only subscription on this topic in this node).After calling, calls to rcl_wait and rcl_take will fail when using this
        /// subscription.
        /// Additioanlly rcl_wait will be interrupted if currently blocking.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_subscription_fini(RclCommon.rcl_subscription_t* subscription, RclCommon.rcl_node_t* node);

        /// <summary>
        /// Take a ROS message from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take</param>
        /// <param name="ros_message">type-erased ptr to a allocated ROS message</param>
        /// <param name="message_info">rmw struct which contains meta-data for the message</param>
        /// <param name="allocation">structure pointer used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
        /// occurred in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_message
        /// argument and the type associated with the subscription, via the type
        /// support, match.
        /// Passing a different type to rcl_take produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.TODO(wjwwood) blocking of take?
        /// TODO(wjwwood) pre-, during-, and post-conditions for message ownership?
        /// TODO(wjwwood) is rcl_take thread-safe?
        /// TODO(wjwwood) Should there be an rcl_message_info_t?The ros_message pointer should point to an already allocated ROS message
        /// struct of the correct type, into which the taken ROS message will be copied
        /// if one is available.
        /// If taken is false after calling, then the ROS message will be unmodified.The taken boolean may be false even if a wait set reports that the
        /// subscription was ready to be taken from in some cases, e.g. when the
        /// state of the subscription changes it may cause the wait set to wake up
        /// but subsequent takes to fail to take anything.If allocation is required when taking the message, e.g. if space needs to
        /// be allocated for a dynamically sized array in the target message, then the
        /// allocator given in the subscription options is used.The rmw_message_info struct contains meta information about this particular
        /// message instance, like what the GUID of the publisher which published it
        /// originally or whether or not the message received from within the same
        /// process.
        /// The message_info argument should be an already allocated rmw_message_info_t
        /// structure.
        /// Passing `NULL` for message_info will result in the argument being ignored.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the message, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_take(RclCommon.rcl_subscription_t* subscription, void* ros_message, void* message_info, RclCommon.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Get the topic name for the subscription.
        /// </summary>
        /// <param name="subscription">the pointer to the subscription</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the subscription's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - subscription is `NULL`
        /// - subscription is invalid (never called init, called fini, or invalid)The returned string is only valid as long as the subscription is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_subscription_get_topic_name(RclCommon.rcl_subscription_t* subscription);

        /// <summary>
        /// Check that the subscription is valid.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <returns>`true` if `subscription` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `subscription` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_subscription_is_valid(RclCommon.rcl_subscription_t* subscription);

        /// <summary>
        /// Get the number of publishers matched to a subscription.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <param name="publisher_count">number of matched publishers</param>
        /// <returns>`RCL_RET_OK` if the count was retrieved, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Used to get the internal count of publishers matched to a subscription.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] only if the underlying rmw doesn't make use of this feature &lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_subscription_get_publisher_count(RclCommon.rcl_subscription_t* subscription, RclCommon.size_t* publisher_count);

        /// <summary>
        /// Get the actual qos settings of the subscription.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <returns>qos struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// Used to get the actual qos settings of the subscription.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the subscription, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.
        /// The returned struct is only valid as long as the rcl_subscription_t is valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rmw_qos_profile_t* rcl_subscription_get_actual_qos(RclCommon.rcl_subscription_t* subscription);

        /// <summary>
        /// Return a rcl_client_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_client_t before passing to
        /// rcl_client_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_client_t rcl_get_zero_initialized_client();

        /// <summary>
        /// Initialize a rcl client.
        /// </summary>
        /// <param name="client">preallocated rcl_client_t structure</param>
        /// <param name="node">valid rcl_node_t</param>
        /// <param name="type_support">type support object for the service's type</param>
        /// <param name="service_name">the name of the service to request</param>
        /// <param name="options">client options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if the client was initialized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the client is already initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_client_t, it can be used to send
        /// requests of the given type by calling rcl_send_request().
        /// If the request is received by a (possibly remote) service and if the service
        /// sends a response, the client can access the response through
        /// rcl_take_response() once the response is available to the client.The given rcl_node_t must be valid and the resulting rcl_client_t is only
        /// valid as long as the given rcl_node_t remains valid.The rosidl_service_type_support_t is obtained on a per `.srv` type basis.
        /// When the user defines a ROS service, code is generated which provides the
        /// required rosidl_service_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `example_interfaces/AddTwoInts`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _typesupport_cpp/service_type_support.hpp&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.hpp&gt;using rosidl_typesupport_cpp::get_service_type_support_handle;
        /// const rosidl_service_type_support_t * ts =
        /// get_service_type_support_handle
        /// &lt;example
        /// _interfaces::srv::AddTwoInts&gt;();
        /// ```The rosidl_service_type_support_t object contains service type specific
        /// information used to send or take requests and responses.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// client to allocate space for incidentals, e.g. the service name string.Expected usage (for C services):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// rcl_client_t client = rcl_get_zero_initialized_client();
        /// rcl_client_options_t client_ops = rcl_client_get_default_options();
        /// ret = rcl_client_init(
        /// &amp;client
        /// , 
        /// &amp;node
        /// , ts, "add_two_ints", 
        /// &amp;client
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_client_fini(
        /// &amp;client
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_client_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_client_init(RclCommon.rcl_client_t* client, RclCommon.rcl_node_t* node, ServiceTypeSupport* type_support, byte* service_name, RclCommon.rcl_client_options_t* options);

        /// <summary>
        /// Finalize a rcl_client_t.
        /// </summary>
        /// <param name="client">handle to the client to be finalized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the client</param>
        /// <returns>`RCL_RET_OK` if client was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function, calls to rcl_send_request() and
        /// rcl_take_response() will fail when using this client.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_client_fini(RclCommon.rcl_client_t* client, RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the default client options in a rcl_client_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_services_default
        /// - allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_client_options_t rcl_client_get_default_options();

        /// <summary>
        /// Send a ROS request using a client.
        /// </summary>
        /// <param name="client">handle to the client which will make the response</param>
        /// <param name="ros_request">type-erased pointer to the ROS request message</param>
        /// <param name="sequence_number">the sequence number</param>
        /// <returns>`RCL_RET_OK` if the request was sent successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_INVALID` if the client is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_request`
        /// parameter and the type associate with the client (via the type support)
        /// match.
        /// Passing a different type to `send_request` produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.rcl_send_request() is an non-blocking call.The ROS request message given by the `ros_request` void pointer is always
        /// owned by the calling code, but should remain constant during `send_request`.This function is thread safe so long as access to both the client and the
        /// `ros_request` is synchronized.
        /// That means that calling rcl_send_request() from multiple threads is allowed,
        /// but calling rcl_send_request() at the same time as non-thread safe client
        /// functions is not, e.g. calling rcl_send_request() and rcl_client_fini()
        /// concurrently is not allowed.
        /// Before calling rcl_send_request() the message can change and after calling
        /// rcl_send_request() the message can change, but it cannot be changed during
        /// the `send_request` call.
        /// The same `ros_request`, however, can be passed to multiple calls of
        /// rcl_send_request() simultaneously, even if the clients differ.
        /// The `ros_request` is unmodified by rcl_send_request().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of clients and requests, see above for more&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_send_request(RclCommon.rcl_client_t* client, void* ros_request, long* sequence_number);

        /// <summary>
        /// Take a ROS response using a client
        /// </summary>
        /// <param name="client">handle to the client which will take the response</param>
        /// <param name="request_header">pointer to the request header</param>
        /// <param name="ros_response">type-erased pointer to the ROS response message</param>
        /// <returns>`RCL_RET_OK` if the response was taken successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_INVALID` if the client is invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_TAKE_FAILED` if take failed but no error occurred
        /// in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_response`
        /// parameter and the type associate with the client (via the type support)
        /// match.
        /// Passing a different type to take_response produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.
        /// The request_header is an rmw struct for meta-information about the request
        /// sent (e.g. the sequence number).
        /// The caller must provide a pointer to an allocated struct.
        /// This function will populate the struct's fields.
        /// `ros_response` should point to an already allocated ROS response message
        /// struct of the correct type, into which the response from the service will be
        /// copied.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the message, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_take_response_with_info(RclCommon.rcl_client_t* client, RclCommon.rmw_service_info_t* request_header, void* ros_response);

        /// <summary>
        /// Get the name of the service that this client will request a response from.
        /// </summary>
        /// <param name="client">pointer to the client</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the client's internal service name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - client is `NULL`
        /// - client is invalid (never called init, called fini, or invalid node)The returned string is only valid as long as the rcl_client_t is valid.
        /// The value of the string may change if the service name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_client_get_service_name(RclCommon.rcl_client_t* client);

        /// <summary>
        /// Check that the client is valid.
        /// </summary>
        /// <param name="client">pointer to the rcl client</param>
        /// <returns>`true` if `client` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if client is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_client_is_valid(RclCommon.rcl_client_t* client);

        /// <summary>
        /// Return a rcl_guard_condition_t struct with members set to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_guard_condition_t rcl_get_zero_initialized_guard_condition();

        /// <summary>
        /// Initialize a rcl guard_condition.
        /// </summary>
        /// <param name="guard_condition">preallocated guard_condition structure</param>
        /// <param name="context">the context instance with which the guard condition
        /// should be associated</param>
        /// <param name="options">the guard_condition's options</param>
        /// <returns>`RCL_RET_OK` if guard_condition was initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_guard_condition_t, it can be passed to
        /// rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;// ... error handling
        /// rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();
        /// // ... customize guard condition options
        /// rcl_ret_t ret = rcl_guard_condition_init(
        /// &amp;guard
        /// _condition, context, rcl_guard_condition_get_default_options());
        /// // ... error handling, and on shutdown do deinitialization:
        /// ret = rcl_guard_condition_fini(
        /// &amp;guard
        /// _condition);
        /// // ... error handling for rcl_guard_condition_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_guard_condition_init(RclCommon.rcl_guard_condition_t* guard_condition, RclCommon.rcl_context_t* context, RclCommon.rcl_guard_condition_options_t options);

        /// <summary>
        /// Finalize a rcl_guard_condition_t.
        /// </summary>
        /// <param name="guard_condition">handle to the guard_condition to be finalized</param>
        /// <returns>`RCL_RET_OK` if guard_condition was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, calls to rcl_trigger_guard_condition() will fail when using
        /// this guard condition.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] specifically not thread-safe with rcl_trigger_guard_condition()&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_guard_condition_fini(RclCommon.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return the default options in a rcl_guard_condition_options_t struct.
        /// </summary>
        /// <remarks>
        /// The defaults are:- allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_guard_condition_options_t rcl_guard_condition_get_default_options();

        /// <summary>
        /// Trigger a rcl guard condition.
        /// </summary>
        /// <param name="guard_condition">handle to the guard_condition to be triggered</param>
        /// <returns>`RCL_RET_OK` if the guard condition was triggered, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:
        /// - guard condition is `NULL`
        /// - guard condition is invalid (never called init or called fini)A guard condition can be triggered from any thread.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] it can be called concurrently with itself, even on the same guard condition&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_trigger_guard_condition(RclCommon.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return a rcl_service_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_service_t before passing to
        /// rcl_service_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_service_t rcl_get_zero_initialized_service();

        /// <summary>
        /// Initialize a rcl service.
        /// </summary>
        /// <param name="service">preallocated service structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the service's type</param>
        /// <param name="service_name">the name of the service</param>
        /// <param name="options">service options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if service was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the service is already initialized, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_service_t, it can be used to take
        /// requests of the given type to the given topic using rcl_take_request().
        /// It can also send a response to a request using rcl_send_response().The given rcl_node_t must be valid and the resulting rcl_service_t is
        /// only valid as long as the given rcl_node_t remains valid.The rosidl_service_type_support_t is obtained on a per .srv type basis.
        /// When the user defines a ROS service, code is generated which provides the
        /// required rosidl_service_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `example_interfaces/AddTwoInts`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _runtime_cpp/service_type_support.hpp&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;
        /// using rosidl_typesupport_cpp::get_service_type_support_handle;
        /// const rosidl_service_type_support_t * ts =
        /// get_service_type_support_handle
        /// &lt;example
        /// _interfaces::srv::AddTwoInts&gt;();
        /// ```The rosidl_service_type_support_t object contains service type specific
        /// information used to send or take requests and responses.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// client to allocate space for incidentals, e.g. the service name string.Expected usage (for C services):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// rcl_service_t service = rcl_get_zero_initialized_service();
        /// rcl_service_options_t service_ops = rcl_service_get_default_options();
        /// ret = rcl_service_init(
        /// &amp;service
        /// , 
        /// &amp;node
        /// , ts, "add_two_ints", 
        /// &amp;service
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_service_fini(
        /// &amp;service
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_service_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_service_init(RclCommon.rcl_service_t* service, RclCommon.rcl_node_t* node, ServiceTypeSupport* type_support, byte* service_name, RclCommon.rcl_service_options_t* options);

        /// <summary>
        /// Finalize a rcl_service_t.
        /// </summary>
        /// <param name="service">handle to the service to be deinitialized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the service</param>
        /// <returns>`RCL_RET_OK` if service was deinitialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer listen for requests for this service.
        /// (assuming this is the only service of this type in this node).After calling, calls to rcl_wait(), rcl_take_request(), and
        /// rcl_send_response() will fail when using this service.
        /// Additionally rcl_wait() will be interrupted if currently blocking.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_service_fini(RclCommon.rcl_service_t* service, RclCommon.rcl_node_t* node);

        /// <summary>
        /// Return the default service options in a rcl_service_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_services_default
        /// - allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_service_options_t rcl_service_get_default_options();

        /// <summary>
        /// Take a pending ROS request using a rcl service.
        /// </summary>
        /// <param name="service">the handle to the service from which to take</param>
        /// <param name="request_header">ptr to the struct holding metadata about the request</param>
        /// <param name="ros_request">type-erased ptr to an allocated ROS request message</param>
        /// <returns>`RCL_RET_OK` if the request was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SERVICE_TAKE_FAILED` if take failed but no error occurred
        /// in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_request
        /// argument and the type associate with the service, via the type
        /// support, match.
        /// Passing a different type to rcl_take produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.TODO(jacquelinekay) blocking of take?
        /// TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?
        /// TODO(jacquelinekay) is rcl_take_request thread-safe?
        /// TODO(jacquelinekay) Should there be an rcl_request_id_t?The ros_request pointer should point to an already allocated ROS request message
        /// struct of the correct type, into which the taken ROS request will be copied
        /// if one is available.
        /// If taken is false after calling, then the ROS request will be unmodified.If allocation is required when taking the request, e.g. if space needs to
        /// be allocated for a dynamically sized array in the target message, then the
        /// allocator given in the service options is used.request_header is a pointer to pre-allocated a rmw struct containing
        /// meta-information about the request (e.g. the sequence number).&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the request, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_take_request_with_info(RclCommon.rcl_service_t* service, RclCommon.rmw_service_info_t* request_header, void* ros_request);

        /// <summary>
        /// Send a ROS response to a client using a service.
        /// </summary>
        /// <param name="service">handle to the service which will make the response</param>
        /// <param name="response_header">ptr to the struct holding metadata about the request ID</param>
        /// <param name="ros_response">type-erased pointer to the ROS response message</param>
        /// <returns>`RCL_RET_OK` if the response was sent successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_response`
        /// parameter and the type associate with the service (via the type support)
        /// match.
        /// Passing a different type to send_response produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.send_response() is an non-blocking call.The ROS response message given by the `ros_response` void pointer is always
        /// owned by the calling code, but should remain constant during
        /// rcl_send_response().This function is thread safe so long as access to both the service and the
        /// `ros_response` is synchronized.
        /// That means that calling rcl_send_response() from multiple threads is
        /// allowed, but calling rcl_send_response() at the same time as non-thread safe
        /// service functions is not, e.g. calling rcl_send_response() and
        /// rcl_service_fini() concurrently is not allowed.
        /// Before calling rcl_send_response() the message can change and after calling
        /// rcl_send_response() the message can change, but it cannot be changed during
        /// the rcl_send_response() call.
        /// The same `ros_response`, however, can be passed to multiple calls of
        /// rcl_send_response() simultaneously, even if the services differ.
        /// The `ros_response` is unmodified by rcl_send_response().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of services and responses, see above for more&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_send_response(RclCommon.rcl_service_t* service, RclCommon.rmw_request_id_t* response_header, void* ros_response);

        /// <summary>
        /// Get the topic name for the service.
        /// </summary>
        /// <param name="service">the pointer to the service</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the service's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - service is `NULL`
        /// - service is invalid (never called init, called fini, or invalid)The returned string is only valid as long as the service is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_service_get_service_name(RclCommon.rcl_service_t* service);

        /// <summary>
        /// Check that the service is valid.
        /// </summary>
        /// <param name="service">pointer to the rcl service</param>
        /// <returns>`true` if `service` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `service` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_service_is_valid(RclCommon.rcl_service_t* service);

        /// <summary>
        /// Initialize a clock based on the passed type.
        /// </summary>
        /// <param name="clock_type">the type identifying the time source to provide</param>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <param name="allocator">The allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will allocate all necessary internal structures, and initialize variables.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes [1]
        /// Thread-Safe        | No [2]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] If `clock_type` is `RCL_ROS_TIME`&lt;/i&gt;&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_clock_init(RclCommon.rcl_clock_type_t clock_type, RclCommon.rcl_clock_t* clock, RclCommon.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a clock.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being finalized</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully finalized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will deallocate all necessary internal structures, and clean up any variables.
        /// It can be combined with any of the init functions.Passing a clock with type RCL_CLOCK_UNINITIALIZED will result in
        /// RCL_RET_INVALID_ARGUMENT being returned.This function is not thread-safe with any other function operating on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_clock_fini(RclCommon.rcl_clock_t* clock);

        /// <summary>
        /// Fill the time point value with the current value of the associated clock.
        /// </summary>
        /// <param name="clock">The time source from which to set the value.</param>
        /// <param name="time_point_value">The time_point value to populate.</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will populate the data of the time_point_value object with the
        /// current value from it's associated time abstraction.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes [1]
        /// Lock-Free          | Yes&lt;i&gt;[1] If `clock` is of `RCL_ROS_TIME` type.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_clock_get_now(RclCommon.rcl_clock_t* clock, RclCommon.rcl_time_point_value_t* time_point_value);

        /// <summary>
        /// Get the name of the rmw implementation being used
        /// </summary>
        /// <returns>Name of rmw implementation</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rmw_get_implementation_identifier();

        /// <summary>
        /// Get the unique serialization format for this middleware.
        /// </summary>
        /// <returns>serialization format</returns>
        /// <remarks>
        /// Return the format in which binary data is serialized.
        /// One middleware can only have one encoding.
        /// In contrast to the implementation identifier, the serialization format can be equal between
        /// multiple RMW implementations.
        /// This means, that the same binary messages can be deserialized by RMW implementations with the
        /// same format.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rmw_get_serialization_format();

        /// <summary>
        /// Return a zero initialized timer.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_timer_t rcl_get_zero_initialized_timer();

        /// <summary>
        /// Initialize a timer.
        /// </summary>
        /// <param name="timer">the timer handle to be initialized</param>
        /// <param name="clock">the clock providing the current time</param>
        /// <param name="context">the context that this timer is to be associated with</param>
        /// <param name="period">the duration between calls to the callback in nanoseconds</param>
        /// <param name="callback">the user defined function to be called every period</param>
        /// <param name="allocator">the allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the timer was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the timer was already initialized, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// A timer consists of a clock, a callback function and a period.
        /// A timer can be added to a wait set and waited on, such that the wait set
        /// will wake up when a timer is ready to be executed.A timer simply holds state and does not automatically call callbacks.
        /// It does not create any threads, register interrupts, or consume signals.
        /// For blocking behavior it can be used in conjunction with a wait set and
        /// rcl_wait().
        /// When rcl_timer_is_ready() returns true, the timer must still be called
        /// explicitly using rcl_timer_call().The timer handle must be a pointer to an allocated and zero initialized
        /// rcl_timer_t struct.
        /// Calling this function on an already initialized timer will fail.
        /// Calling this function on a timer struct which has been allocated but not
        /// zero initialized is undefined behavior.The clock handle must be a pointer to an initialized rcl_clock_t struct.
        /// The life time of the clock must exceed the life time of the timer.The period is a non-negative duration (rather an absolute time in the
        /// future).
        /// If the period is `0` then it will always be ready.The callback is an optional argument.
        /// Valid inputs are either a pointer to the function callback, or `NULL` to
        /// indicate that no callback will be stored in rcl.
        /// If the callback is `NULL`, the caller client library is responsible for
        /// firing the timer callback.
        /// Else, it must be a function which returns void and takes two arguments,
        /// the first being a pointer to the associated timer, and the second a int64_t
        /// which is the time since the previous call, or since the timer was created
        /// if it is the first call to the callback.Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)
        /// {
        /// // Do timer work...
        /// // Optionally reconfigure, cancel, or reset the timer...
        /// }rcl_context_t * context;  // initialized previously by rcl_init()...
        /// rcl_clock_t clock;
        /// rcl_allocator_t allocator = rcl_get_default_allocator();
        /// rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, 
        /// &amp;clock
        /// , 
        /// &amp;allocator
        /// );
        /// // ... error handlingrcl_timer_t timer = rcl_get_zero_initialized_timer();
        /// ret = rcl_timer_init(
        /// &amp;timer
        /// , 
        /// &amp;clock
        /// , context, RCL_MS_TO_NS(100), my_timer_callback, allocator);
        /// // ... error handling, use the timer with a wait set, or poll it manually, then cleanup
        /// ret = rcl_timer_fini(
        /// &amp;timer
        /// );
        /// // ... error handling
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1][2][3]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`&lt;/i&gt;&lt;i&gt;[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;&lt;i&gt;[3] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_init(RclCommon.rcl_timer_t* timer, RclCommon.rcl_clock_t* clock, RclCommon.rcl_context_t* context, long period, delegate* unmanaged[Cdecl]<RclCommon.rcl_timer_t*, long, void> callback, RclCommon.rcl_allocator_t allocator);

        /// <summary>
        /// Finalize a timer.
        /// </summary>
        /// <param name="timer">the handle to the timer to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the timer was finalized successfully, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will deallocate any memory and make the timer invalid.A timer that is already invalid (zero initialized) or `NULL` will not fail.This function is not thread-safe with any rcl_timer_* functions used on the
        /// same timer object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1][2][3]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`&lt;/i&gt;&lt;i&gt;[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;&lt;i&gt;[3] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_fini(RclCommon.rcl_timer_t* timer);

        /// <summary>
        /// Retrieve the period of the timer.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being queried</param>
        /// <param name="period">the int64_t in which the period is stored</param>
        /// <returns>`RCL_RET_OK` if the period was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function retrieves the period and copies it into the given variable.The period argument must be a pointer to an already allocated int64_t.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_get_period(RclCommon.rcl_timer_t* timer, long* period);

        /// <summary>
        /// Exchange the period of the timer and return the previous period.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being modified</param>
        /// <param name="new_period">the int64_t to exchange into the timer</param>
        /// <param name="old_period">the int64_t in which the previous period is stored</param>
        /// <returns>`RCL_RET_OK` if the period was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function exchanges the period in the timer and copies the old one into
        /// the given variable.Exchanging (changing) the period will not affect already waiting wait sets.The old_period argument must be a pointer to an already allocated int64_t.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_exchange_period(RclCommon.rcl_timer_t* timer, long new_period, long* old_period);

        /// <summary>
        /// Cancel a timer.
        /// </summary>
        /// <param name="timer">the timer to be canceled</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// When a timer is canceled, rcl_timer_is_ready() will return false for that
        /// timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.A canceled timer can be reset with rcl_timer_reset(), and then used again.
        /// Calling this function on an already canceled timer will succeed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_cancel(RclCommon.rcl_timer_t* timer);

        /// <summary>
        /// Retrieve the canceled state of a timer.
        /// </summary>
        /// <param name="timer">the timer to be queried</param>
        /// <param name="is_canceled">storage for the is canceled bool</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// If the timer is canceled true will be stored in the is_canceled argument.
        /// Otherwise false will be stored in the is_canceled argument.The is_canceled argument must point to an allocated bool, as the result is
        /// copied into this variable.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_is_canceled(RclCommon.rcl_timer_t* timer, bool* is_canceled);

        /// <summary>
        /// Reset a timer.
        /// </summary>
        /// <param name="timer">the timer to be reset</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function can be called on a timer, canceled or not.
        /// For all timers it will reset the last call time to now.
        /// For canceled timers it will additionally make the timer not canceled.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_timer_reset(RclCommon.rcl_timer_t* timer);

        /// <summary>
        /// Return a rcl_event_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_event_t before passing to
        /// rcl_event_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_event_t rcl_get_zero_initialized_event();

        /// <summary>
        /// Initialize an rcl_event_t with a publisher.
        /// </summary>
        /// <param name="event">pointer to fill</param>
        /// <param name="publisher">to get events from</param>
        /// <param name="event_type">to listen for</param>
        /// <returns>`RCL_RET_OK` if the rcl_event_t is filled, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_UNSUPPORTED` if event_type is not supported, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Fill the rcl_event_t with the publisher and desired event_type.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_publisher_event_init(RclCommon.rcl_event_t* @event, RclCommon.rcl_publisher_t* publisher, RclCommon.rcl_publisher_event_type_t event_type);

        /// <summary>
        /// Initialize an rcl_event_t with a subscription.
        /// </summary>
        /// <param name="event">pointer to fill</param>
        /// <param name="subscription">to get events from</param>
        /// <param name="event_type">to listen for</param>
        /// <returns>`RCL_RET_OK` if the rcl_event_t is filled, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_UNSUPPORTED` if event_type is not supported, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Fill the rcl_event_t with the subscription and desired event_type.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_subscription_event_init(RclCommon.rcl_event_t* @event, RclCommon.rcl_subscription_t* subscription, RclCommon.rcl_subscription_event_type_t event_type);

        /// <summary>
        /// Take event using the event handle.
        /// </summary>
        /// <param name="event">event object to take from</param>
        /// <param name="event_info">event info object to write taken data into</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCL_RET_EVENT_TAKE_FAILED` if the take event failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Take an event from the event handle.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_take_event(RclCommon.rcl_event_t* @event, void* event_info);

        /// <summary>
        /// Finalize an event.
        /// </summary>
        /// <param name="event">to finalize</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_EVENT_INVALID` if event is null, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Finalize an event.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_event_fini(RclCommon.rcl_event_t* @event);

        /// <summary>
        /// Return a rcl_wait_set_t struct with members set to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclCommon.rcl_wait_set_t rcl_get_zero_initialized_wait_set();

        /// <summary>
        /// Initialize a rcl wait set with space for items to be waited on.
        /// </summary>
        /// <param name="wait_set">the wait set struct to be initialized</param>
        /// <param name="context">the context that the wait set should be associated with</param>
        /// <param name="number_of_events">non-zero size of the events set</param>
        /// <param name="number_of_services">non-zero size of the services set</param>
        /// <param name="allocator">the allocator to use when allocating space in the sets</param>
        /// <param name="number_of_timers">non-zero size of the timers set</param>
        /// <param name="number_of_guard_conditions">non-zero size of the guard conditions set</param>
        /// <param name="number_of_subscriptions">non-zero size of the subscriptions set</param>
        /// <param name="number_of_clients">non-zero size of the clients set</param>
        /// <returns>`RCL_RET_OK` if the wait set is initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the wait set is not zero initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function allocates space for the subscriptions and other wait-able
        /// entities that can be stored in the wait set.
        /// It also sets the allocator to the given allocator and initializes the pruned
        /// member to be false.The wait_set struct should be allocated and initialized to `NULL`.
        /// If the wait_set is allocated but the memory is uninitialized the behavior is
        /// undefined.
        /// Calling this function on a wait set that has already been initialized will
        /// result in an error.
        /// A wait set can be reinitialized if rcl_wait_set_fini() was called on it.To use the default allocator use rcl_get_default_allocator().Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /wait.h&gt;rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
        /// rcl_ret_t ret =
        /// rcl_wait_set_init(
        /// &amp;wait
        /// _set, 42, 42, 42, 42, 42, 
        /// &amp;context
        /// , rcl_get_default_allocator());
        /// // ... error handling, then use it, then call the matching fini:
        /// ret = rcl_wait_set_fini(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_init(RclCommon.rcl_wait_set_t* wait_set, RclCommon.size_t number_of_subscriptions, RclCommon.size_t number_of_guard_conditions, RclCommon.size_t number_of_timers, RclCommon.size_t number_of_clients, RclCommon.size_t number_of_services, RclCommon.size_t number_of_events, RclCommon.rcl_context_t* context, RclCommon.rcl_allocator_t allocator);

        /// <summary>
        /// Finalize a rcl wait set.
        /// </summary>
        /// <param name="wait_set">the wait set struct to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the finalization was successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Deallocates any memory in the wait set that was allocated in
        /// rcl_wait_set_init() using the allocator given in the initialization.Calling this function on a zero initialized wait set will do nothing and
        /// return RCL_RET_OK.
        /// Calling this function on uninitialized memory results in undefined behavior.
        /// After calling this function the wait set will once again be zero initialized
        /// and so calling this function or rcl_wait_set_init() immediately after will
        /// succeed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_fini(RclCommon.rcl_wait_set_t* wait_set);

        /// <summary>
        /// Store a pointer to the given subscription in the next empty spot in the set.
        /// </summary>
        /// <param name="wait_set">struct in which the subscription is to be stored</param>
        /// <param name="subscription">the subscription to be added to the wait set</param>
        /// <param name="index">the index of the added subscription in the storage container.
        /// This parameter is optional and can be set to `NULL` to be ignored.</param>
        /// <returns>`RCL_RET_OK` if added successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_FULL` if the subscription set is full, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function does not guarantee that the subscription is not already in the
        /// wait set.Also add the rmw representation to the underlying rmw array and increment
        /// the rmw array count.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_subscription(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_subscription_t* subscription, RclCommon.size_t* index);

        /// <summary>
        /// Reallocate space for entities in the wait set.
        /// </summary>
        /// <param name="wait_set">struct to be resized</param>
        /// <param name="subscriptions_size">a size for the new subscriptions set</param>
        /// <param name="guard_conditions_size">a size for the new guard conditions set</param>
        /// <param name="timers_size">a size for the new timers set</param>
        /// <param name="clients_size">a size for the new clients set</param>
        /// <param name="services_size">a size for the new services set</param>
        /// <param name="events_size">a size for the new events set</param>
        /// <returns>`RCL_RET_OK` if resized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will deallocate and reallocate the memory for all entity sets.A size of 0 will just deallocate the memory and assign `NULL` to the array.Allocation and deallocation is done with the allocator given during the
        /// wait set's initialization.After calling this function all values in the set will be set to `NULL`,
        /// effectively the same as calling rcl_wait_set_clear().
        /// Similarly, the underlying rmw representation is reallocated and reset:
        /// all entries are set to `NULL` and the count is set to zero.If the requested size matches the current size, no allocation will be done.This can be called on an uninitialized (zero initialized) wait set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_resize(RclCommon.rcl_wait_set_t* wait_set, RclCommon.size_t subscriptions_size, RclCommon.size_t guard_conditions_size, RclCommon.size_t timers_size, RclCommon.size_t clients_size, RclCommon.size_t services_size, RclCommon.size_t events_size);

        /// <summary>
        /// Store a pointer to the guard condition in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_guard_condition(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_guard_condition_t* guard_condition, RclCommon.size_t* index);

        /// <summary>
        /// Store a pointer to the timer in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_timer(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_timer_t* timer, RclCommon.size_t* index);

        /// <summary>
        /// Store a pointer to the client in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_client(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_client_t* client, RclCommon.size_t* index);

        /// <summary>
        /// Store a pointer to the service in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_service(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_service_t* service, RclCommon.size_t* index);

        /// <summary>
        /// Store a pointer to the event in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait_set_add_event(RclCommon.rcl_wait_set_t* wait_set, RclCommon.rcl_event_t* @event, RclCommon.size_t* index);

        /// <summary>
        /// Block until the wait set is ready or until the timeout has been exceeded.
        /// </summary>
        /// <param name="wait_set">the set of things to be waited on and to be pruned if not ready</param>
        /// <param name="timeout">the duration to wait for the wait set to be ready, in nanoseconds</param>
        /// <returns>`RCL_RET_OK` something in the wait set became ready, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_EMPTY` if the wait set contains no items, or</returns>
        /// <returns>`RCL_RET_TIMEOUT` if the timeout expired before something was ready, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will collect the items in the rcl_wait_set_t and pass them
        /// to the underlying rmw_wait function.The items in the wait set will be either left untouched or set to `NULL` after
        /// this function returns.
        /// Items that are not `NULL` are ready, where ready means different things based
        /// on the type of the item.
        /// For subscriptions this means there may be messages that can be taken, or
        /// perhaps that the state of the subscriptions has changed, in which case
        /// rcl_take may succeed but return with taken == false.
        /// For guard conditions this means the guard condition was triggered.Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;// rcl_init() called successfully before here...
        /// rcl_node_t node;  // initialize this, see rcl_node_init()
        /// rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()
        /// rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()
        /// rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()
        /// rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
        /// rcl_ret_t ret = rcl_wait_set_init(
        /// &amp;wait
        /// _set, 2, 1, 0, 0, 0, rcl_get_default_allocator());
        /// // ... error handling
        /// do {
        /// ret = rcl_wait_set_clear(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ret = rcl_wait_set_add_subscription(
        /// &amp;wait
        /// _set, 
        /// &amp;sub
        /// 1);
        /// // ... error handling
        /// ret = rcl_wait_set_add_subscription(
        /// &amp;wait
        /// _set, 
        /// &amp;sub
        /// 2);
        /// // ... error handling
        /// ret = rcl_wait_set_add_guard_condition(
        /// &amp;wait
        /// _set, 
        /// &amp;gc
        /// 1);
        /// // ... error handling
        /// ret = rcl_wait(
        /// &amp;wait
        /// _set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns
        /// if (ret == RCL_RET_TIMEOUT) {
        /// continue;
        /// }
        /// for (int i = 0; i 
        /// &lt;
        /// wait_set.size_of_subscriptions; ++i) {
        /// if (wait_set.subscriptions[i]) {
        /// // The subscription is ready...
        /// }
        /// }
        /// for (int i = 0; i 
        /// &lt;
        /// wait_set.size_of_guard_conditions; ++i) {
        /// if (wait_set.guard_conditions[i]) {
        /// // The subscription is ready...
        /// }
        /// }
        /// } while(check_some_condition());
        /// // ... fini node, and subscriptions and guard conditions...
        /// ret = rcl_wait_set_fini(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ```The wait set struct must be allocated, initialized, and should have been
        /// cleared and then filled with items, e.g. subscriptions and guard conditions.
        /// Passing a wait set with no wait-able items in it will fail.
        /// `NULL` items in the sets are ignored, e.g. it is valid to have as input:
        /// - `subscriptions[0]` = valid pointer
        /// - `subscriptions[1]` = `NULL`
        /// - `subscriptions[2]` = valid pointer
        /// - `size_of_subscriptions` = 3
        /// Passing an uninitialized (zero initialized) wait set struct will fail.
        /// Passing a wait set struct with uninitialized memory is undefined behavior.The unit of timeout is nanoseconds.
        /// If the timeout is negative then this function will block indefinitely until
        /// something in the wait set is valid or it is interrupted.
        /// If the timeout is 0 then this function will be non-blocking; checking what's
        /// ready now, but not waiting if nothing is ready yet.
        /// If the timeout is greater than 0 then this function will return after
        /// that period of time has elapsed or the wait set becomes ready, which ever
        /// comes first.
        /// Passing a timeout struct with uninitialized memory is undefined behavior.This function is thread-safe for unique wait sets with unique contents.
        /// This function cannot operate on the same wait set in multiple threads, and
        /// the wait sets may not share content.
        /// For example, calling rcl_wait() in two threads on two different wait sets
        /// that both contain a single, shared guard condition is undefined behavior.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_wait(RclCommon.rcl_wait_set_t* wait_set, long timeout);

        /// <summary>
        /// Finalize an array of topic endpoint information.
        /// </summary>
        /// <param name="topic_endpoint_info_array">object to be finalized.</param>
        /// <param name="allocator">Allocator used to populate the given `topic_endpoint_info_array`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,
        /// by rcutils_allocator_is_valid() definition, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function deallocates the given array storage, and then zero initializes it.
        /// If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will
        /// return early, leaving the given array unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Finalization is a reentrant procedure, but:
        /// - Access to the array of topic endpoint information is not synchronized.
        /// It is not safe to read or write `topic_endpoint_info_array` during finalization.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `allocator` must be the same used to initialize the given `topic_endpoint_info_array`.
        /// </pre>
        [DllImport("rmw", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rmw_topic_endpoint_info_array_fini(RclCommon.rmw_topic_endpoint_info_array_t* topic_endpoint_info_array, RclCommon.rcutils_allocator_t* allocator);

        /// <summary>
        /// Return a list of service names and types associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="node_name">the node name of the services to return</param>
        /// <param name="node_namespace">the node namespace of the services to return</param>
        /// <param name="service_names_and_types">list of service names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `service_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create service clients using names returned by this function may not
        /// result in the desired service name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_service_names_and_types_by_node(RclCommon.rcl_node_t* node, RclCommon.rcl_allocator_t* allocator, byte* node_name, byte* node_namespace, RclCommon.rcl_names_and_types_t* service_names_and_types);

        /// <summary>
        /// Return a list of service client names and types associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="node_name">the node name of the services to return</param>
        /// <param name="node_namespace">the node namespace of the services to return</param>
        /// <param name="service_names_and_types">list of service client names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `service_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create service servers using names returned by this function may not
        /// result in the desired service name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_client_names_and_types_by_node(RclCommon.rcl_node_t* node, RclCommon.rcl_allocator_t* allocator, byte* node_name, byte* node_namespace, RclCommon.rcl_names_and_types_t* service_names_and_types);

        /// <summary>
        /// Return a list of topic names and their types.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="no_demangle">if true, list all topics without any demangling</param>
        /// <param name="topic_names_and_types">list of topic names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create publishers or subscribers using names returned by this function may not
        /// result in the desired topic name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_topic_names_and_types(RclCommon.rcl_node_t* node, RclCommon.rcl_allocator_t* allocator, bool no_demangle, RclCommon.rcl_names_and_types_t* topic_names_and_types);

        /// <summary>
        /// Finalize a rcl_names_and_types_t object.
        /// </summary>
        /// <param name="names_and_types">struct to be finalized</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The object is populated when given to one of the rcl_get_*_names_and_types()
        /// functions.
        /// This function reclaims any resources allocated during population.The `names_and_types` parameter must not be `NULL`, and must point to an
        /// already allocated rcl_names_and_types_t struct that was previously
        /// passed to a successful rcl_get_*_names_and_types() function call.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_names_and_types_fini(RclCommon.rcl_names_and_types_t* names_and_types);

        /// <summary>
        /// Return a list of available nodes in the ROS graph, including their enclave names.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">used to control allocation and deallocation of names</param>
        /// <param name="node_names">struct storing discovered node names</param>
        /// <param name="node_namespaces">struct storing discovered node namespaces</param>
        /// <param name="enclaves">struct storing discovered node enclaves</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if an error occurred while allocating memory, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// An @ref rcl_get_node_names equivalent, but including in its output the enclave
        /// name the node is using.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] RMW implementation in use may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_node_names_with_enclaves(RclCommon.rcl_node_t* node, RclCommon.rcl_allocator_t allocator, RclCommon.rcutils_string_array_t* node_names, RclCommon.rcutils_string_array_t* node_namespaces, RclCommon.rcutils_string_array_t* enclaves);

        /// <summary>
        /// Return a list of all publishers to a topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for
        /// the array inside publishers_info</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="no_mangle">if `true`, `topic_name` needs to be a valid middleware topic name,
        /// otherwise it should be a valid ROS topic name</param>
        /// <param name="publishers_info">a struct representing a list of publisher information</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`.When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name
        /// for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
        /// When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
        /// ROS topic name conventions.
        /// In either case, the topic name should always be fully qualified.Each element in the `publishers_info` array will contain the node name, node namespace,
        /// topic type, gid and the qos profile of the publisher.
        /// It is the responsibility of the caller to ensure that `publishers_info` parameter points
        /// to a valid struct of type rcl_topic_endpoint_info_array_t.
        /// The `count` field inside the struct must be set to 0 and the `info_array` field inside
        /// the struct must be set to null.The `allocator` will be used to allocate memory to the `info_array` member
        /// inside of `publishers_info`.
        /// Moreover, every const char * member inside of
        /// rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_publishers_info_by_topic(RclCommon.rcl_node_t* node, RclCommon.rcutils_allocator_t* allocator, byte* topic_name, bool no_mangle, RclCommon.rmw_topic_endpoint_info_array_t* publishers_info);

        /// <summary>
        /// Return a list of all subscriptions to a topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for
        /// the array inside publishers_info</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="no_mangle">if `true`, `topic_name` needs to be a valid middleware topic name,
        /// otherwise it should be a valid ROS topic name</param>
        /// <param name="subscriptions_info">a struct representing a list of subscriptions information</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`.When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name
        /// for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
        /// When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
        /// ROS topic name conventions.
        /// In either case, the topic name should always be fully qualified.Each element in the `subscriptions_info` array will contain the node name, node namespace,
        /// topic type, gid and the qos profile of the subscription.
        /// It is the responsibility of the caller to ensure that `subscriptions_info` parameter points
        /// to a valid struct of type rcl_topic_endpoint_info_array_t.
        /// The `count` field inside the struct must be set to 0 and the `info_array` field inside
        /// the struct must be set to null.The `allocator` will be used to allocate memory to the `info_array` member
        /// inside of `subscriptions_info`.
        /// Moreover, every const char * member inside of
        /// rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_get_subscriptions_info_by_topic(RclCommon.rcl_node_t* node, RclCommon.rcutils_allocator_t* allocator, byte* topic_name, bool no_mangle, RclCommon.rmw_topic_endpoint_info_array_t* subscriptions_info);

        /// <summary>
        /// Check if a service server is available for the given service client.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="client">the handle to the service client being queried</param>
        /// <param name="is_available">set to true if there is a service server available, else false</param>
        /// <returns>`RCL_RET_OK` if the check was made successfully (regardless of the service readiness), or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will return true for `is_available` if there is a service server
        /// available for the given client.The `node` parameter must point to a valid node.The `client` parameter must point to a valid client.The given client and node must match, i.e. the client must have been created
        /// using the given node.The `is_available` parameter must not be `NULL`, and must point a bool variable.
        /// The result of the check will be stored in the `is_available` parameter.In the event that error handling needs to allocate memory, this function
        /// will try to use the node's allocator.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_service_server_is_available(RclCommon.rcl_node_t* node, RclCommon.rcl_client_t* client, bool* is_available);

        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t　rcl_logging_configure(rcl_arguments_t* global_args, rcl_allocator_t* allocator);

        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern rcl_ret_t rcl_logging_fini();

        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern void rcutils_log(rcutils_log_location_t* location, int severity, byte* name, byte* format, nint args);

    }
}

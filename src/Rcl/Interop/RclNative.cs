//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace Rcl.Interop
{
    using System.Runtime.InteropServices;

    internal static unsafe partial class RclNative
    {
        /// <summary>
        /// Used to specify if the context can only communicate through localhost.
        /// </summary>
        public enum rmw_localhost_only_t : int
        {
            /// <summary>
            /// Uses ROS_LOCALHOST_ONLY environment variable.
            /// </summary>
            RMW_LOCALHOST_ONLY_DEFAULT = unchecked((int)0),

            /// <summary>
            /// Forces using only localhost.
            /// </summary>
            RMW_LOCALHOST_ONLY_ENABLED = unchecked((int)1),

            /// <summary>
            /// Forces disabling localhost only.
            /// </summary>
            RMW_LOCALHOST_ONLY_DISABLED = unchecked((int)2),
        }

        /// <summary>
        /// Uses ROS_LOCALHOST_ONLY environment variable.
        /// </summary>
        public const RclNative.rmw_localhost_only_t RMW_LOCALHOST_ONLY_DEFAULT = rmw_localhost_only_t.RMW_LOCALHOST_ONLY_DEFAULT;

        /// <summary>
        /// Forces using only localhost.
        /// </summary>
        public const RclNative.rmw_localhost_only_t RMW_LOCALHOST_ONLY_ENABLED = rmw_localhost_only_t.RMW_LOCALHOST_ONLY_ENABLED;

        /// <summary>
        /// Forces disabling localhost only.
        /// </summary>
        public const RclNative.rmw_localhost_only_t RMW_LOCALHOST_ONLY_DISABLED = rmw_localhost_only_t.RMW_LOCALHOST_ONLY_DISABLED;

        public enum rmw_security_enforcement_policy_t : int
        {
            RMW_SECURITY_ENFORCEMENT_PERMISSIVE,

            RMW_SECURITY_ENFORCEMENT_ENFORCE,
        }

        public const RclNative.rmw_security_enforcement_policy_t RMW_SECURITY_ENFORCEMENT_PERMISSIVE = rmw_security_enforcement_policy_t.RMW_SECURITY_ENFORCEMENT_PERMISSIVE;

        public const RclNative.rmw_security_enforcement_policy_t RMW_SECURITY_ENFORCEMENT_ENFORCE = rmw_security_enforcement_policy_t.RMW_SECURITY_ENFORCEMENT_ENFORCE;

        /// <summary>
        /// The severity levels of log messages / loggers.
        /// </summary>
        public enum RCUTILS_LOG_SEVERITY : int
        {
            /// <summary>
            /// The unset log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_UNSET = unchecked((int)0),

            /// <summary>
            /// The debug log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_DEBUG = unchecked((int)10),

            /// <summary>
            /// The info log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_INFO = unchecked((int)20),

            /// <summary>
            /// The warn log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_WARN = unchecked((int)30),

            /// <summary>
            /// The error log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_ERROR = unchecked((int)40),

            /// <summary>
            /// The fatal log level
            /// </summary>
            RCUTILS_LOG_SEVERITY_FATAL = unchecked((int)50),
        }

        /// <summary>
        /// The unset log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_UNSET = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_UNSET;

        /// <summary>
        /// The debug log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_DEBUG = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_DEBUG;

        /// <summary>
        /// The info log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_INFO = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_INFO;

        /// <summary>
        /// The warn log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_WARN = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_WARN;

        /// <summary>
        /// The error log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_ERROR = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_ERROR;

        /// <summary>
        /// The fatal log level
        /// </summary>
        public const RclNative.RCUTILS_LOG_SEVERITY RCUTILS_LOG_SEVERITY_FATAL = RCUTILS_LOG_SEVERITY.RCUTILS_LOG_SEVERITY_FATAL;

        /// <summary>
        /// Endpoint enumeration type
        /// </summary>
        public enum rmw_endpoint_type_t : int
        {
            /// <summary>
            /// Endpoint type has not yet been set
            /// </summary>
            RMW_ENDPOINT_INVALID = unchecked((int)0),

            /// <summary>
            /// Creates and publishes messages to the ROS topic
            /// </summary>
            RMW_ENDPOINT_PUBLISHER,

            /// <summary>
            /// Listens for and receives messages from a topic
            /// </summary>
            RMW_ENDPOINT_SUBSCRIPTION,
        }

        /// <summary>
        /// Endpoint type has not yet been set
        /// </summary>
        public const RclNative.rmw_endpoint_type_t RMW_ENDPOINT_INVALID = rmw_endpoint_type_t.RMW_ENDPOINT_INVALID;

        /// <summary>
        /// Creates and publishes messages to the ROS topic
        /// </summary>
        public const RclNative.rmw_endpoint_type_t RMW_ENDPOINT_PUBLISHER = rmw_endpoint_type_t.RMW_ENDPOINT_PUBLISHER;

        /// <summary>
        /// Listens for and receives messages from a topic
        /// </summary>
        public const RclNative.rmw_endpoint_type_t RMW_ENDPOINT_SUBSCRIPTION = rmw_endpoint_type_t.RMW_ENDPOINT_SUBSCRIPTION;

        public enum rmw_qos_reliability_policy_t : int
        {
            /// <summary>
            /// Implementation specific default
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT,

            /// <summary>
            /// Guarantee that samples are delivered, may retry multiple times.
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_RELIABLE,

            /// <summary>
            /// Attempt to deliver samples, but some may be lost if the network is not robust
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT,

            /// <summary>
            /// Reliability policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_RELIABILITY_UNKNOWN,
        }

        /// <summary>
        /// Implementation specific default
        /// </summary>
        public const RclNative.rmw_qos_reliability_policy_t RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT = rmw_qos_reliability_policy_t.RMW_QOS_POLICY_RELIABILITY_SYSTEM_DEFAULT;

        /// <summary>
        /// Guarantee that samples are delivered, may retry multiple times.
        /// </summary>
        public const RclNative.rmw_qos_reliability_policy_t RMW_QOS_POLICY_RELIABILITY_RELIABLE = rmw_qos_reliability_policy_t.RMW_QOS_POLICY_RELIABILITY_RELIABLE;

        /// <summary>
        /// Attempt to deliver samples, but some may be lost if the network is not robust
        /// </summary>
        public const RclNative.rmw_qos_reliability_policy_t RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT = rmw_qos_reliability_policy_t.RMW_QOS_POLICY_RELIABILITY_BEST_EFFORT;

        /// <summary>
        /// Reliability policy has not yet been set
        /// </summary>
        public const RclNative.rmw_qos_reliability_policy_t RMW_QOS_POLICY_RELIABILITY_UNKNOWN = rmw_qos_reliability_policy_t.RMW_QOS_POLICY_RELIABILITY_UNKNOWN;

        /// <summary>
        /// QoS history enumerations describing how samples endure
        /// </summary>
        public enum rmw_qos_history_policy_t : int
        {
            /// <summary>
            /// Implementation default for history policy
            /// </summary>
            RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT,

            /// <summary>
            /// Only store up to a maximum number of samples, dropping oldest once max is exceeded
            /// </summary>
            RMW_QOS_POLICY_HISTORY_KEEP_LAST,

            /// <summary>
            /// Store all samples, subject to resource limits
            /// </summary>
            RMW_QOS_POLICY_HISTORY_KEEP_ALL,

            /// <summary>
            /// History policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_HISTORY_UNKNOWN,
        }

        /// <summary>
        /// Implementation default for history policy
        /// </summary>
        public const RclNative.rmw_qos_history_policy_t RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT = rmw_qos_history_policy_t.RMW_QOS_POLICY_HISTORY_SYSTEM_DEFAULT;

        /// <summary>
        /// Only store up to a maximum number of samples, dropping oldest once max is exceeded
        /// </summary>
        public const RclNative.rmw_qos_history_policy_t RMW_QOS_POLICY_HISTORY_KEEP_LAST = rmw_qos_history_policy_t.RMW_QOS_POLICY_HISTORY_KEEP_LAST;

        /// <summary>
        /// Store all samples, subject to resource limits
        /// </summary>
        public const RclNative.rmw_qos_history_policy_t RMW_QOS_POLICY_HISTORY_KEEP_ALL = rmw_qos_history_policy_t.RMW_QOS_POLICY_HISTORY_KEEP_ALL;

        /// <summary>
        /// History policy has not yet been set
        /// </summary>
        public const RclNative.rmw_qos_history_policy_t RMW_QOS_POLICY_HISTORY_UNKNOWN = rmw_qos_history_policy_t.RMW_QOS_POLICY_HISTORY_UNKNOWN;

        /// <summary>
        /// QoS durability enumerations describing how samples persist
        /// </summary>
        public enum rmw_qos_durability_policy_t : int
        {
            /// <summary>
            /// Impplementation specific default
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT,

            /// <summary>
            /// The rmw publisher is responsible for persisting samples for “late-joining” subscribers
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL,

            /// <summary>
            /// Samples are not persistent
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_VOLATILE,

            /// <summary>
            /// Durability policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_DURABILITY_UNKNOWN,
        }

        /// <summary>
        /// Impplementation specific default
        /// </summary>
        public const RclNative.rmw_qos_durability_policy_t RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT = rmw_qos_durability_policy_t.RMW_QOS_POLICY_DURABILITY_SYSTEM_DEFAULT;

        /// <summary>
        /// The rmw publisher is responsible for persisting samples for “late-joining” subscribers
        /// </summary>
        public const RclNative.rmw_qos_durability_policy_t RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL = rmw_qos_durability_policy_t.RMW_QOS_POLICY_DURABILITY_TRANSIENT_LOCAL;

        /// <summary>
        /// Samples are not persistent
        /// </summary>
        public const RclNative.rmw_qos_durability_policy_t RMW_QOS_POLICY_DURABILITY_VOLATILE = rmw_qos_durability_policy_t.RMW_QOS_POLICY_DURABILITY_VOLATILE;

        /// <summary>
        /// Durability policy has not yet been set
        /// </summary>
        public const RclNative.rmw_qos_durability_policy_t RMW_QOS_POLICY_DURABILITY_UNKNOWN = rmw_qos_durability_policy_t.RMW_QOS_POLICY_DURABILITY_UNKNOWN;

        /// <summary>
        /// QoS liveliness enumerations that describe a publisher's reporting policy for its alive status.
        /// For a subscriber, these are its requirements for its topic's publishers.
        /// Suppress syntax errors, as cppcheck does not seem to handle enumerator attributes.
        /// cppcheck-suppress syntaxError
        /// </summary>
        public enum rmw_qos_liveliness_policy_t : int
        {
            /// <summary>
            /// Implementation specific default
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = unchecked((int)0),

            /// <summary>
            /// The signal that establishes a Topic is alive comes from the ROS rmw layer.
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = unchecked((int)1),

            RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = unchecked((int)2),

            /// <summary>
            /// The signal that establishes a Topic is alive is at the Topic level. Only publishing a message
            /// on the Topic or an explicit signal from the application to assert liveliness on the Topic
            /// will mark the Topic as being alive.
            /// Using `3` for backwards compatibility.
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = unchecked((int)3),

            /// <summary>
            /// Liveliness policy has not yet been set
            /// </summary>
            RMW_QOS_POLICY_LIVELINESS_UNKNOWN = unchecked((int)4),
        }

        /// <summary>
        /// Implementation specific default
        /// </summary>
        public const RclNative.rmw_qos_liveliness_policy_t RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT = rmw_qos_liveliness_policy_t.RMW_QOS_POLICY_LIVELINESS_SYSTEM_DEFAULT;

        /// <summary>
        /// The signal that establishes a Topic is alive comes from the ROS rmw layer.
        /// </summary>
        public const RclNative.rmw_qos_liveliness_policy_t RMW_QOS_POLICY_LIVELINESS_AUTOMATIC = rmw_qos_liveliness_policy_t.RMW_QOS_POLICY_LIVELINESS_AUTOMATIC;

        public const RclNative.rmw_qos_liveliness_policy_t RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE = rmw_qos_liveliness_policy_t.RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_NODE;

        /// <summary>
        /// The signal that establishes a Topic is alive is at the Topic level. Only publishing a message
        /// on the Topic or an explicit signal from the application to assert liveliness on the Topic
        /// will mark the Topic as being alive.
        /// Using `3` for backwards compatibility.
        /// </summary>
        public const RclNative.rmw_qos_liveliness_policy_t RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC = rmw_qos_liveliness_policy_t.RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC;

        /// <summary>
        /// Liveliness policy has not yet been set
        /// </summary>
        public const RclNative.rmw_qos_liveliness_policy_t RMW_QOS_POLICY_LIVELINESS_UNKNOWN = rmw_qos_liveliness_policy_t.RMW_QOS_POLICY_LIVELINESS_UNKNOWN;

        /// <summary>
        /// Default size of the rmw queue when history is set to RMW_QOS_POLICY_HISTORY_KEEP_LAST,
        /// 0 indicates it is currently not set
        /// </summary>
        public enum __AnonymousCppEnum_types_16866AnonymousEnum : int
        {
            RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = unchecked((int)0),
        }

        public const RclNative.__AnonymousCppEnum_types_16866AnonymousEnum RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT = __AnonymousCppEnum_types_16866AnonymousEnum.RMW_QOS_POLICY_DEPTH_SYSTEM_DEFAULT;

        /// <summary>
        /// Type mapping of rcutils log severity types to rmw specific types.
        /// </summary>
        public enum rmw_log_severity_t : int
        {
            /// <summary>
            /// Debug log severity, for pedantic messaging
            /// </summary>
            RMW_LOG_SEVERITY_DEBUG = unchecked((int)RCUTILS_LOG_SEVERITY_DEBUG),

            /// <summary>
            /// Informational log severity, for reporting expected but not overwhelming information
            /// </summary>
            RMW_LOG_SEVERITY_INFO = unchecked((int)RCUTILS_LOG_SEVERITY_INFO),

            /// <summary>
            /// Warning log severity, for reporting recoverable issues
            /// </summary>
            RMW_LOG_SEVERITY_WARN = unchecked((int)RCUTILS_LOG_SEVERITY_WARN),

            /// <summary>
            /// Error log severity, for reporting uncoverable issues
            /// </summary>
            RMW_LOG_SEVERITY_ERROR = unchecked((int)RCUTILS_LOG_SEVERITY_ERROR),

            /// <summary>
            /// Fatal log severity, for reporting issue causing imminent shutdown
            /// </summary>
            RMW_LOG_SEVERITY_FATAL = unchecked((int)RCUTILS_LOG_SEVERITY_FATAL),
        }

        /// <summary>
        /// Debug log severity, for pedantic messaging
        /// </summary>
        public const RclNative.rmw_log_severity_t RMW_LOG_SEVERITY_DEBUG = rmw_log_severity_t.RMW_LOG_SEVERITY_DEBUG;

        /// <summary>
        /// Informational log severity, for reporting expected but not overwhelming information
        /// </summary>
        public const RclNative.rmw_log_severity_t RMW_LOG_SEVERITY_INFO = rmw_log_severity_t.RMW_LOG_SEVERITY_INFO;

        /// <summary>
        /// Warning log severity, for reporting recoverable issues
        /// </summary>
        public const RclNative.rmw_log_severity_t RMW_LOG_SEVERITY_WARN = rmw_log_severity_t.RMW_LOG_SEVERITY_WARN;

        /// <summary>
        /// Error log severity, for reporting uncoverable issues
        /// </summary>
        public const RclNative.rmw_log_severity_t RMW_LOG_SEVERITY_ERROR = rmw_log_severity_t.RMW_LOG_SEVERITY_ERROR;

        /// <summary>
        /// Fatal log severity, for reporting issue causing imminent shutdown
        /// </summary>
        public const RclNative.rmw_log_severity_t RMW_LOG_SEVERITY_FATAL = rmw_log_severity_t.RMW_LOG_SEVERITY_FATAL;

        /// <summary>
        /// Time source type, used to indicate the source of a time measurement.
        /// </summary>
        /// <remarks>
        /// RCL_ROS_TIME will report the latest value reported by a ROS time source, or
        /// if a ROS time source is not active it reports the same as RCL_SYSTEM_TIME.
        /// For more information about ROS time sources, refer to the design document:
        /// http://design.ros2.org/articles/clock_and_time.htmlRCL_SYSTEM_TIME reports the same value as the system clock.RCL_STEADY_TIME reports a value from a monotonically increasing clock.
        /// </remarks>
        public enum rcl_clock_type_t : int
        {
            RCL_CLOCK_UNINITIALIZED = unchecked((int)0),

            RCL_ROS_TIME,

            RCL_SYSTEM_TIME,

            RCL_STEADY_TIME,
        }

        public const RclNative.rcl_clock_type_t RCL_CLOCK_UNINITIALIZED = rcl_clock_type_t.RCL_CLOCK_UNINITIALIZED;

        public const RclNative.rcl_clock_type_t RCL_ROS_TIME = rcl_clock_type_t.RCL_ROS_TIME;

        public const RclNative.rcl_clock_type_t RCL_SYSTEM_TIME = rcl_clock_type_t.RCL_SYSTEM_TIME;

        public const RclNative.rcl_clock_type_t RCL_STEADY_TIME = rcl_clock_type_t.RCL_STEADY_TIME;

        /// <summary>
        /// Enumeration to describe the type of time jump.
        /// </summary>
        public enum rcl_clock_change_t : int
        {
            /// <summary>
            /// The source before and after the jump is ROS_TIME.
            /// </summary>
            RCL_ROS_TIME_NO_CHANGE = unchecked((int)1),

            /// <summary>
            /// The source switched to ROS_TIME from SYSTEM_TIME.
            /// </summary>
            RCL_ROS_TIME_ACTIVATED = unchecked((int)2),

            /// <summary>
            /// The source switched to SYSTEM_TIME from ROS_TIME.
            /// </summary>
            RCL_ROS_TIME_DEACTIVATED = unchecked((int)3),

            /// <summary>
            /// The source before and after the jump is SYSTEM_TIME.
            /// </summary>
            RCL_SYSTEM_TIME_NO_CHANGE = unchecked((int)4),
        }

        /// <summary>
        /// The source before and after the jump is ROS_TIME.
        /// </summary>
        public const RclNative.rcl_clock_change_t RCL_ROS_TIME_NO_CHANGE = rcl_clock_change_t.RCL_ROS_TIME_NO_CHANGE;

        /// <summary>
        /// The source switched to ROS_TIME from SYSTEM_TIME.
        /// </summary>
        public const RclNative.rcl_clock_change_t RCL_ROS_TIME_ACTIVATED = rcl_clock_change_t.RCL_ROS_TIME_ACTIVATED;

        /// <summary>
        /// The source switched to SYSTEM_TIME from ROS_TIME.
        /// </summary>
        public const RclNative.rcl_clock_change_t RCL_ROS_TIME_DEACTIVATED = rcl_clock_change_t.RCL_ROS_TIME_DEACTIVATED;

        /// <summary>
        /// The source before and after the jump is SYSTEM_TIME.
        /// </summary>
        public const RclNative.rcl_clock_change_t RCL_SYSTEM_TIME_NO_CHANGE = rcl_clock_change_t.RCL_SYSTEM_TIME_NO_CHANGE;

        public enum rcl_publisher_event_type_t : int
        {
            RCL_PUBLISHER_OFFERED_DEADLINE_MISSED,

            RCL_PUBLISHER_LIVELINESS_LOST,

            RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS,
        }

        public const RclNative.rcl_publisher_event_type_t RCL_PUBLISHER_OFFERED_DEADLINE_MISSED = rcl_publisher_event_type_t.RCL_PUBLISHER_OFFERED_DEADLINE_MISSED;

        public const RclNative.rcl_publisher_event_type_t RCL_PUBLISHER_LIVELINESS_LOST = rcl_publisher_event_type_t.RCL_PUBLISHER_LIVELINESS_LOST;

        public const RclNative.rcl_publisher_event_type_t RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS = rcl_publisher_event_type_t.RCL_PUBLISHER_OFFERED_INCOMPATIBLE_QOS;

        public enum rcl_subscription_event_type_t : int
        {
            RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED,

            RCL_SUBSCRIPTION_LIVELINESS_CHANGED,

            RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS,
        }

        public const RclNative.rcl_subscription_event_type_t RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED = rcl_subscription_event_type_t.RCL_SUBSCRIPTION_REQUESTED_DEADLINE_MISSED;

        public const RclNative.rcl_subscription_event_type_t RCL_SUBSCRIPTION_LIVELINESS_CHANGED = rcl_subscription_event_type_t.RCL_SUBSCRIPTION_LIVELINESS_CHANGED;

        public const RclNative.rcl_subscription_event_type_t RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS = rcl_subscription_event_type_t.RCL_SUBSCRIPTION_REQUESTED_INCOMPATIBLE_QOS;

        /// <summary>
        /// Encapsulation of an allocator.
        /// </summary>
        /// <remarks>
        /// The default allocator uses malloc(), free(), calloc(), and realloc().
        /// It can be obtained using rcutils_get_default_allocator().The allocator should be trivially copyable.
        /// Meaning that the struct should continue to work after being assignment
        /// copied into a new struct.
        /// Specifically the object pointed to by the state pointer should remain valid
        /// until all uses of the allocator have been made.
        /// Particular care should be taken when giving an allocator to functions like
        /// rcutils_*_init() where it is stored within another object and used later.
        /// Developers should note that, while the fields of a const-qualified allocator
        /// struct cannot be modified, the state of the allocator can be modified.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_allocator_t
        {
            /// <summary>
            /// Allocate memory, given a size and the `state` pointer.
            /// An error should be indicated by returning `NULL`.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclNative.size_t, void*, void*> allocate;

            /// <summary>
            /// Deallocate previously allocated memory, mimicking free().
            /// Also takes the `state` pointer.
            /// </summary>
            public delegate* unmanaged[Cdecl]<void*, void*, void> deallocate;

            /// <summary>
            /// Reallocate if possible, otherwise it deallocates and allocates.
            /// </summary>
            /// <remarks>
            /// Also takes the `state` pointer.If unsupported then do deallocate and then allocate.
            /// This should behave as realloc() does, as opposed to posix's
            /// [reallocf](https://linux.die.net/man/3/reallocf), i.e. the memory given
            /// by pointer will not be free'd automatically if realloc() fails.
            /// For reallocf-like behavior use rcutils_reallocf().
            /// This function must be able to take an input pointer of `NULL` and succeed.
            /// </remarks>
            public delegate* unmanaged[Cdecl]<void*, RclNative.size_t, void*, void*> reallocate;

            /// <summary>
            /// Allocate memory with all elements set to zero, given a number of elements and their size.
            /// An error should be indicated by returning `NULL`.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclNative.size_t, RclNative.size_t, void*, void*> zero_allocate;

            /// <summary>
            /// Implementation defined state storage.
            /// </summary>
            /// <remarks>
            /// This is passed as the final parameter to other allocator functions.
            /// Note that the contents of the state can be modified even in const-qualified
            /// allocator objects.
            /// </remarks>
            public void* state;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct size_t : IEquatable<size_t>
        {
            public size_t(nuint value) => this.Value = value;

            public readonly nuint Value;

            public bool Equals(size_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is size_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator nuint(size_t from) => from.Value;

            public static implicit operator size_t(nuint from) => new size_t(from);

            public static bool operator ==(size_t left, size_t right) => left.Equals(right);

            public static bool operator !=(size_t left, size_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_security_options_t
        {
            public RclNative.rmw_security_enforcement_policy_t enforce_security;

            public sbyte* security_root_path;
        }

        /// <summary>
        /// Implementation defined options structure used during rmw_init().
        /// </summary>
        /// <remarks>
        /// This should be defined by the rmw implementation.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_init_options_impl_t : IEquatable<rmw_init_options_impl_t>
        {
            private readonly IntPtr _handle;

            public rmw_init_options_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rmw_init_options_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rmw_init_options_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rmw_init_options_impl_t left, rmw_init_options_impl_t right) => left.Equals(right);

            public static bool operator !=(rmw_init_options_impl_t left, rmw_init_options_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Options structure used during rmw_init().
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_init_options_t
        {
            /// <summary>
            /// Locally (process local) unique ID that represents this init/shutdown cycle.
            /// </summary>
            /// <remarks>
            /// This should be set by the caller of `rmw_init()` to a number that is
            /// unique within this process.
            /// It is designed to be used with `rcl_init()` and `rcl_get_instance_id()`.
            /// </remarks>
            public ulong instance_id;

            /// <summary>
            /// Implementation identifier, used to ensure two different implementations are not being mixed.
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// ROS domain id
            /// </summary>
            public RclNative.size_t domain_id;

            /// <summary>
            /// Security options
            /// </summary>
            public RclNative.rmw_security_options_t security_options;

            /// <summary>
            /// Enable localhost only
            /// </summary>
            public RclNative.rmw_localhost_only_t localhost_only;

            /// <summary>
            /// Enclave, name used to find security artifacts in a sros2 keystore.
            /// </summary>
            public sbyte* enclave;

            /// <summary>
            /// TODO(wjwwood): replace with rmw_allocator_t when that refactor happens
            /// Allocator used during internal allocation of init options, if needed.
            /// </summary>
            public RclNative.rcutils_allocator_t allocator;

            /// <summary>
            /// Implementation defined init options.
            /// May be NULL if there are no implementation defined options.
            /// </summary>
            public RclNative.rmw_init_options_impl_t impl;
        }

        /// <summary>
        /// Implementation defined context structure returned by rmw_init().
        /// </summary>
        /// <remarks>
        /// This should be defined by the rmw implementation.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_context_impl_t : IEquatable<rmw_context_impl_t>
        {
            private readonly IntPtr _handle;

            public rmw_context_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rmw_context_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rmw_context_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rmw_context_impl_t left, rmw_context_impl_t right) => left.Equals(right);

            public static bool operator !=(rmw_context_impl_t left, rmw_context_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Initialization context structure which is used to store init specific information.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_context_t
        {
            /// <summary>
            /// Locally (process local) unique ID that represents this init/shutdown cycle.
            /// </summary>
            public ulong instance_id;

            /// <summary>
            /// Implementation identifier, used to ensure two different implementations are not being mixed.
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Options used to initialize the context.
            /// </summary>
            public RclNative.rmw_init_options_t options;

            /// <summary>
            /// Implementation defined context information.
            /// May be NULL if there is no implementation defined context information.
            /// </summary>
            public RclNative.rmw_context_impl_t impl;
        }

        /// <summary>
        /// Struct wrapping a fixed-size c string used for returning the formatted error string.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_error_string_t
        {
            public fixed sbyte str[1024];
        }

        /// <summary>
        /// Struct which encapsulates the error state set by RCUTILS_SET_ERROR_MSG().
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_error_state_t
        {
            /// <summary>
            /// User message storage, limited to RCUTILS_ERROR_STATE_MESSAGE_MAX_LENGTH characters.
            /// </summary>
            public fixed sbyte message[768];

            /// <summary>
            /// File name, limited to what's left from RCUTILS_ERROR_STATE_MAX_SIZE characters
            /// after subtracting storage for others.
            /// </summary>
            public fixed sbyte file[229];

            /// <summary>
            /// Line number of error.
            /// </summary>
            public ulong line_number;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_array_list_impl_t : IEquatable<rcutils_array_list_impl_t>
        {
            private readonly IntPtr _handle;

            public rcutils_array_list_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcutils_array_list_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcutils_array_list_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcutils_array_list_impl_t left, rcutils_array_list_impl_t right) => left.Equals(right);

            public static bool operator !=(rcutils_array_list_impl_t left, rcutils_array_list_impl_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_array_list_t
        {
            public RclNative.rcutils_array_list_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_char_array_t
        {
            public sbyte* buffer;

            /// <summary>
            /// if this is true, we may safely free/realloc the buffer as needed;
            /// otherwise we will leave the buffer alone and alloc new memory if
            /// more space is needed
            /// </summary>
            public bool owns_buffer;

            public RclNative.size_t buffer_length;

            public RclNative.size_t buffer_capacity;

            public RclNative.rcutils_allocator_t allocator;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_hash_map_impl_t : IEquatable<rcutils_hash_map_impl_t>
        {
            private readonly IntPtr _handle;

            public rcutils_hash_map_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcutils_hash_map_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcutils_hash_map_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcutils_hash_map_impl_t left, rcutils_hash_map_impl_t right) => left.Equals(right);

            public static bool operator !=(rcutils_hash_map_impl_t left, rcutils_hash_map_impl_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_hash_map_t
        {
            public RclNative.rcutils_hash_map_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_string_array_t
        {
            public RclNative.size_t size;

            public sbyte** data;

            public RclNative.rcutils_allocator_t allocator;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_string_map_impl_t : IEquatable<rcutils_string_map_impl_t>
        {
            private readonly IntPtr _handle;

            public rcutils_string_map_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcutils_string_map_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcutils_string_map_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcutils_string_map_impl_t left, rcutils_string_map_impl_t right) => left.Equals(right);

            public static bool operator !=(rcutils_string_map_impl_t left, rcutils_string_map_impl_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_string_map_t
        {
            public RclNative.rcutils_string_map_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_uint8_array_t
        {
            public byte* buffer;

            public RclNative.size_t buffer_length;

            public RclNative.size_t buffer_capacity;

            public RclNative.rcutils_allocator_t allocator;
        }

        /// <summary>
        /// The structure identifying the caller location in the source code.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcutils_log_location_t
        {
            /// <summary>
            /// The name of the function containing the log call.
            /// </summary>
            public byte* function_name;

            /// <summary>
            /// The name of the source file containing the log call.
            /// </summary>
            public byte* file_name;

            /// <summary>
            /// The line number containing the log call.
            /// </summary>
            public RclNative.size_t line_number;
        }

        /// <summary>
        /// Structure which encapsulates an rmw node
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_node_t
        {
            /// <summary>
            /// Name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this node's data
            /// </summary>
            public void* data;

            /// <summary>
            /// A concise name of this rmw node for identification
            /// </summary>
            public byte* name;

            /// <summary>
            /// The namespace of this rmw node
            /// </summary>
            public byte* namespace_;

            /// <summary>
            /// Context information about node's init specific information
            /// </summary>
            public RclNative.rmw_context_t* context;
        }

        /// <summary>
        /// Options that can be used to configure the creation of a publisher in rmw.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_publisher_options_t
        {
            /// <summary>
            /// Used to pass rmw implementation specific resources during publisher creation.
            /// </summary>
            /// <remarks>
            /// This field is type erased (rather than forward declared) because it will
            /// usually be a non-owned reference to an language specific object, e.g.
            /// C++ it may be a polymorphic class that only the rmw implementation can use.The resource pointed to here needs to outlive this options structure, and
            /// any rmw_publisher objects that are created using it, as they copy this
            /// structure and may use this payload throughout their lifetime.
            /// </remarks>
            public void* rmw_specific_publisher_payload;
        }

        /// <summary>
        /// Structure which encapsulates an rmw publisher
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_publisher_t
        {
            /// <summary>
            /// Name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this publisher's data
            /// </summary>
            public void* data;

            /// <summary>
            /// The name of the ROS topic this publisher publishes to
            /// </summary>
            public byte* topic_name;

            /// <summary>
            /// Publisher options.
            /// </summary>
            /// <remarks>
            /// The options structure passed to rmw_create_publisher() should be
            /// assigned to this field by the rmw implementation.
            /// The fields should not be modified after creation, but
            /// the contents of the options structure may or may not be const, i.e.
            /// shallow const-ness.
            /// This field is not marked const to avoid any const casting during setup.
            /// </remarks>
            public RclNative.rmw_publisher_options_t options;

            /// <summary>
            /// Indicate whether this publisher supports loaning messages
            /// </summary>
            public bool can_loan_messages;
        }

        /// <summary>
        /// Options that can be used to configure the creation of a subscription in rmw.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_subscription_options_t
        {
            /// <summary>
            /// Used to pass rmw implementation specific resources during subscription creation.
            /// </summary>
            /// <remarks>
            /// All the same details and restrictions of this field in
            /// rmw_publisher_options_t apply to this struct as well.
            /// </remarks>
            /// <seealso cref="rmw_publisher_options_t.rmw_specific_publisher_payload"/>
            public void* rmw_specific_subscription_payload;

            /// <summary>
            /// If true then the middleware should not deliver data from local publishers.
            /// </summary>
            /// <remarks>
            /// This setting is most often used when data should only be received from
            /// remote nodes, especially to avoid "double delivery" when both intra- and
            /// inter- process communication is taking place.@TODO (wjwwood): nail this down when participant mapping is sorted out.
            /// See: https://github.com/ros2/design/pull/250The definition of local is somewhat vague at the moment.
            /// Right now it means local to the node, and that definition works best, but
            /// may become more complicated when/if participants map to a context instead.
            /// </remarks>
            public bool ignore_local_publications;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_subscription_t
        {
            /// <summary>
            /// Name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this subscription
            /// </summary>
            public void* data;

            /// <summary>
            /// Name of the ros topic this subscription listens to
            /// </summary>
            public byte* topic_name;

            /// <summary>
            /// Subscription options.
            /// </summary>
            /// <remarks>
            /// The options structure passed to rmw_create_subscription() should be
            /// assigned to this field by the rmw implementation.
            /// The fields should not be modified after creation, but
            /// the contents of the options structure may or may not be const, i.e.
            /// shallow const-ness.
            /// This field is not marked const to avoid any const casting during setup.
            /// </remarks>
            public RclNative.rmw_subscription_options_t options;

            /// <summary>
            /// Indicates whether this subscription can loan messages
            /// </summary>
            public bool can_loan_messages;
        }

        /// <summary>
        /// A handle to an rmw service
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_service_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this service
            /// </summary>
            public void* data;

            /// <summary>
            /// The name of this service as exposed to the ros graph
            /// </summary>
            public byte* service_name;
        }

        /// <summary>
        /// A handle to an rmw service client
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_client_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this service client
            /// </summary>
            public void* data;

            /// <summary>
            /// The name of this service as exposed to the ros graph
            /// </summary>
            public byte* service_name;
        }

        /// <summary>
        /// Handle for an rmw guard condition
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_guard_condition_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this guard condition
            /// </summary>
            public void* data;

            /// <summary>
            /// rmw context associated with this guard condition
            /// </summary>
            public RclNative.rmw_context_t* context;
        }

        /// <summary>
        /// Allocation of memory for an rmw publisher
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_publisher_allocation_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this allocation
            /// </summary>
            public void* data;
        }

        /// <summary>
        /// Allocation of memory for an rmw subscription
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_subscription_allocation_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Type erased pointer to this allocation
            /// </summary>
            public void* data;
        }

        /// <summary>
        /// Array of subscriber handles.
        /// </summary>
        /// <remarks>
        /// An array of void * pointers representing type-erased middleware-specific subscriptions.
        /// The number of non-null entries may be smaller than the allocated size of the array.
        /// The number of subscriptions represented may be smaller than the allocated size of the array.
        /// The creator of this struct is responsible for allocating and deallocating the array.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_subscriptions_t
        {
            /// <summary>
            /// The number of subscribers represented by the array.
            /// </summary>
            public RclNative.size_t subscriber_count;

            /// <summary>
            /// Pointer to an array of void * pointers of subscriptions.
            /// </summary>
            public void** subscribers;
        }

        /// <summary>
        /// Array of service handles.
        /// </summary>
        /// <remarks>
        /// An array of void * pointers representing type-erased middleware-specific services.
        /// The number of non-null entries may be smaller than the allocated size of the array.
        /// The number of services represented may be smaller than the allocated size of the array.
        /// The creator of this struct is responsible for allocating and deallocating the array.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_services_t
        {
            /// <summary>
            /// The number of services represented by the array.
            /// </summary>
            public RclNative.size_t service_count;

            /// <summary>
            /// Pointer to an array of void * pointers of services.
            /// </summary>
            public void** services;
        }

        /// <summary>
        /// Array of client handles.
        /// </summary>
        /// <remarks>
        /// An array of void * pointers representing type-erased middleware-specific clients.
        /// The number of non-null entries may be smaller than the allocated size of the array.
        /// The number of clients represented may be smaller than the allocated size of the array.
        /// The creator of this struct is responsible for allocating and deallocating the array.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_clients_t
        {
            /// <summary>
            /// The number of clients represented by the array.
            /// </summary>
            public RclNative.size_t client_count;

            /// <summary>
            /// Pointer to an array of void * pointers of clients.
            /// </summary>
            public void** clients;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_events_t
        {
            /// <summary>
            /// The number of events represented by the array.
            /// </summary>
            public RclNative.size_t event_count;

            /// <summary>
            /// Pointer to an array of void * pointers of events.
            /// </summary>
            public void** events;
        }

        /// <summary>
        /// Array of guard condition handles.
        /// </summary>
        /// <remarks>
        /// An array of void * pointers representing type-erased middleware-specific guard conditions.
        /// The number of non-null entries may be smaller than the allocated size of the array.
        /// The number of guard conditions represented may be smaller than the allocated size of the array.
        /// The creator of this struct is responsible for allocating and deallocating the array.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_guard_conditions_t
        {
            /// <summary>
            /// The number of guard conditions represented by the array.
            /// </summary>
            public RclNative.size_t guard_condition_count;

            /// <summary>
            /// Pointer to an array of void * pointers of guard conditions.
            /// </summary>
            public void** guard_conditions;
        }

        /// <summary>
        /// Container for guard conditions to be waited on
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_wait_set_t
        {
            /// <summary>
            /// The name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// The guard condition to be waited on
            /// </summary>
            public RclNative.rmw_guard_conditions_t* guard_conditions;

            /// <summary>
            /// Type erased pointer to this wait set's data
            /// </summary>
            public void* data;
        }

        /// <summary>
        /// An rmw service request identifier
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_request_id_t
        {
            /// <summary>
            /// The guid of the writer associated with this request
            /// </summary>
            public fixed sbyte writer_guid[16];

            /// <summary>
            /// Sequence number of this service
            /// </summary>
            public long sequence_number;
        }

        /// <summary>
        /// Struct representing a time point for rmw
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_time_t
        {
            /// <summary>
            /// Seconds since the epoch
            /// </summary>
            public ulong sec;

            /// <summary>
            /// Nanoseconds component of this time point
            /// </summary>
            public ulong nsec;
        }

        /// <summary>
        /// Meta-data for a service-related take.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_service_info_t
        {
            public RclNative.rmw_time_point_value_t source_timestamp;

            public RclNative.rmw_time_point_value_t received_timestamp;

            public RclNative.rmw_request_id_t request_id;
        }

        /// <summary>
        /// A single point in time, measured in nanoseconds since the Unix epoch.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_time_point_value_t : IEquatable<rcutils_time_point_value_t>
        {
            public rcutils_time_point_value_t(long value) => this.Value = value;

            public readonly long Value;

            public bool Equals(rcutils_time_point_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcutils_time_point_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator long(rcutils_time_point_value_t from) => from.Value;

            public static implicit operator rcutils_time_point_value_t(long from) => new rcutils_time_point_value_t(from);

            public static bool operator ==(rcutils_time_point_value_t left, rcutils_time_point_value_t right) => left.Equals(right);

            public static bool operator !=(rcutils_time_point_value_t left, rcutils_time_point_value_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_time_point_value_t : IEquatable<rmw_time_point_value_t>
        {
            public rmw_time_point_value_t(RclNative.rcutils_time_point_value_t value) => this.Value = value;

            public readonly RclNative.rcutils_time_point_value_t Value;

            public bool Equals(rmw_time_point_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rmw_time_point_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcutils_time_point_value_t(rmw_time_point_value_t from) => from.Value;

            public static implicit operator rmw_time_point_value_t(RclNative.rcutils_time_point_value_t from) => new rmw_time_point_value_t(from);

            public static bool operator ==(rmw_time_point_value_t left, rmw_time_point_value_t right) => left.Equals(right);

            public static bool operator !=(rmw_time_point_value_t left, rmw_time_point_value_t right) => !left.Equals(right);
        }

        /// <summary>
        /// ROS MiddleWare quality of service profile.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_qos_profile_t
        {
            public RclNative.rmw_qos_history_policy_t history;

            /// <summary>
            /// Size of the message queue.
            /// </summary>
            public RclNative.size_t depth;

            /// <summary>
            /// Reliabiilty QoS policy setting
            /// </summary>
            public RclNative.rmw_qos_reliability_policy_t reliability;

            /// <summary>
            /// Durability QoS policy setting
            /// </summary>
            public RclNative.rmw_qos_durability_policy_t durability;

            /// <summary>
            /// The period at which messages are expected to be sent/received
            /// </summary>
            public RclNative.rmw_time_t deadline;

            /// <summary>
            /// The age at which messages are considered expired and no longer valid
            /// </summary>
            public RclNative.rmw_time_t lifespan;

            /// <summary>
            /// Liveliness QoS policy setting
            /// </summary>
            public RclNative.rmw_qos_liveliness_policy_t liveliness;

            /// <summary>
            /// The time within which the RMW node or publisher must show that it is alive
            /// </summary>
            public RclNative.rmw_time_t liveliness_lease_duration;

            /// <summary>
            /// If true, any ROS specific namespacing conventions will be circumvented.
            /// </summary>
            /// <remarks>
            /// In the case of DDS and topics, for example, this means the typical
            /// ROS specific prefix of `rt` would not be applied as described here:http://design.ros2.org/articles/topic_and_service_names.html#ros-specific-namespace-prefixThis might be useful when trying to directly connect a native DDS topic
            /// with a ROS 2 topic.
            /// </remarks>
            public bool avoid_ros_namespace_conventions;
        }

        /// <summary>
        /// ROS graph ID of the topic
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_gid_t
        {
            /// <summary>
            /// Name of the rmw implementation
            /// </summary>
            public byte* implementation_identifier;

            /// <summary>
            /// Bype data Gid value
            /// </summary>
            public fixed byte data[24];
        }

        /// <summary>
        /// Information describing an rmw message
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_message_info_t
        {
            public RclNative.rmw_time_point_value_t source_timestamp;

            public RclNative.rmw_time_point_value_t received_timestamp;

            public RclNative.rmw_gid_t publisher_gid;

            /// <summary>
            /// Whether this message is from intra_process communication or not
            /// </summary>
            public bool from_intra_process;
        }

        /// <summary>
        /// QoS Liveliness Changed information provided by a subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_liveliness_changed_status_t
        {
            /// <summary>
            /// The total number of currently active Publishers which publish to the topic associated with
            /// the Subscription.
            /// This count increases when a newly matched Publisher asserts its liveliness for the first time
            /// or when a Publisher previously considered to be not alive reasserts its liveliness.
            /// The count decreases when a Publisher considered alive fails to assert its liveliness and
            /// becomes not alive, whether because it was deleted normally or for some other reason.
            /// </summary>
            public int alive_count;

            /// <summary>
            /// The total count of current Publishers which publish to the topic associated with the
            /// Subscription that are no longer asserting their liveliness.
            /// This count increases when a Publisher considered alive fails to assert its liveliness and
            /// becomes not alive for some reason other than the normal deletion of that Publisher.
            /// It decreases when a previously not alive Publisher either reasserts its liveliness or is
            /// deleted normally.
            /// </summary>
            public int not_alive_count;

            /// <summary>
            /// The change in the alive_count since the status was last read.
            /// </summary>
            public int alive_count_change;

            /// <summary>
            /// The change in the not_alive_count since the status was last read.
            /// </summary>
            public int not_alive_count_change;
        }

        /// <summary>
        /// QoS Requested Deadline Missed information provided by a subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_requested_deadline_missed_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of missed deadlines detected for any instance read by the
            /// subscription.
            /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
            /// by one for each instance for which data was not received.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The incremental number of deadlines detected since the status was read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// QoS Liveliness Lost information provided by a publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_liveliness_lost_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of times that a previously-alive Publisher became not alive due to
            /// a failure to actively signal its liveliness within its offered liveliness period.
            /// This count does not change when an already not alive Publisher simply remains not alive for
            /// another liveliness period.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The change in total_count since the last time the status was last read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// QoS Deadline Missed information provided by a publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_offered_deadline_missed_status_t
        {
            /// <summary>
            /// Lifetime cumulative number of offered deadline periods elapsed during which a Publisher failed
            /// to provide data.
            /// Missed deadlines accumulate; that is, each deadline period the total_count will be incremented
            /// by one.
            /// </summary>
            public int total_count;

            /// <summary>
            /// The change in total_count since the last time the status was last read.
            /// </summary>
            public int total_count_change;
        }

        /// <summary>
        /// Array of bool values
        /// </summary>
        /// <remarks>
        ///  rcl_bool_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_bool_array_s
        {
            /// <summary>
            /// Array with bool values
            /// </summary>
            public bool* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclNative.size_t size;
        }

        /// <summary>
        /// Array of int64_t values
        /// </summary>
        /// <remarks>
        ///  rcl_int64_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_int64_array_s
        {
            /// <summary>
            /// Array with int64 values
            /// </summary>
            public long* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclNative.size_t size;
        }

        /// <summary>
        /// Array of double values
        /// </summary>
        /// <remarks>
        ///  rcl_double_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_double_array_s
        {
            /// <summary>
            /// Array with double values
            /// </summary>
            public double* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclNative.size_t size;
        }

        /// <summary>
        /// Array of byte values
        /// </summary>
        /// <remarks>
        ///  rcl_byte_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_byte_array_s
        {
            /// <summary>
            /// Array with uint8_t values
            /// </summary>
            public byte* values;

            /// <summary>
            /// Number of values in the array
            /// </summary>
            public RclNative.size_t size;
        }

        /// <summary>
        /// variant_t stores the value of a parameter
        /// </summary>
        /// <remarks>
        /// Only one pointer in this struct will store the value rcl_variant_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_variant_s
        {
            /// <summary>
            /// If bool, gets stored here
            /// </summary>
            public bool* bool_value;

            /// <summary>
            /// If integer, gets stored here
            /// </summary>
            public long* integer_value;

            /// <summary>
            /// If double, gets stored here
            /// </summary>
            public double* double_value;

            /// <summary>
            /// If string, gets stored here
            /// </summary>
            public sbyte* string_value;

            /// <summary>
            /// If array of bytes
            /// </summary>
            public RclNative.rcl_byte_array_t* byte_array_value;

            /// <summary>
            /// If array of bool's
            /// </summary>
            public RclNative.rcl_bool_array_t* bool_array_value;

            /// <summary>
            /// If array of integers
            /// </summary>
            public RclNative.rcl_int64_array_t* integer_array_value;

            /// <summary>
            /// If array of doubles
            /// </summary>
            public RclNative.rcl_double_array_t* double_array_value;

            /// <summary>
            /// If array of strings
            /// </summary>
            public RclNative.rcutils_string_array_t* string_array_value;
        }

        /// <summary>
        /// Array of byte values
        /// </summary>
        /// <remarks>
        ///  rcl_byte_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_byte_array_t : IEquatable<rcl_byte_array_t>
        {
            public rcl_byte_array_t(RclNative.rcl_byte_array_s value) => this.Value = value;

            public readonly RclNative.rcl_byte_array_s Value;

            public bool Equals(rcl_byte_array_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_byte_array_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_byte_array_s(rcl_byte_array_t from) => from.Value;

            public static implicit operator rcl_byte_array_t(RclNative.rcl_byte_array_s from) => new rcl_byte_array_t(from);

            public static bool operator ==(rcl_byte_array_t left, rcl_byte_array_t right) => left.Equals(right);

            public static bool operator !=(rcl_byte_array_t left, rcl_byte_array_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Array of bool values
        /// </summary>
        /// <remarks>
        ///  rcl_bool_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_bool_array_t : IEquatable<rcl_bool_array_t>
        {
            public rcl_bool_array_t(RclNative.rcl_bool_array_s value) => this.Value = value;

            public readonly RclNative.rcl_bool_array_s Value;

            public bool Equals(rcl_bool_array_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_bool_array_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_bool_array_s(rcl_bool_array_t from) => from.Value;

            public static implicit operator rcl_bool_array_t(RclNative.rcl_bool_array_s from) => new rcl_bool_array_t(from);

            public static bool operator ==(rcl_bool_array_t left, rcl_bool_array_t right) => left.Equals(right);

            public static bool operator !=(rcl_bool_array_t left, rcl_bool_array_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Array of int64_t values
        /// </summary>
        /// <remarks>
        ///  rcl_int64_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_int64_array_t : IEquatable<rcl_int64_array_t>
        {
            public rcl_int64_array_t(RclNative.rcl_int64_array_s value) => this.Value = value;

            public readonly RclNative.rcl_int64_array_s Value;

            public bool Equals(rcl_int64_array_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_int64_array_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_int64_array_s(rcl_int64_array_t from) => from.Value;

            public static implicit operator rcl_int64_array_t(RclNative.rcl_int64_array_s from) => new rcl_int64_array_t(from);

            public static bool operator ==(rcl_int64_array_t left, rcl_int64_array_t right) => left.Equals(right);

            public static bool operator !=(rcl_int64_array_t left, rcl_int64_array_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Array of double values
        /// </summary>
        /// <remarks>
        ///  rcl_double_array_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_double_array_t : IEquatable<rcl_double_array_t>
        {
            public rcl_double_array_t(RclNative.rcl_double_array_s value) => this.Value = value;

            public readonly RclNative.rcl_double_array_s Value;

            public bool Equals(rcl_double_array_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_double_array_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_double_array_s(rcl_double_array_t from) => from.Value;

            public static implicit operator rcl_double_array_t(RclNative.rcl_double_array_s from) => new rcl_double_array_t(from);

            public static bool operator ==(rcl_double_array_t left, rcl_double_array_t right) => left.Equals(right);

            public static bool operator !=(rcl_double_array_t left, rcl_double_array_t right) => !left.Equals(right);
        }

        /// <summary>
        /// node_params_t stores all the parameters(key:value) of a single node
        /// </summary>
        /// <remarks>
        ///  rcl_node_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_node_params_s
        {
            /// <summary>
            /// Array of parameter names (keys)
            /// </summary>
            public sbyte** parameter_names;

            /// <summary>
            /// Array of coressponding parameter values
            /// </summary>
            public RclNative.rcl_variant_t* parameter_values;

            /// <summary>
            /// Number of parameters in the node
            /// </summary>
            public RclNative.size_t num_params;
        }

        /// <summary>
        /// variant_t stores the value of a parameter
        /// </summary>
        /// <remarks>
        /// Only one pointer in this struct will store the value rcl_variant_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_variant_t : IEquatable<rcl_variant_t>
        {
            public rcl_variant_t(RclNative.rcl_variant_s value) => this.Value = value;

            public readonly RclNative.rcl_variant_s Value;

            public bool Equals(rcl_variant_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_variant_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_variant_s(rcl_variant_t from) => from.Value;

            public static implicit operator rcl_variant_t(RclNative.rcl_variant_s from) => new rcl_variant_t(from);

            public static bool operator ==(rcl_variant_t left, rcl_variant_t right) => left.Equals(right);

            public static bool operator !=(rcl_variant_t left, rcl_variant_t right) => !left.Equals(right);
        }

        /// <summary>
        /// stores all the parameters of all nodes of a process
        /// </summary>
        /// <remarks>
        ///  rcl_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_params_s
        {
            /// <summary>
            /// List of names of the node
            /// </summary>
            public sbyte** node_names;

            /// <summary>
            /// Array of parameters
            /// </summary>
            public RclNative.rcl_node_params_t* @params;

            /// <summary>
            /// Number of nodes
            /// </summary>
            public RclNative.size_t num_nodes;

            /// <summary>
            /// Allocator used
            /// </summary>
            public RclNative.rcutils_allocator_t allocator;
        }

        /// <summary>
        /// node_params_t stores all the parameters(key:value) of a single node
        /// </summary>
        /// <remarks>
        ///  rcl_node_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_node_params_t : IEquatable<rcl_node_params_t>
        {
            public rcl_node_params_t(RclNative.rcl_node_params_s value) => this.Value = value;

            public readonly RclNative.rcl_node_params_s Value;

            public bool Equals(rcl_node_params_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_node_params_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_node_params_s(rcl_node_params_t from) => from.Value;

            public static implicit operator rcl_node_params_t(RclNative.rcl_node_params_s from) => new rcl_node_params_t(from);

            public static bool operator ==(rcl_node_params_t left, rcl_node_params_t right) => left.Equals(right);

            public static bool operator !=(rcl_node_params_t left, rcl_node_params_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_arguments_impl_t : IEquatable<rcl_arguments_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_arguments_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_arguments_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_arguments_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_arguments_impl_t left, rcl_arguments_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_arguments_impl_t left, rcl_arguments_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Hold output of parsing command line arguments.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_arguments_t
        {
            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public RclNative.rcl_arguments_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_init_options_impl_t : IEquatable<rcl_init_options_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_init_options_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_init_options_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_init_options_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_init_options_impl_t left, rcl_init_options_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_init_options_impl_t left, rcl_init_options_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Encapsulation of init options and implementation defined init options.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_init_options_t
        {
            /// <summary>
            /// Implementation specific pointer.
            /// </summary>
            public RclNative.rcl_init_options_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_context_impl_t : IEquatable<rcl_context_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_context_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_context_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_context_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_context_impl_t left, rcl_context_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_context_impl_t left, rcl_context_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Encapsulates the non-global state of an init/shutdown cycle.
        /// </summary>
        /// <remarks>
        /// The context is used in the creation of top level entities like nodes and
        /// guard conditions, as well as to shutdown a specific instance of init.Here is a diagram of a typical context's lifecycle:```
        /// +---------------+
        /// |               |
        /// +--&gt; uninitialized +---&gt; rcl_get_zero_initialized_context() +
        /// |  |               |                                        |
        /// |  +---------------+                                        |
        /// |                                                           |
        /// |           +-----------------------------------------------+
        /// |           |
        /// |  +--------v---------+                +-----------------------+
        /// |  |                  |                |                       |
        /// |  | zero-initialized +-&gt; rcl_init() +-&gt; initialized and valid +-&gt; rcl_shutdown() +
        /// |  |                  |                |                       |                  |
        /// |  +------------------+                +-----------------------+                  |
        /// |                                                                                 |
        /// |               +-----------------------------------------------------------------+
        /// |               |
        /// |  +------------v------------+
        /// |  |                         |
        /// |  | initialized but invalid +---&gt; finalize all entities, then rcl_context_fini() +
        /// |  |                         |                                                    |
        /// |  +-------------------------+                                                    |
        /// |                                                                                 |
        /// +---------------------------------------------------------------------------------+
        /// ```A declared but not defined `rcl_context_t` instance is considered to be
        /// "uninitialized", and passing an uninitialized context to any functions will
        /// result in undefined behavior.
        /// Some functions, like `rcl_init()` require the context instance to be
        /// zero initialized (all members set to "zero" state) before use.Zero initialization of an `rcl_context_t` should be done with
        /// `rcl_get_zero_initialized_context()`, which ensures the context is in a safe
        /// state for initialization with `rcl_init()`.Initialization of an `rcl_context_t` should be done with `rcl_init()`, after
        /// which the context is considered both initialized and valid.
        /// After initialization it can be used in the creation of other entities like
        /// nodes and guard conditions.At any time the context can be invalidated by calling `rcl_shutdown()` on
        /// the `rcl_context_t`, after which the context is still initialized but now
        /// invalid.Invalidation indicates to other entities that the context was shutdown, but
        /// is still accessible for use during cleanup of themselves.After being invalidated, and after all of the entities which used it have
        /// been finalized, the context should be finalized with `rcl_context_fini()`.Finalizing the context while entities which have copies of it have not yet
        /// been finalized is undefined behavior.
        /// Therefore, the context's lifetime (between calls to `rcl_init()` and
        /// `rcl_context_fini()`) should exceed the lifetime of all entities which use
        /// it directly (e.g. nodes and guard conditions) or indirectly (e.g.
        /// subscriptions and topics).
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_context_t
        {
            /// <summary>
            /// Global arguments for all nodes which share this context.
            /// Typically generated by the parsing of argc/argv in `rcl_init()`.
            /// </summary>
            public RclNative.rcl_arguments_t global_arguments;

            /// <summary>
            /// Implementation specific pointer.
            /// </summary>
            public RclNative.rcl_context_impl_t impl;

            /// <summary>
            /// Private storage for instance ID atomic.
            /// </summary>
            /// <remarks>
            /// Accessing the instance id should be done using the function
            /// `rcl_context_get_instance_id()` because the instance id's type is an
            /// atomic and needs to be accessed properly to ensure safety.The instance id should not be changed manually - doing so is undefined
            /// behavior.The instance id cannot be protected within the `impl` pointer's type
            /// because it needs to be accessible even when the context is zero
            /// initialized and therefore `impl` is `NULL`.
            /// Specifically, storing the instance id in the `impl` would introduce a
            /// race condition between accessing it and finalizing the context.
            /// Additionally, C11 atomics (i.e. "stdatomic.h") cannot be used directly
            /// here in the case that this header is included into a C++ program.
            /// See this paper for an effort to make this possible in the future:
            /// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0943r1.html
            /// </remarks>
            public fixed byte instance_id_storage[8];
        }

        /// <summary>
        /// Structure which encapsulates the options for creating a rcl_node_t.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_node_options_t
        {
            /// <summary>
            /// If set, then this value overrides the ROS_DOMAIN_ID environment variable.
            /// </summary>
            /// <remarks>
            /// It defaults to RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID, which will cause the
            /// node to use the ROS domain ID set in the ROS_DOMAIN_ID environment
            /// variable, or on some systems 0 if the environment variable is not set.
            /// </remarks>
            /// <todo>
            /// TODO(wjwwood):
            /// Should we put a limit on the ROS_DOMAIN_ID value, that way we can have
            /// a safe value for the default RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID?
            /// (currently max size_t)
            /// </todo>
            public RclNative.size_t domain_id;

            /// <summary>
            /// Custom allocator used for internal allocations.
            /// </summary>
            public RclNative.rcl_allocator_t allocator;

            /// <summary>
            /// If false then only use arguments in this struct, otherwise use global arguments also.
            /// </summary>
            public bool use_global_arguments;

            /// <summary>
            /// Command line arguments that apply only to this node.
            /// </summary>
            public RclNative.rcl_arguments_t arguments;

            /// <summary>
            /// Flag to enable rosout for this node
            /// </summary>
            public bool enable_rosout;
        }

        /// <summary>
        /// Encapsulation of an allocator.
        /// </summary>
        /// <remarks>
        /// The default allocator uses malloc(), free(), calloc(), and realloc().
        /// It can be obtained using rcutils_get_default_allocator().The allocator should be trivially copyable.
        /// Meaning that the struct should continue to work after being assignment
        /// copied into a new struct.
        /// Specifically the object pointed to by the state pointer should remain valid
        /// until all uses of the allocator have been made.
        /// Particular care should be taken when giving an allocator to functions like
        /// rcutils_*_init() where it is stored within another object and used later.
        /// Developers should note that, while the fields of a const-qualified allocator
        /// struct cannot be modified, the state of the allocator can be modified.
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_allocator_t : IEquatable<rcl_allocator_t>
        {
            public rcl_allocator_t(RclNative.rcutils_allocator_t value) => this.Value = value;

            public readonly RclNative.rcutils_allocator_t Value;

            public bool Equals(rcl_allocator_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_allocator_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcutils_allocator_t(rcl_allocator_t from) => from.Value;

            public static implicit operator rcl_allocator_t(RclNative.rcutils_allocator_t from) => new rcl_allocator_t(from);

            public static bool operator ==(rcl_allocator_t left, rcl_allocator_t right) => left.Equals(right);

            public static bool operator !=(rcl_allocator_t left, rcl_allocator_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Handle for a rcl guard condition.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_guard_condition_t
        {
            /// <summary>
            /// Context associated with this guard condition.
            /// </summary>
            public RclNative.rcl_context_t* context;

            /// <summary>
            /// Pointer to the guard condition implementation
            /// </summary>
            public RclNative.rcl_guard_condition_impl_t impl;
        }

        /// <summary>
        /// Internal rcl guard condition implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_guard_condition_impl_t : IEquatable<rcl_guard_condition_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_guard_condition_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_guard_condition_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_guard_condition_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_guard_condition_impl_t left, rcl_guard_condition_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_guard_condition_impl_t left, rcl_guard_condition_impl_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_node_impl_t : IEquatable<rcl_node_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_node_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_node_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_node_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_node_impl_t left, rcl_node_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_node_impl_t left, rcl_node_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Node.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_node_t
        {
            /// <summary>
            /// Context associated with this node.
            /// </summary>
            public RclNative.rcl_context_t* context;

            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public RclNative.rcl_node_impl_t impl;
        }

        /// <summary>
        /// Contains rosidl message type support data
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rosidl_message_type_support_t
        {
            /// <summary>
            /// String identifier for the type_support.
            /// </summary>
            public byte* typesupport_identifier;

            /// <summary>
            /// Pointer to the message type support library
            /// </summary>
            public void* data;

            /// <summary>
            /// Pointer to the message type support handler function
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclNative.rosidl_message_type_support_t*, byte*, RclNative.rosidl_message_type_support_t*> func;
        }

        /// <summary>
        /// Internal rcl publisher implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_publisher_impl_t : IEquatable<rcl_publisher_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_publisher_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_publisher_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_publisher_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_publisher_impl_t left, rcl_publisher_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_publisher_impl_t left, rcl_publisher_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_publisher_t
        {
            /// <summary>
            /// Pointer to the publisher implementation
            /// </summary>
            public RclNative.rcl_publisher_impl_t impl;
        }

        /// <summary>
        /// Options available for a rcl publisher.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_publisher_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the publisher.
            /// </summary>
            public RclNative.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the publisher, used for incidental allocations.
            /// For default behavior (malloc/free), use: rcl_get_default_allocator()
            /// </summary>
            public RclNative.rcl_allocator_t allocator;

            /// <summary>
            /// rmw specific publisher options, e.g. the rmw implementation specific payload.
            /// </summary>
            public RclNative.rmw_publisher_options_t rmw_publisher_options;
        }

        /// <summary>
        /// Structure to hold a sequence of ROS messages.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_message_sequence_t
        {
            /// <summary>
            /// Array of pointers to ROS messages.
            /// </summary>
            public void** data;

            /// <summary>
            /// The number of valid entries in `data`.
            /// </summary>
            public RclNative.size_t size;

            /// <summary>
            /// The total allocated capacity of the data array.
            /// </summary>
            public RclNative.size_t capacity;

            /// <summary>
            /// The allocator used to allocate the data array.
            /// </summary>
            public RclNative.rcutils_allocator_t* allocator;
        }

        /// <summary>
        /// Structure to hold a sequence of message infos.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_message_info_sequence_t
        {
            /// <summary>
            /// Array of message info.
            /// </summary>
            public RclNative.rmw_message_info_t* data;

            /// <summary>
            /// The number of valid entries in data.
            /// </summary>
            public RclNative.size_t size;

            /// <summary>
            /// The total allocated capacity of the data array.
            /// </summary>
            public RclNative.size_t capacity;

            /// <summary>
            /// The allocator used to allocate the data array.
            /// </summary>
            public RclNative.rcutils_allocator_t* allocator;
        }

        /// <summary>
        /// Internal rcl implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_subscription_impl_t : IEquatable<rcl_subscription_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_subscription_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_subscription_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_subscription_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_subscription_impl_t left, rcl_subscription_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_subscription_impl_t left, rcl_subscription_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_subscription_t
        {
            /// <summary>
            /// Pointer to the subscription implementation
            /// </summary>
            public RclNative.rcl_subscription_impl_t impl;
        }

        /// <summary>
        /// Options available for a rcl subscription.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_subscription_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the subscription.
            /// </summary>
            public RclNative.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the subscription, used for incidental allocations.
            /// For default behavior (malloc/free), see: rcl_get_default_allocator()
            /// </summary>
            public RclNative.rcl_allocator_t allocator;

            /// <summary>
            /// rmw specific subscription options, e.g. the rmw implementation specific payload.
            /// </summary>
            public RclNative.rmw_subscription_options_t rmw_subscription_options;
        }

        /// <summary>
        /// Contains rosidl service type support data
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rosidl_service_type_support_t
        {
            /// <summary>
            /// String identifier for the type_support.
            /// </summary>
            public byte* typesupport_identifier;

            /// <summary>
            /// Pointer to the service type support library
            /// </summary>
            public void* data;

            /// <summary>
            /// Pointer to the service type support handler function
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclNative.rosidl_service_type_support_t*, byte*, RclNative.rosidl_service_type_support_t*> func;
        }

        /// <summary>
        /// Internal rcl client implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_client_impl_t : IEquatable<rcl_client_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_client_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_client_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_client_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_client_impl_t left, rcl_client_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_client_impl_t left, rcl_client_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Client.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_client_t
        {
            /// <summary>
            /// Pointer to the client implementation
            /// </summary>
            public RclNative.rcl_client_impl_t impl;
        }

        /// <summary>
        /// Options available for a rcl_client_t.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_client_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the client.
            /// </summary>
            public RclNative.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the client, used for incidental allocations.
            /// For default behavior (malloc/free), use: rcl_get_default_allocator()
            /// </summary>
            public RclNative.rcl_allocator_t allocator;
        }

        /// <summary>
        /// Options available for a rcl guard condition.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_guard_condition_options_t
        {
            /// <summary>
            /// Custom allocator for the guard condition, used for internal allocations.
            /// </summary>
            public RclNative.rcl_allocator_t allocator;
        }

        /// <summary>
        /// Internal rcl implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_service_impl_t : IEquatable<rcl_service_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_service_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_service_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_service_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_service_impl_t left, rcl_service_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_service_impl_t left, rcl_service_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Service.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_service_t
        {
            /// <summary>
            /// Pointer to the service implementation
            /// </summary>
            public RclNative.rcl_service_impl_t impl;
        }

        /// <summary>
        /// Options available for a rcl service.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_service_options_t
        {
            /// <summary>
            /// Middleware quality of service settings for the service.
            /// </summary>
            public RclNative.rmw_qos_profile_t qos;

            /// <summary>
            /// Custom allocator for the service, used for incidental allocations.
            /// For default behavior (malloc/free), see: rcl_get_default_allocator()
            /// </summary>
            public RclNative.rcl_allocator_t allocator;
        }

        /// <summary>
        /// A duration of time, measured in nanoseconds and its source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_duration_t
        {
            /// <summary>
            /// Duration in nanoseconds and its source.
            /// </summary>
            public RclNative.rcl_duration_value_t nanoseconds;
        }

        /// <summary>
        /// A duration of time, measured in nanoseconds.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_duration_value_t : IEquatable<rcutils_duration_value_t>
        {
            public rcutils_duration_value_t(long value) => this.Value = value;

            public readonly long Value;

            public bool Equals(rcutils_duration_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcutils_duration_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator long(rcutils_duration_value_t from) => from.Value;

            public static implicit operator rcutils_duration_value_t(long from) => new rcutils_duration_value_t(from);

            public static bool operator ==(rcutils_duration_value_t left, rcutils_duration_value_t right) => left.Equals(right);

            public static bool operator !=(rcutils_duration_value_t left, rcutils_duration_value_t right) => !left.Equals(right);
        }

        /// <summary>
        /// A duration of time, measured in nanoseconds.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_duration_value_t : IEquatable<rcl_duration_value_t>
        {
            public rcl_duration_value_t(RclNative.rcutils_duration_value_t value) => this.Value = value;

            public readonly RclNative.rcutils_duration_value_t Value;

            public bool Equals(rcl_duration_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_duration_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcutils_duration_value_t(rcl_duration_value_t from) => from.Value;

            public static implicit operator rcl_duration_value_t(RclNative.rcutils_duration_value_t from) => new rcl_duration_value_t(from);

            public static bool operator ==(rcl_duration_value_t left, rcl_duration_value_t right) => left.Equals(right);

            public static bool operator !=(rcl_duration_value_t left, rcl_duration_value_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Struct to describe a jump in time.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_time_jump_t
        {
            /// <summary>
            /// Indicate whether or not the source of time changed.
            /// </summary>
            public RclNative.rcl_clock_change_t clock_change;

            /// <summary>
            /// The new time minus the last time before the jump.
            /// </summary>
            public RclNative.rcl_duration_t delta;
        }

        /// <summary>
        /// Describe the prerequisites for calling a time jump callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_jump_threshold_t
        {
            /// <summary>
            /// True to call callback when the clock type changes.
            /// </summary>
            public bool on_clock_change;

            /// <summary>
            /// A positive duration indicating the minimum jump forwards to be considered exceeded, or zero
            /// to disable.
            /// </summary>
            public RclNative.rcl_duration_t min_forward;

            /// <summary>
            /// A negative duration indicating the minimum jump backwards to be considered exceeded, or zero
            /// to disable.
            /// </summary>
            public RclNative.rcl_duration_t min_backward;
        }

        /// <summary>
        /// Struct to describe an added callback.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_jump_callback_info_t
        {
            /// <summary>
            /// Callback to fucntion.
            /// </summary>
            public delegate* unmanaged[Cdecl]<RclNative.rcl_time_jump_t*, bool, void*, void> callback;

            /// <summary>
            /// Threshold to decide when to call the callback.
            /// </summary>
            public RclNative.rcl_jump_threshold_t threshold;

            /// <summary>
            /// Pointer passed to the callback.
            /// </summary>
            public void* user_data;
        }

        /// <summary>
        /// Encapsulation of a time source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_clock_t
        {
            /// <summary>
            /// Clock type
            /// </summary>
            public RclNative.rcl_clock_type_t type;

            /// <summary>
            /// An array of added jump callbacks.
            /// </summary>
            public RclNative.rcl_jump_callback_info_t* jump_callbacks;

            /// <summary>
            /// Number of callbacks in jump_callbacks.
            /// </summary>
            public RclNative.size_t num_jump_callbacks;

            /// <summary>
            /// Pointer to get_now function
            /// </summary>
            public delegate* unmanaged[Cdecl]<void*, RclNative.rcl_time_point_value_t*, RclNative.rcl_ret_t> get_now;

            /// <summary>
            /// void (*set_now) (rcl_time_point_value_t);
            /// Clock storage
            /// </summary>
            public void* data;

            /// <summary>
            /// Custom allocator used for internal allocations.
            /// </summary>
            public RclNative.rcl_allocator_t allocator;
        }

        /// <summary>
        /// Return code for rmw functions
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_ret_t : IEquatable<rmw_ret_t>
        {
            public rmw_ret_t(int value) => this.Value = value;

            public readonly int Value;

            public bool Equals(rmw_ret_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rmw_ret_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator int(rmw_ret_t from) => from.Value;

            public static implicit operator rmw_ret_t(int from) => new rmw_ret_t(from);

            public static bool operator ==(rmw_ret_t left, rmw_ret_t right) => left.Equals(right);

            public static bool operator !=(rmw_ret_t left, rmw_ret_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_ret_t : IEquatable<rcl_ret_t>
        {
            public rcl_ret_t(RclNative.rmw_ret_t value) => this.Value = value;

            public readonly RclNative.rmw_ret_t Value;

            public bool Equals(rcl_ret_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_ret_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rmw_ret_t(rcl_ret_t from) => from.Value;

            public static implicit operator rcl_ret_t(RclNative.rmw_ret_t from) => new rcl_ret_t(from);

            public static bool operator ==(rcl_ret_t left, rcl_ret_t right) => left.Equals(right);

            public static bool operator !=(rcl_ret_t left, rcl_ret_t right) => !left.Equals(right);
        }

        /// <summary>
        /// A single point in time, measured in nanoseconds since the Unix epoch.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_time_point_value_t : IEquatable<rcl_time_point_value_t>
        {
            public rcl_time_point_value_t(RclNative.rcutils_time_point_value_t value) => this.Value = value;

            public readonly RclNative.rcutils_time_point_value_t Value;

            public bool Equals(rcl_time_point_value_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_time_point_value_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcutils_time_point_value_t(rcl_time_point_value_t from) => from.Value;

            public static implicit operator rcl_time_point_value_t(RclNative.rcutils_time_point_value_t from) => new rcl_time_point_value_t(from);

            public static bool operator ==(rcl_time_point_value_t left, rcl_time_point_value_t right) => left.Equals(right);

            public static bool operator !=(rcl_time_point_value_t left, rcl_time_point_value_t right) => !left.Equals(right);
        }

        /// <summary>
        /// A single point in time, measured in nanoseconds, the reference point is based on the source.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_time_point_t
        {
            /// <summary>
            /// Nanoseconds of the point in time
            /// </summary>
            public RclNative.rcl_time_point_value_t nanoseconds;

            /// <summary>
            /// Clock type of the point in time
            /// </summary>
            public RclNative.rcl_clock_type_t clock_type;
        }

        [StructLayout(LayoutKind.Sequential)]
        public partial struct rosidl_runtime_c__Sequence__bound
        {
            /// <summary>
            /// String identifier for the type_support.
            /// </summary>
            public byte* typesupport_identifier;

            /// <summary>
            /// Pointer to type support handle function
            /// </summary>
            public void* data;

            public delegate* unmanaged[Cdecl]<RclNative.rosidl_runtime_c__Sequence__bound*, byte*, RclNative.rosidl_runtime_c__Sequence__bound*> func;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_timer_impl_t : IEquatable<rcl_timer_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_timer_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_timer_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_timer_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_timer_impl_t left, rcl_timer_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_timer_impl_t left, rcl_timer_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS Timer.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_timer_t
        {
            /// <summary>
            /// Private implementation pointer.
            /// </summary>
            public RclNative.rcl_timer_impl_t impl;
        }

        /// <summary>
        /// rmw struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_event_t : IEquatable<rmw_event_t>
        {
            private readonly IntPtr _handle;

            public rmw_event_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rmw_event_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rmw_event_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rmw_event_t left, rmw_event_t right) => left.Equals(right);

            public static bool operator !=(rmw_event_t left, rmw_event_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Internal rcl implementation struct.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_event_impl_t : IEquatable<rcl_event_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_event_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_event_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_event_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_event_impl_t left, rcl_event_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_event_impl_t left, rcl_event_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Structure which encapsulates a ROS QoS event handle.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_event_t
        {
            /// <summary>
            /// Pointer to the event implementation
            /// </summary>
            public RclNative.rcl_event_impl_t impl;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_wait_set_impl_t : IEquatable<rcl_wait_set_impl_t>
        {
            private readonly IntPtr _handle;

            public rcl_wait_set_impl_t(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(rcl_wait_set_impl_t other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is rcl_wait_set_impl_t other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(rcl_wait_set_impl_t left, rcl_wait_set_impl_t right) => left.Equals(right);

            public static bool operator !=(rcl_wait_set_impl_t left, rcl_wait_set_impl_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Container for subscription's, guard condition's, etc to be waited on.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rcl_wait_set_t
        {
            /// <summary>
            /// Storage for subscription pointers.
            /// </summary>
            public RclNative.rcl_subscription_t** subscriptions;

            /// <summary>
            /// Number of subscriptions
            /// </summary>
            public RclNative.size_t size_of_subscriptions;

            /// <summary>
            /// Storage for guard condition pointers.
            /// </summary>
            public RclNative.rcl_guard_condition_t** guard_conditions;

            /// <summary>
            /// Number of guard_conditions
            /// </summary>
            public RclNative.size_t size_of_guard_conditions;

            /// <summary>
            /// Storage for timer pointers.
            /// </summary>
            public RclNative.rcl_timer_t** timers;

            /// <summary>
            /// Number of timers
            /// </summary>
            public RclNative.size_t size_of_timers;

            /// <summary>
            /// Storage for client pointers.
            /// </summary>
            public RclNative.rcl_client_t** clients;

            /// <summary>
            /// Number of clients
            /// </summary>
            public RclNative.size_t size_of_clients;

            /// <summary>
            /// Storage for service pointers.
            /// </summary>
            public RclNative.rcl_service_t** services;

            /// <summary>
            /// Number of services
            /// </summary>
            public RclNative.size_t size_of_services;

            /// <summary>
            /// Storage for event pointers.
            /// </summary>
            public RclNative.rcl_event_t** events;

            /// <summary>
            /// Number of events
            /// </summary>
            public RclNative.size_t size_of_events;

            /// <summary>
            /// Implementation specific storage.
            /// </summary>
            public RclNative.rcl_wait_set_impl_t impl;
        }

        /// <summary>
        /// Associative array of topic or service names and types.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_names_and_types_t
        {
            /// <summary>
            /// Array of names
            /// </summary>
            public RclNative.rcutils_string_array_t names;

            /// <summary>
            /// Dynamic array of arrays of type names, with the same length as `names`
            /// </summary>
            public RclNative.rcutils_string_array_t* types;
        }

        /// <summary>
        /// A data structure that encapsulates the node name, node namespace,
        /// topic_type, gid, and qos_profile of publishers and subscriptions
        /// for a topic.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_topic_endpoint_info_t
        {
            /// <summary>
            /// Name of the node
            /// </summary>
            public byte* node_name;

            /// <summary>
            /// Namespace of the node
            /// </summary>
            public byte* node_namespace;

            /// <summary>
            /// The associated topic type
            /// </summary>
            public byte* topic_type;

            /// <summary>
            /// The endpoint type
            /// </summary>
            public RclNative.rmw_endpoint_type_t endpoint_type;

            /// <summary>
            /// The GID of the endpoint
            /// </summary>
            public fixed byte endpoint_gid[24];

            /// <summary>
            /// QoS profile of the endpoint
            /// </summary>
            public RclNative.rmw_qos_profile_t qos_profile;
        }

        /// <summary>
        /// Array of topic endpoint information
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public partial struct rmw_topic_endpoint_info_array_t
        {
            /// <summary>
            /// Size of the array.
            /// </summary>
            public RclNative.size_t size;

            /// <summary>
            /// Contiguous storage for topic endpoint information elements.
            /// </summary>
            public RclNative.rmw_topic_endpoint_info_t* info_array;
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcutils_ret_t : IEquatable<rcutils_ret_t>
        {
            public rcutils_ret_t(int value) => this.Value = value;

            public readonly int Value;

            public bool Equals(rcutils_ret_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcutils_ret_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator int(rcutils_ret_t from) => from.Value;

            public static implicit operator rcutils_ret_t(int from) => new rcutils_ret_t(from);

            public static bool operator ==(rcutils_ret_t left, rcutils_ret_t right) => left.Equals(right);

            public static bool operator !=(rcutils_ret_t left, rcutils_ret_t right) => !left.Equals(right);
        }

        /// <summary>
        /// For now this is a simple aliasing from a serialized message to a uint8 array.
        /// However, in future developments this serialized message can become something
        /// more complex and is therefore aliased.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rmw_serialized_message_t : IEquatable<rmw_serialized_message_t>
        {
            public rmw_serialized_message_t(RclNative.rcutils_uint8_array_t value) => this.Value = value;

            public readonly RclNative.rcutils_uint8_array_t Value;

            public bool Equals(rmw_serialized_message_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rmw_serialized_message_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcutils_uint8_array_t(rmw_serialized_message_t from) => from.Value;

            public static implicit operator rmw_serialized_message_t(RclNative.rcutils_uint8_array_t from) => new rmw_serialized_message_t(from);

            public static bool operator ==(rmw_serialized_message_t left, rmw_serialized_message_t right) => left.Equals(right);

            public static bool operator !=(rmw_serialized_message_t left, rmw_serialized_message_t right) => !left.Equals(right);
        }

        /// <summary>
        /// typedef for rmw_serialized_message_t;
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_serialized_message_t : IEquatable<rcl_serialized_message_t>
        {
            public rcl_serialized_message_t(RclNative.rmw_serialized_message_t value) => this.Value = value;

            public readonly RclNative.rmw_serialized_message_t Value;

            public bool Equals(rcl_serialized_message_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_serialized_message_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rmw_serialized_message_t(rcl_serialized_message_t from) => from.Value;

            public static implicit operator rcl_serialized_message_t(RclNative.rmw_serialized_message_t from) => new rcl_serialized_message_t(from);

            public static bool operator ==(rcl_serialized_message_t left, rcl_serialized_message_t right) => left.Equals(right);

            public static bool operator !=(rcl_serialized_message_t left, rcl_serialized_message_t right) => !left.Equals(right);
        }

        /// <summary>
        /// stores all the parameters of all nodes of a process
        /// </summary>
        /// <remarks>
        ///  rcl_params_t
        /// </remarks>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_params_t : IEquatable<rcl_params_t>
        {
            public rcl_params_t(RclNative.rcl_params_s value) => this.Value = value;

            public readonly RclNative.rcl_params_s Value;

            public bool Equals(rcl_params_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_params_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rcl_params_s(rcl_params_t from) => from.Value;

            public static implicit operator rcl_params_t(RclNative.rcl_params_s from) => new rcl_params_t(from);

            public static bool operator ==(rcl_params_t left, rcl_params_t right) => left.Equals(right);

            public static bool operator !=(rcl_params_t left, rcl_params_t right) => !left.Equals(right);
        }

        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_context_instance_id_t : IEquatable<rcl_context_instance_id_t>
        {
            public rcl_context_instance_id_t(ulong value) => this.Value = value;

            public readonly ulong Value;

            public bool Equals(rcl_context_instance_id_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_context_instance_id_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator ulong(rcl_context_instance_id_t from) => from.Value;

            public static implicit operator rcl_context_instance_id_t(ulong from) => new rcl_context_instance_id_t(from);

            public static bool operator ==(rcl_context_instance_id_t left, rcl_context_instance_id_t right) => left.Equals(right);

            public static bool operator !=(rcl_context_instance_id_t left, rcl_context_instance_id_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Associative array of topic or service names and types.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_names_and_types_t : IEquatable<rcl_names_and_types_t>
        {
            public rcl_names_and_types_t(RclNative.rmw_names_and_types_t value) => this.Value = value;

            public readonly RclNative.rmw_names_and_types_t Value;

            public bool Equals(rcl_names_and_types_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_names_and_types_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rmw_names_and_types_t(rcl_names_and_types_t from) => from.Value;

            public static implicit operator rcl_names_and_types_t(RclNative.rmw_names_and_types_t from) => new rcl_names_and_types_t(from);

            public static bool operator ==(rcl_names_and_types_t left, rcl_names_and_types_t right) => left.Equals(right);

            public static bool operator !=(rcl_names_and_types_t left, rcl_names_and_types_t right) => !left.Equals(right);
        }

        /// <summary>
        /// A data structure that encapsulates the node name, node namespace,
        /// topic_type, gid, and qos_profile of publishers and subscriptions
        /// for a topic.
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_topic_endpoint_info_t : IEquatable<rcl_topic_endpoint_info_t>
        {
            public rcl_topic_endpoint_info_t(RclNative.rmw_topic_endpoint_info_t value) => this.Value = value;

            public readonly RclNative.rmw_topic_endpoint_info_t Value;

            public bool Equals(rcl_topic_endpoint_info_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_topic_endpoint_info_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rmw_topic_endpoint_info_t(rcl_topic_endpoint_info_t from) => from.Value;

            public static implicit operator rcl_topic_endpoint_info_t(RclNative.rmw_topic_endpoint_info_t from) => new rcl_topic_endpoint_info_t(from);

            public static bool operator ==(rcl_topic_endpoint_info_t left, rcl_topic_endpoint_info_t right) => left.Equals(right);

            public static bool operator !=(rcl_topic_endpoint_info_t left, rcl_topic_endpoint_info_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Array of topic endpoint information
        /// </summary>
        [StructLayout(LayoutKind.Sequential)]
        public readonly partial struct rcl_topic_endpoint_info_array_t : IEquatable<rcl_topic_endpoint_info_array_t>
        {
            public rcl_topic_endpoint_info_array_t(RclNative.rmw_topic_endpoint_info_array_t value) => this.Value = value;

            public readonly RclNative.rmw_topic_endpoint_info_array_t Value;

            public bool Equals(rcl_topic_endpoint_info_array_t other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is rcl_topic_endpoint_info_array_t other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator RclNative.rmw_topic_endpoint_info_array_t(rcl_topic_endpoint_info_array_t from) => from.Value;

            public static implicit operator rcl_topic_endpoint_info_array_t(RclNative.rmw_topic_endpoint_info_array_t from) => new rcl_topic_endpoint_info_array_t(from);

            public static bool operator ==(rcl_topic_endpoint_info_array_t left, rcl_topic_endpoint_info_array_t right) => left.Equals(right);

            public static bool operator !=(rcl_topic_endpoint_info_array_t left, rcl_topic_endpoint_info_array_t right) => !left.Equals(right);
        }

        /// <summary>
        /// Return a zero initialized allocator.
        /// </summary>
        /// <remarks>
        /// Note that this is an invalid allocator and should only be used as a placeholder.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_allocator_t rcutils_get_zero_initialized_allocator();

        /// <summary>
        /// Return a properly initialized rcutils_allocator_t with default values.
        /// </summary>
        /// <remarks>
        /// This defaults to:- allocate = wraps malloc()
        /// - deallocate = wraps free()
        /// - reallocate = wraps realloc()
        /// - zero_allocate = wraps calloc()
        /// - state = `NULL`&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_allocator_t rcutils_get_default_allocator();

        /// <summary>
        /// Return true if the given allocator has non-null function pointers.
        /// </summary>
        /// <param name="allocator">to be checked by the function</param>
        /// <remarks>
        /// Will also return false if the allocator pointer is null.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_allocator_is_valid(RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Emulate the behavior of [reallocf](https://linux.die.net/man/3/reallocf).
        /// </summary>
        /// <param name="pointer">to the memory which will be reallocated</param>
        /// <param name="size">in bytes</param>
        /// <param name="allocator">to be used to allocate and deallocate memory</param>
        /// <remarks>
        /// This function will return `NULL` if the allocator is `NULL` or has `NULL` for
        /// function pointer fields.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern void* rcutils_reallocf(void* pointer, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Get zero initialized security options.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_security_options_t rmw_get_zero_initialized_security_options();

        /// <summary>
        /// Get default initialized security options.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_security_options_t rmw_get_default_security_options();

        /// <summary>
        /// Copy the given security options.
        /// </summary>
        /// <param name="src">security options to be copied.</param>
        /// <param name="allocator">allocator used when copying data to the new security options.</param>
        /// <param name="dst">security options to be set.</param>
        /// <returns>RMW_RET_BAD_ALLOC, or</returns>
        /// <returns>RMW_RET_OK</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_security_options_copy(RclNative.rmw_security_options_t* src, RclNative.rcutils_allocator_t* allocator, RclNative.rmw_security_options_t* dst);

        /// <summary>
        /// Set the security root path for the given security options.
        /// </summary>
        /// <param name="security_root_path">path to be set.</param>
        /// <param name="allocator">allocator used to allocate the new path.</param>
        /// <param name="security_options">security options to be set.</param>
        /// <returns>RMW_RET_BAD_ALLOC, or</returns>
        /// <returns>RMW_RET_OK</returns>
        /// <remarks>
        /// The provided `security_root_path` will be copied into allocated memory.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_security_options_set_root_path(byte* security_root_path, RclNative.rcutils_allocator_t* allocator, RclNative.rmw_security_options_t* security_options);

        /// <summary>
        /// Finalize the given security_options.
        /// </summary>
        /// <param name="security_options">security options to be finalized.</param>
        /// <param name="allocator">allocator used to deallocate the root path.</param>
        /// <returns>RMW_RET_ERROR, or</returns>
        /// <returns>RMW_RET_OK</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_security_options_fini(RclNative.rmw_security_options_t* security_options, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Return a zero initialized init options structure.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_init_options_t rmw_get_zero_initialized_init_options();

        /// <summary>
        /// Initialize given init options with the default values and implementation specific values.
        /// </summary>
        /// <param name="init_options">object to be setup</param>
        /// <param name="allocator">to be used during setup and during initialization</param>
        /// <returns>`RMW_RET_OK` if setup is successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Giving an already initialized init options will result
        /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.The given allocator is used, if required, during setup of the init options,
        /// but is also used during initialization.In either case the given allocator is stored in the returned init options.The `impl` pointer should not be changed manually.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | YesThis should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The given init options must be zero initialized.
        /// </pre>
        /// <post>
        /// If initialization fails, init options will remain zero initialized.
        /// </post>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init_options_init(RclNative.rmw_init_options_t* init_options, RclNative.rcutils_allocator_t allocator);

        /// <summary>
        /// Copy the given source init options to the destination init options.
        /// </summary>
        /// <param name="src">rcl_init_options_t object to be copied from</param>
        /// <param name="dst">rcl_init_options_t object to be copied into</param>
        /// <returns>`RMW_RET_OK` if the copy is successful, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier for src does not match the implementation of this function, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Giving an zero initialized init options as a source will result
        /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.Giving an already initialized init options for the destination will result
        /// in a failure with return code `RMW_RET_INVALID_ARGUMENT`.The allocator from the source is used for any allocations and stored in the
        /// destination.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | YesThis should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The source init options must have been initialized
        /// i.e. had `rmw_init_options_init()` called on.
        /// </pre>
        /// <pre>
        /// The destination init options must be zero initialized.
        /// </pre>
        /// <post>
        /// If copy fails, destination init options will remain zero initialized.
        /// </post>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init_options_copy(RclNative.rmw_init_options_t* src, RclNative.rmw_init_options_t* dst);

        /// <summary>
        /// Finalize the given init options.
        /// </summary>
        /// <param name="init_options">object to finalized</param>
        /// <returns>`RMW_RET_OK` if finalization is successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier does not match the implementation of this function, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// If init options are zero initialized,
        /// then `RMW_RET_INVALID_ARGUMENT` is returned.This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given init options
        /// unchanged.
        /// Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
        /// initializing the given init options.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | YesThis should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The given init options must have been initialized
        /// i.e. had `rmw_init_options_init()` called on.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init_options_fini(RclNative.rmw_init_options_t* init_options);

        /// <summary>
        /// Return a zero initialized context structure.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_context_t rmw_get_zero_initialized_context();

        /// <summary>
        /// Initialize the middleware with the given options, and yielding an context.
        /// </summary>
        /// <param name="options">initialization options to be used during initialization</param>
        /// <param name="context">resulting context struct</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// If options are zero-initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
        /// If options are initialized but no enclave is provided, then `RMW_RET_INVALID_ARGUMENT`
        /// is returned.
        /// If context has been already initialized (`rmw_init()` was called on it), then
        /// `RMW_RET_INVALID_ARGUMENT` is returned.Context is filled with middleware specific data upon success of this function.
        /// The context is used when initializing some entities like nodes and
        /// guard conditions, and is also required to properly call `rmw_shutdown()`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesThis should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The given options must have been initialized
        /// i.e. `rmw_init_options_init()` called on it and
        /// an enclave set.
        /// </pre>
        /// <pre>
        /// The given context must be zero initialized.
        /// </pre>
        /// <post>
        /// If initialization fails, context will remain zero initialized.
        /// </post>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init(RclNative.rmw_init_options_t* options, RclNative.rmw_context_t* context);

        /// <summary>
        /// Shutdown the middleware for a given context.
        /// </summary>
        /// <param name="context">resulting context struct</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any argument are invalid, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
        /// If context has been already invalidated (`rmw_shutdown()` was called on it), then
        /// this function is a no-op and `RMW_RET_OK` is returned.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesThis should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The given context must be a valid context which has been initialized with `rmw_init()`.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_shutdown(RclNative.rmw_context_t* context);

        /// <summary>
        /// Finalize a context.
        /// </summary>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// If context is zero initialized, then `RMW_RET_INVALID_ARGUMENT` is returned.
        /// If context is initialized and valid (`rmw_shutdown()` was not called on it), then
        /// `RMW_RET_INVALID_ARGUMENT` is returned.This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given context unchanged.
        /// Otherwise, it will proceed despite errors, freeing as much resources as it can and zero
        /// initializing the given context.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;This should be defined by the rmw implementation.
        /// </remarks>
        /// <pre>
        /// The context to be finalized must have been previously initialized with
        /// `rmw_init()`, and then later invalidated with `rmw_shutdown()`.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_context_fini(RclNative.rmw_context_t* context);

        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_fault_injection_is_test_complete();

        /// <summary>
        /// Atomically set the fault injection counter.
        /// </summary>
        /// <param name="count">The count to set the fault injection counter to. If count is negative, then fault
        /// injection errors will be disabled. The counter is globally initialized to
        /// RCUTILS_FAULT_INJECTION_NEVER_FAIL.</param>
        /// <remarks>
        /// This is typically not the preferred method of interacting directly with the fault injection
        /// logic, instead use `RCUTILS_FAULT_INJECTION_TEST` instead.This function may also be used for pausing code inside of a `RCUTILS_FAULT_INJECTION_TEST` with
        /// something like the following:RCUTILS_FAULT_INJECTION_TEST({
        /// ...  // code to run with fault injection
        /// int64_t count = rcutils_fault_injection_get_count();
        /// rcutils_fault_injection_set_count(RCUTILS_FAULT_INJECTION_NEVER_FAIL);
        /// ...  // code to run without fault injection
        /// rcutils_fault_injection_set_count(count);
        /// ...  // code to run with fault injection
        /// });
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern void rcutils_fault_injection_set_count(long count);

        /// <summary>
        /// Atomically get the fault injection counter value
        /// </summary>
        /// <remarks>
        /// This function is typically not used directly but instead indirectly inside an
        /// `RCUTILS_FAULT_INJECTION_TEST`
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern long rcutils_fault_injection_get_count();

        /// <summary>
        /// Implementation of fault injection decrementer
        /// </summary>
        /// <remarks>
        /// This is included inside of macros, so it needs to be exported as a public function, but it
        /// should not be used directly.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern long _rcutils_fault_injection_maybe_fail();

        /// <summary>
        /// Forces initialization of thread-local storage if called in a newly created thread.
        /// </summary>
        /// <param name="allocator">to be used to allocate and deallocate memory</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if the allocator is invalid, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// If this function is not called beforehand, then the first time the error
        /// state is set or the first time the error message is retrieved, the default
        /// allocator will be used to allocate thread-local storage.This function may or may not allocate memory.
        /// The system's thread-local storage implementation may need to allocate
        /// memory, since it usually has no way of knowing how much storage is needed
        /// without knowing how many threads will be created.
        /// Most implementations (e.g. C11, C++11, and pthread) do not have ways to
        /// specify how this memory is allocated, but if the implementation allows, the
        /// given allocator to this function will be used, but is otherwise unused.
        /// This only occurs when creating and destroying threads, which can be avoided
        /// in the "steady" state by reusing pools of threads.It is worth considering that repeated thread creation and destruction will
        /// result in repeated memory allocations and could result in memory
        /// fragmentation.
        /// This is typically avoided anyways by using pools of threads.In case an error is indicated by the return code, no error message will have
        /// been set.If called more than once in a thread, or after implicitly initialized by
        /// setting the error state, it will still return `RCUTILS_RET_OK`, even
        /// if the given allocator is invalid.
        /// Essentially this function does nothing if thread-local storage has already
        /// been called.
        /// If already initialized, the given allocator is ignored, even if it does not
        /// match the allocator used originally to initialize the thread-local storage.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_initialize_error_handling_thread_local_storage(RclNative.rcutils_allocator_t allocator);

        /// <summary>
        /// Set the error message, as well as the file and line on which it occurred.
        /// </summary>
        /// <param name="error_string">The error message to set.</param>
        /// <param name="file">The path to the file in which the error occurred.</param>
        /// <param name="line_number">The line number on which the error occurred.</param>
        /// <remarks>
        /// This is not meant to be used directly, but instead via the
        /// RCUTILS_SET_ERROR_MSG(msg) macro.The error_msg parameter is copied into the internal error storage and must
        /// be null terminated.
        /// The file parameter is copied into the internal error storage and must
        /// be null terminated.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern void rcutils_set_error_state(byte* error_string, byte* file, RclNative.size_t line_number);

        /// <summary>
        /// Return `true` if the error is set, otherwise `false`.
        /// </summary>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_error_is_set();

        /// <summary>
        /// Return an rcutils_error_state_t which was set with rcutils_set_error_state().
        /// </summary>
        /// <returns>A pointer to the current error state struct.</returns>
        /// <remarks>
        /// The returned pointer will be NULL if no error has been set in this thread.The returned pointer is valid until RCUTILS_SET_ERROR_MSG, rcutils_set_error_state,
        /// or rcutils_reset_error are called in the same thread.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_error_state_t* rcutils_get_error_state();

        /// <summary>
        /// Return the error message followed by `, at 
        /// &lt;file
        /// &gt;:
        /// &lt;line
        /// &gt;` if set, else "error not set".
        /// </summary>
        /// <returns>The current error string, with file and line number, or "error not set" if not set.</returns>
        /// <remarks>
        /// This function is "safe" because it returns a copy of the current error
        /// string or one containing the string "error not set" if no error was set.
        /// This ensures that the copy is owned by the calling thread and is therefore
        /// never invalidated by other error handling calls, and that the C string
        /// inside is always valid and null terminated.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_error_string_t rcutils_get_error_string();

        /// <summary>
        /// Reset the error state by clearing any previously set error state.
        /// </summary>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern void rcutils_reset_error();

        /// <summary>
        /// Return an empty array_list struct.
        /// </summary>
        /// <remarks>
        /// This function returns an empty and zero initialized array_list struct.
        /// Calling rcutils_array_list_fini() on any non-initialized instance leads
        /// to undefined behavior.
        /// Every instance of array_list_t has to either be zero_initialized with this
        /// function or manually allocated.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | YesExample:```c
        /// rcutils_array_list_t foo;
        /// rcutils_array_list_fini(
        /// &amp;foo
        /// ); // undefined behavior!rcutils_array_list_t bar = rcutils_get_zero_initialized_array_list();
        /// rcutils_array_list_fini(
        /// &amp;bar
        /// ); // ok
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_array_list_t rcutils_get_zero_initialized_array_list();

        /// <summary>
        /// Initialize an array list with a given initial capacity.
        /// </summary>
        /// <param name="array_list">object to be initialized</param>
        /// <param name="initial_capacity">the initial capacity to allocate in the list</param>
        /// <param name="data_size">the size (in bytes) of the data object being stored in the list</param>
        /// <param name="allocator">to be used to allocate and deallocate memory</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will initialize a given, zero initialized, array_list to
        /// a given size.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesExample:```c
        /// rcutils_allocator_t allocator = rcutils_get_default_allocator();
        /// rcutils_array_list_t array_list = rcutils_get_zero_initialized_array_list();
        /// rcutils_ret_t ret = rcutils_array_list_init(
        /// &amp;array
        /// _list, 2, sizeof(int), 
        /// &amp;allocator
        /// );
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... error handling
        /// }
        /// int data = 42;
        /// int out_data = 0;
        /// ret = rcutils_array_list_add(
        /// &amp;array
        /// _list, 
        /// &amp;data
        /// );
        /// data++;
        /// ret = rcutils_array_list_get(
        /// &amp;array
        /// _list, 0, 
        /// &amp;out
        /// _data);
        /// assert(42 == out_data);
        /// ret = rcutils_array_list_fini(
        /// &amp;array
        /// _list);
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_init(RclNative.rcutils_array_list_t* array_list, RclNative.size_t initial_capacity, RclNative.size_t data_size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize an array list, reclaiming all resources.
        /// </summary>
        /// <param name="array_list">object to be finalized</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function reclaims any memory owned by the array list.The allocator used to initialize the array list is used to deallocate each
        /// entry in the list and the list itself.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_fini(RclNative.rcutils_array_list_t* array_list);

        /// <summary>
        /// Adds an entry to the list
        /// </summary>
        /// <param name="array_list">to add the data to</param>
        /// <param name="data">a pointer to the data to add to the list</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function adds the provided data to the end of the list. A shallow copy of
        /// the provided data is made to store in the list instead of just storing
        /// the pointer to the provided data.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_add(RclNative.rcutils_array_list_t* array_list, void* data);

        /// <summary>
        /// Sets an entry in the list to the provided data
        /// </summary>
        /// <param name="array_list">to add the data to</param>
        /// <param name="index">the position in the list to set the data</param>
        /// <param name="data">a pointer to the data that will be set in the list</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function sets the provided data at the specified index in the list.
        /// A shallow copy of the provided data is made to store in the list instead
        /// of just storing the pointer to the provided data.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_set(RclNative.rcutils_array_list_t* array_list, RclNative.size_t index, void* data);

        /// <summary>
        /// Removes an entry in the list at the provided index
        /// </summary>
        /// <param name="array_list">to add the data to</param>
        /// <param name="index">the index of the item to remove from the list</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if index out of bounds, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function removes data from the list at the specified index. The capacity
        /// of the list will never decrease when entries are removed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_remove(RclNative.rcutils_array_list_t* array_list, RclNative.size_t index);

        /// <summary>
        /// Retrieves an entry in the list at the provided index
        /// </summary>
        /// <param name="array_list">to add the data to</param>
        /// <param name="index">the index at which to get the data</param>
        /// <param name="data">a copy of the data stored in the list</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function retrieves a copy of the data stored in the list at the provided index.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_get(RclNative.rcutils_array_list_t* array_list, RclNative.size_t index, void* data);

        /// <summary>
        /// Retrieves the size of the provided array_list
        /// </summary>
        /// <param name="array_list">list to get the size of</param>
        /// <param name="size">The number of items currently stored in the list</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function retrieves the number of items in the provided array list&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_array_list_get_size(RclNative.rcutils_array_list_t* array_list, RclNative.size_t* size);

        /// <summary>
        /// Return a zero initialized char array struct.
        /// </summary>
        /// <returns>rcutils_char_array_t a zero initialized char array struct</returns>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_char_array_t rcutils_get_zero_initialized_char_array();

        /// <summary>
        /// Initialize a zero initialized char array struct.
        /// </summary>
        /// <param name="char_array">a pointer to the to be initialized char array struct</param>
        /// <param name="buffer_capacity">the size of the memory to allocate for the byte stream</param>
        /// <param name="allocator">the allocator to use for the memory allocation</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or</returns>
        /// <returns>'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function may leak if the char array struct is already
        /// pre-initialized.
        /// If the capacity is set to 0, no memory is allocated and the internal buffer
        /// is still NULL.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_init(RclNative.rcutils_char_array_t* char_array, RclNative.size_t buffer_capacity, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize a char array struct.
        /// </summary>
        /// <param name="char_array">pointer to the rcutils_char_array_t to be cleaned up</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENTS` if the char_array argument is invalid</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// Cleans up and deallocates any resources owned by rcutils_char_array_t.
        /// The array passed to this function needs to have been initialized by
        /// rcutils_char_array_init().
        /// If .owns_buffer is false, this function has no effect because that
        /// implies that the char_array does not own the internal buffer.
        /// Passing an uninitialized instance to this function leads to undefined
        /// behavior.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_fini(RclNative.rcutils_char_array_t* char_array);

        /// <summary>
        /// Resize the internal buffer of the char array.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being resized</param>
        /// <param name="new_size">the new size of the internal buffer</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// The internal buffer of the char array can be resized dynamically if needed.
        /// If the new size is smaller than the current capacity, then the memory is
        /// truncated.
        /// Be aware, that this will deallocate the memory and therefore invalidates any
        /// pointers to this storage.
        /// If the new size is larger, new memory is getting allocated and the existing
        /// content is copied over.
        /// Note that if the array doesn't own the current buffer the function just
        /// allocates a new block of memory and copies the contents of the old buffer
        /// instead of resizing the existing buffer.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_resize(RclNative.rcutils_char_array_t* char_array, RclNative.size_t new_size);

        /// <summary>
        /// Expand the internal buffer of the char array.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being resized</param>
        /// <param name="new_size">the new size of the internal buffer</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function is equivalent to `rcutils_char_array_resize` except that it resizes
        /// the internal buffer only when it is not big enough.
        /// If the buffer is already big enough for `new_size`, it returns `RCUTILS_RET_OK` without
        /// doing anything.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_expand_as_needed(RclNative.rcutils_char_array_t* char_array, RclNative.size_t new_size);

        /// <summary>
        /// Append a string (or part of it) to the string in buffer.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being appended to</param>
        /// <param name="src">the string to be appended to the end of the string in buffer</param>
        /// <param name="n">it uses at most n bytes from the src string</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function treats the internal buffer as a string and appends the src string to it.
        /// If src is longer than n, n bytes will be used and an extra null byte will be appended.
        /// It is virtually equivalent to `strncat(char_array-&gt;buffer, src, n)` except that the buffer
        /// grows as needed so a user doesn't have to deal with memory management.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_strncat(RclNative.rcutils_char_array_t* char_array, byte* src, RclNative.size_t n);

        /// <summary>
        /// Append a string to the string in buffer.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being
        /// appended to</param>
        /// <param name="src">the string to be appended to the end of the string in buffer</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function treats the internal buffer as a string and appends the src string to it.
        /// It is virtually equivalent to `strcat(char_array-&gt;buffer, src)` except that the buffer
        /// grows as needed. That is to say, a user can safely use it without doing calculation or
        /// checks on the sizes of the src and buffer.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_strcat(RclNative.rcutils_char_array_t* char_array, byte* src);

        /// <summary>
        /// Copy memory to buffer.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being resized</param>
        /// <param name="src">the memory to be copied from</param>
        /// <param name="n">a total of n bytes will be copied</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function is equivalent to `memcpy(char_array-&gt;buffer, src, n)` except that the buffer
        /// grows as needed so a user doesn't have to worry about overflow.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_memcpy(RclNative.rcutils_char_array_t* char_array, byte* src, RclNative.size_t n);

        /// <summary>
        /// Copy a string to buffer.
        /// </summary>
        /// <param name="char_array">pointer to the instance of rcutils_char_array_t which is being
        /// copied to</param>
        /// <param name="src">the string to be copied from</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function is equivalent to `strcpy(char_array-&gt;buffer, src)` except that the buffer
        /// grows as needed so that `src` will fit without overflow.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_char_array_strcpy(RclNative.rcutils_char_array_t* char_array, byte* src);

        /// <summary>
        /// A hashing function for a null terminated c string.
        /// </summary>
        /// <remarks>
        /// A hashing function for a null terminated c string.
        /// Should be used when your key is just a pointer to a c-string
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.size_t rcutils_hash_map_string_hash_func(void* key_str);

        /// <summary>
        /// A comparison function for a null terminated c string.
        /// </summary>
        /// <remarks>
        /// A comparison function for a null terminated c string.
        /// Should be used when your key is just a pointer to a c-string
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcutils_hash_map_string_cmp_func(void* val1, void* val2);

        /// <summary>
        /// Return an empty hash_map struct.
        /// </summary>
        /// <remarks>
        /// This function returns an empty and zero initialized hash_map struct.
        /// All hash maps should be initialized with this or manually initialized
        /// before being used.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesExample:
        /// ```c
        /// // Do not do this:
        /// // rcutils_hash_map_t foo;
        /// // rcutils_hash_map_fini(
        /// &amp;foo
        /// ); // undefined behavior!// Do this instead:
        /// rcutils_hash_map_t bar = rcutils_get_zero_initialized_hash_map();
        /// rcutils_hash_map_fini(
        /// &amp;bar
        /// ); // ok
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_hash_map_t rcutils_get_zero_initialized_hash_map();

        /// <summary>
        /// Initialize a rcutils_hash_map_t, allocating space for given capacity.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be initialized</param>
        /// <param name="initial_capacity">the amount of initial capacity for the hash_map</param>
        /// <param name="key_size">the size (in bytes) of the key used to index the data</param>
        /// <param name="data_size">the size (in bytes) of the data being stored</param>
        /// <param name="key_hashing_func">a function that returns a hashed value for a key</param>
        /// <param name="key_cmp_func">a function used to compare keys</param>
        /// <param name="allocator">the allocator to use through out the lifetime of the hash_map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function initializes the rcutils_hash_map_t with a given initial
        /// capacity for entries.
        /// Note this does not allocate space for keys or values in the hash_map, just the
        /// arrays of pointers to the keys and values.
        /// rcutils_hash_map_set() should still be used when assigning values.The hash_map argument should point to allocated memory and should have
        /// been zero initialized with rcutils_get_zero_initialized_hash_map().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesExample:
        /// ```c
        /// rcutils_hash_map_t hash_map = rcutils_get_zero_initialized_hash_map();
        /// rcutils_ret_t ret =
        /// rcutils_hash_map_init(
        /// &amp;hash
        /// _map, 10, rcutils_get_default_allocator());
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... do error handling
        /// }
        /// // ... use the hash_map and when done:
        /// ret = rcutils_hash_map_fini(
        /// &amp;hash
        /// _map);
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... do error handling
        /// }
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_init(RclNative.rcutils_hash_map_t* hash_map, RclNative.size_t initial_capacity, RclNative.size_t key_size, RclNative.size_t data_size, delegate* unmanaged[Cdecl]<void*, RclNative.size_t> key_hashing_func, delegate* unmanaged[Cdecl]<void*, void*, int> key_cmp_func, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize the previously initialized hash_map struct.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be finalized</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will free any resources which were created when initializing
        /// or when calling rcutils_hash_map_set().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_fini(RclNative.rcutils_hash_map_t* hash_map);

        /// <summary>
        /// Get the current capacity of the hash_map.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be queried</param>
        /// <param name="capacity">capacity of the hash_map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will return the internal capacity of the hash_map, which is the
        /// number of buckets the hash_map uses to sort the keys.
        /// The capacity does not indicate how many key value pairs are stored in the
        /// hash_map, the rcutils_hash_map_get_size() function can provide that, nor the
        /// maximum number that can be stored without increasing the capacity.
        /// The capacity can be set initially with rcutils_hash_map_init().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_get_capacity(RclNative.rcutils_hash_map_t* hash_map, RclNative.size_t* capacity);

        /// <summary>
        /// Get the current size of the hash_map.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be queried</param>
        /// <param name="size">size of the hash_map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will return the internal size of the hash_map, which is the
        /// current number of key value pairs in the hash_map.
        /// The size is changed when calling rcutils_hash_map_set() or rcutils_hash_map_unset().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_get_size(RclNative.rcutils_hash_map_t* hash_map, RclNative.size_t* size);

        /// <summary>
        /// Set a key value pair in the hash_map, increasing capacity if necessary.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be updated</param>
        /// <param name="key">hash_map key</param>
        /// <param name="value">value for given hash_map key</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// If the key already exists in the map then the value is updated to the new value
        /// provided. If it does not already exist then a new entry is added for the new key
        /// and value. The capacity will be increased if needed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_set(RclNative.rcutils_hash_map_t* hash_map, void* key, void* value);

        /// <summary>
        /// Unset a key value pair in the hash_map.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be updated</param>
        /// <param name="key">hash_map key, must be null terminated c string</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_STRING_KEY_NOT_FOUND` if the key is not found in the map, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// Unsets the key value pair in the hash_map and frees any internal resources allocated
        /// for the entry. This function will never decrease the capacity when removing keys.
        /// If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_unset(RclNative.rcutils_hash_map_t* hash_map, void* key);

        /// <summary>
        /// Get whether or not a key exists.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be searched</param>
        /// <param name="key">hash_map key, must be null terminated c string</param>
        /// <returns>`true` if key is in the hash_map, or</returns>
        /// <returns>`false` if key is not in the hash_map, or</returns>
        /// <returns>`false` for invalid arguments, or</returns>
        /// <returns>`false` if the hash_map is invalid</returns>
        /// <remarks>
        /// Returns true if the provided key exists in the hash_map or false if it does not or
        /// if the hash_map or key are invalid.
        /// In all cases no error message is set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_hash_map_key_exists(RclNative.rcutils_hash_map_t* hash_map, void* key);

        /// <summary>
        /// Get value given a key.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be searched</param>
        /// <param name="key">hash_map key to look up the data for</param>
        /// <param name="data">A copy of the data stored in the map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_NOT_FOUND` if the key doesn't exist in the map, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function can be used to retrieve a shallow copy of the stored data. The data
        /// pointer must point to a section of memory large enough to copy the full size of
        /// the data being stored, which is specified when the hash_map in initialized.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_get(RclNative.rcutils_hash_map_t* hash_map, void* key, void* data);

        /// <summary>
        /// Get the next key in the hash_map, unless NULL is given, then get the first key.
        /// </summary>
        /// <param name="hash_map">rcutils_hash_map_t to be queried</param>
        /// <param name="previous_key">NULL to get the first key or the previous key to get the next for</param>
        /// <param name="key">A copy of the next key in the sequence</param>
        /// <param name="data">A copy of the next data in the sequence</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_NOT_INITIALIZED` if the hash_map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_NOT_FOUND` if the previous_key doesn't exist in the map, or</returns>
        /// <returns>`RCUTILS_RET_HASH_MAP_NO_MORE_ENTRIES` if there is no more data beyound the previous_key, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function allows you to iteratively get each key/value pair in the hash_map.If NULL is given for the previous_key, then the first key in the hash_map is returned.
        /// If that returned key is given as the previous_key for the next call to this function,
        /// then the next key in the hash_map is returned.
        /// If there are no more keys in the hash_map or if the given key is not in the hash_map,
        /// an error will be returned.The order of the keys in the hash_map is arbitrary and if the hash_map is modified
        /// between calls to this function the behavior is undefined.
        /// If the hash_map is modified then iteration should begin again by passing NULL to
        /// get the first key again.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | YesExample:
        /// ```c
        /// printf("entries in the hash_map:\n");
        /// int key = 0, data = 0;
        /// rcutils_ret_t status = rcutils_hash_map_get_next_key(
        /// &amp;hash
        /// _map, NULL, 
        /// &amp;key
        /// , 
        /// &amp;data
        /// );
        /// while (RCUTILS_RET_OK == status) {
        /// printf("%i: %i\n", key, data);
        /// status = rcutils_hash_map_get_next_key(
        /// &amp;hash
        /// _map, 
        /// &amp;key
        /// , 
        /// &amp;key
        /// , 
        /// &amp;data
        /// );
        /// }
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_hash_map_get_next_key_and_data(RclNative.rcutils_hash_map_t* hash_map, void* previous_key, void* key, void* data);

        /// <summary>
        /// Interface to qsort with rcutils-style argument validation.
        /// </summary>
        /// <param name="ptr">object whose elements should be sorted.</param>
        /// <param name="count">number of elements present in the object.</param>
        /// <param name="size">size of each element, in bytes.</param>
        /// <param name="comp">function used to compare two elements.</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs.</returns>
        /// <remarks>
        /// This function changes the order of the elements in the array so that they
        /// are in ascending order according to the given comparison function.This function is thread-safe.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_qsort(void* ptr, RclNative.size_t count, RclNative.size_t size, delegate* unmanaged[Cdecl]<void*, RclNative.size_t, RclNative.size_t, delegate* unmanaged[Cdecl]<void*, void*, int>, int> comp);

        /// <summary>
        /// Return an empty string array struct.
        /// </summary>
        /// <remarks>
        /// This function returns an empty and zero initialized string array struct.
        /// Calling rcutils_string_array_fini() on any non-initialized instance leads
        /// to undefined behavior.
        /// Every instance of string_array_t has to either be zero_initialized with this
        /// function or manually allocated.Example:```c
        /// rcutils_string_array_t foo;
        /// rcutils_string_array_fini(
        /// &amp;foo
        /// ); // undefined behavior!rcutils_string_array_t bar = rcutils_get_zero_initialized_string_array();
        /// rcutils_string_array_fini(
        /// &amp;bar
        /// ); // ok
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_string_array_t rcutils_get_zero_initialized_string_array();

        /// <summary>
        /// Initialize a string array with a given size.
        /// </summary>
        /// <param name="string_array">object to be initialized</param>
        /// <param name="size">the size the array should be</param>
        /// <param name="allocator">to be used to allocate and deallocate memory</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs
        /// ```</returns>
        /// <remarks>
        /// This function will initialize a given, zero initialized, string array to
        /// a given size.Note that putting a string into the array gives owenship to the array.Example:```c
        /// rcutils_allocator_t allocator = rcutils_get_default_allocator();
        /// rcutils_string_array_t string_array = rcutils_get_zero_initialized_string_array();
        /// rcutils_ret_t ret = rcutils_string_array_init(
        /// &amp;string
        /// _array, 2, 
        /// &amp;allocator
        /// );
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... error handling
        /// }
        /// string_array.data[0] = rcutils_strdup("Hello", 
        /// &amp;allocator
        /// );
        /// string_array.data[1] = rcutils_strdup("World", 
        /// &amp;allocator
        /// );
        /// ret = rcutils_string_array_fini(
        /// &amp;string
        /// _array);
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_array_init(RclNative.rcutils_string_array_t* string_array, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize a string array, reclaiming all resources.
        /// </summary>
        /// <param name="string_array">object to be finalized</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function reclaims any memory owned by the string array, including the
        /// strings it references.The allocator used to initialize the string array is used to deallocate each
        /// string in the array and the array of strings itself.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_array_fini(RclNative.rcutils_string_array_t* string_array);

        /// <summary>
        /// Compare two string arrays.
        /// </summary>
        /// <param name="lhs">The first string array.</param>
        /// <param name="rhs">The second string array.</param>
        /// <param name="res">Negative value if `lhs` appears before `rhs` in lexicographical order.
        /// Zero if `lhs` and `rhs` are equal.
        /// Positive value if `lhs` appears after `rhs in lexographical order.</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if any argument is `NULL`, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if `lhs-&gt;data` or `rhs-&gt;data` is `NULL`, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs.</returns>
        /// <remarks>
        /// The two string arrays are compared according to lexicographical order.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_array_cmp(RclNative.rcutils_string_array_t* lhs, RclNative.rcutils_string_array_t* rhs, int* res);

        /// <summary>
        /// Resize a string array, reclaiming removed resources.
        /// </summary>
        /// <param name="string_array">object to be resized.</param>
        /// <param name="new_size">the size the array should be changed to.</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs.</returns>
        /// <remarks>
        /// This function changes the size of an existing string array.
        /// If the new size is larger, new entries are added to the end of the array and
        /// are zero- initialized.
        /// If the new size is smaller, entries are removed from the end of the array
        /// and their resources reclaimed.
        /// </remarks>
        /// <par>
        /// Note:
        /// Resizing to 0 is not a substitute for calling ::rcutils_string_array_fini.
        /// </par>
        /// <par>
        /// Note:
        /// If this function fails, @p string_array remains unchanged and should still
        /// be reclaimed with ::rcutils_string_array_fini.
        /// </par>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_array_resize(RclNative.rcutils_string_array_t* string_array, RclNative.size_t new_size);

        /// <summary>
        /// Lexicographic comparer for pointers to string pointers.
        /// </summary>
        /// <param name="lhs">pointer to the first string pointer.</param>
        /// <param name="rhs">pointer to the second string pointer.</param>
        /// <returns>&lt;
        /// 0 if lhs is lexicographically lower, or</returns>
        /// <returns>0 if the strings are the same, or</returns>
        /// <returns>&gt;0 if lhs is lexicographically higher.</returns>
        /// <remarks>
        /// This functions compares pointers to string pointers lexicographically
        /// ascending.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcutils_string_array_sort_compare(void* lhs, void* rhs);

        /// <summary>
        /// Return an empty string map struct.
        /// </summary>
        /// <remarks>
        /// This function returns an empty and zero initialized string map struct.Example:```c
        /// // Do not do this:
        /// // rcutils_string_map_t foo;
        /// // rcutils_string_map_fini(
        /// &amp;foo
        /// ); // undefined behavior!// Do this instead:
        /// rcutils_string_map_t bar = rcutils_get_zero_initialized_string_map();
        /// rcutils_string_map_fini(
        /// &amp;bar
        /// ); // ok
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_string_map_t rcutils_get_zero_initialized_string_map();

        /// <summary>
        /// Initialize a rcutils_string_map_t, allocating space for given capacity.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be initialized</param>
        /// <param name="initial_capacity">the amount of initial capacity for the string map</param>
        /// <param name="allocator">the allocator to use through out the lifetime of the map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_ALREADY_INIT` if already initialized, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function initializes the rcutils_string_map_t with a given initial
        /// capacity for entries.
        /// Note this does not allocate space for keys or values in the map, just the
        /// arrays of pointers to the keys and values.
        /// rcutils_string_map_set() should still be used when assigning values.The string_map argument should point to allocated memory and should have
        /// been zero initialized with rcutils_get_zero_initialized_string_map().
        /// For example:```c
        /// rcutils_string_map_t string_map = rcutils_get_zero_initialized_string_map();
        /// rcutils_ret_t ret =
        /// rcutils_string_map_init(
        /// &amp;string
        /// _map, 10, rcutils_get_default_allocator());
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... do error handling
        /// }
        /// // ... use the string map and when done:
        /// ret = rcutils_string_map_fini(
        /// &amp;string
        /// _map);
        /// if (ret != RCUTILS_RET_OK) {
        /// // ... do error handling
        /// }
        /// ```
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_init(RclNative.rcutils_string_map_t* string_map, RclNative.size_t initial_capacity, RclNative.rcutils_allocator_t allocator);

        /// <summary>
        /// Finalize the previously initialized string map struct.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be finalized</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will free any resources which were created when initializing
        /// or when calling rcutils_string_map_set().
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_fini(RclNative.rcutils_string_map_t* string_map);

        /// <summary>
        /// Get the current capacity of the string map.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be queried</param>
        /// <param name="capacity">capacity of the string map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will return the internal capacity of the map, which is the
        /// maximum number of key value pairs the map could hold.
        /// The capacity can be set initially with rcutils_string_map_init() or
        /// with rcutils_string_map_reserve().
        /// The capacity does not indicate how many key value paris are stored in the
        /// map, the rcutils_string_map_get_size() function can provide that.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_get_capacity(RclNative.rcutils_string_map_t* string_map, RclNative.size_t* capacity);

        /// <summary>
        /// Get the current size of the string map.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be queried</param>
        /// <param name="size">size of the string map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will return the internal size of the map, which is the
        /// current number of key value pairs in the map.
        /// The size is changed when calling rcutils_string_map_set_no_resize(),
        /// rcutils_string_map_set(), or rcutils_string_map_unset().
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_get_size(RclNative.rcutils_string_map_t* string_map, RclNative.size_t* size);

        /// <summary>
        /// Reserve a given amount of capacity in the map.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to have space reserved in</param>
        /// <param name="capacity">requested size to reserve in the map</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// Increases the capacity of the map to at least the given size.If the current capacity is less than requested capacity then the capacity
        /// is increased using the allocator given during initialization of the map in
        /// rcutils_string_map_init().
        /// If the requested capacity is less than the current capacity, the capacity
        /// may be reduced, but no existing key value pairs will be truncated to do so.
        /// In effect, the capacity will be shrunk to fit the number of items in map or
        /// the requested capacity, which ever is larger.If recovering all resources is desired first call rcutils_string_map_clear()
        /// and then this function with a capacity of 0.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_reserve(RclNative.rcutils_string_map_t* string_map, RclNative.size_t capacity);

        /// <summary>
        /// Remove all key value pairs from the map.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be cleared</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// This function will remove all key value pairs from the map, and it will
        /// reclaim all resources allocated as a result of setting key value pairs.
        /// rcutils_string_map_fini() should still be called after this.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_clear(RclNative.rcutils_string_map_t* string_map);

        /// <summary>
        /// Set a key value pair in the map, increasing capacity if necessary.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be updated</param>
        /// <param name="key">map key, must be null terminated c string</param>
        /// <param name="value">value for given map key, must be null terminated c string</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// The capacity will be increased if needed using rcutils_string_map_reserve().
        /// Otherwise it is the same as rcutils_string_map_set_no_resize().
        /// </remarks>
        /// <seealso cref="rcutils_string_map_set_no_resize()"/>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_set(RclNative.rcutils_string_map_t* string_map, byte* key, byte* value);

        /// <summary>
        /// Set a key value pair in the map but only if the map has enough capacity.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be updated</param>
        /// <param name="key">map key, must be null terminated c string</param>
        /// <param name="value">value for given map key, must be null terminated c string</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_NOT_ENOUGH_SPACE` if map is full, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// If the map already contains the given key, the existing value will be
        /// replaced with the given value.
        /// If the map does not contain the given key, and the map has additional
        /// unused capacity, then it will store the given key and value in the map.
        /// If there is no unused capacity in the map, then RCUTILS_RET_NOT_ENOUGH_SPACE
        /// is returned.The given key and value c strings are copied into the map, and so storage is
        /// allocated for them in the map when this function is called if necessary.
        /// The storage allocated for this purpose is reclaimed either when
        /// rcutils_string_map_fini() is called on this map or when using this function
        /// or rcutils_string_map_unset().Any allocation that occurs in this functions uses the allocator of the map,
        /// which is given when the map is initialized in rcutils_string_map_init().
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_set_no_resize(RclNative.rcutils_string_map_t* string_map, byte* key, byte* value);

        /// <summary>
        /// Unset a key value pair in the map.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be updated</param>
        /// <param name="key">map key, must be null terminated c string</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_STRING_KEY_NOT_FOUND` if key not found, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// The key needs to be a null terminated c string.
        /// If the given key is not found, RCUTILS_RET_STRING_KEY_NOT_FOUND is returned.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_unset(RclNative.rcutils_string_map_t* string_map, byte* key);

        /// <summary>
        /// Get whether or not a key exists.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be searched</param>
        /// <param name="key">map key, must be null terminated c string</param>
        /// <returns>`true` if key is in the map, or</returns>
        /// <returns>`false` if key is not in the map, or</returns>
        /// <returns>`false` for invalid arguments, or</returns>
        /// <returns>`false` if the string map is invalid</returns>
        /// <remarks>
        /// The key needs to be a null terminated c string.This function can fail and return false if the key is not found,
        /// or the string_map is NULL or invalid, or if the key is NULL.
        /// In all cases no error message is set.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_string_map_key_exists(RclNative.rcutils_string_map_t* string_map, byte* key);

        /// <summary>
        /// Get whether or not a key of known length exists.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be searched</param>
        /// <param name="key">map key</param>
        /// <param name="key_length">map key length</param>
        /// <returns>`true` if key is in the map, or</returns>
        /// <returns>`false` if key is not in the map, or</returns>
        /// <returns>`false` for invalid arguments, or</returns>
        /// <returns>`false` if the string map is invalid</returns>
        /// <remarks>
        /// Identical to rcutils_string_map_key_exists() but without relying on key to be
        /// a null terminated c string.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcutils_string_map_key_existsn(RclNative.rcutils_string_map_t* string_map, byte* key, RclNative.size_t key_length);

        /// <summary>
        /// Get value given a key.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be searched</param>
        /// <param name="key">map key, must be null terminated c string</param>
        /// <returns>value for the given key if successful, or</returns>
        /// <returns>`NULL` for invalid arguments, or</returns>
        /// <returns>`NULL` if the string map is invalid, or</returns>
        /// <returns>`NULL` if key not found, or</returns>
        /// <returns>`NULL` if an unknown error occurs</returns>
        /// <remarks>
        /// The key needs to be a null terminated c string.This function can fail, and therefore return NULL, if the key is not found,
        /// or the string_map is NULL or invalid, or if the key is NULL.
        /// In all cases no error message is set.The returned value string is still owned by the map, and it should not be
        /// modified or free'd.
        /// This also means that the value pointer becomes invalid if either
        /// rcutils_string_map_clear() or rcutils_string_map_fini() are called or if
        /// the key value pair is updated or removed with one of rcutils_string_map_set()
        /// or rcutils_string_map_set_no_resize() or rcutils_string_map_unset().
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcutils_string_map_get(RclNative.rcutils_string_map_t* string_map, byte* key);

        /// <summary>
        /// Get value given a key and key length.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be searched</param>
        /// <param name="key">map key</param>
        /// <param name="key_length">map key length</param>
        /// <returns>value for the given key if successful, or</returns>
        /// <returns>`NULL` for invalid arguments, or</returns>
        /// <returns>`NULL` if the string map is invalid, or</returns>
        /// <returns>`NULL` if key not found, or</returns>
        /// <returns>`NULL` if an unknown error occurs</returns>
        /// <remarks>
        /// Identical to rcutils_string_map_get() but without relying on key to be a
        /// null terminated c string.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcutils_string_map_getn(RclNative.rcutils_string_map_t* string_map, byte* key, RclNative.size_t key_length);

        /// <summary>
        /// Get the next key in the map, unless NULL is given, then get the first key.
        /// </summary>
        /// <param name="string_map">rcutils_string_map_t to be queried</param>
        /// <param name="key">NULL to get the first key or the previous key to get the next</param>
        /// <returns>value for the given key if successful, or</returns>
        /// <returns>`NULL` for invalid arguments, or</returns>
        /// <returns>`NULL` if the string map is invalid, or</returns>
        /// <returns>`NULL` if key not found, or</returns>
        /// <returns>`NULL` if there are no more keys in the map, or</returns>
        /// <returns>`NULL` if an unknown error occurs</returns>
        /// <remarks>
        /// This function allows you iteratively get each key in the map.If NULL is given for the key, then the first key in the map is returned.
        /// If that returned key if given to the this function, then the next key in the
        /// map is returned.
        /// If there are no more keys in the map or if the given key is not in the map,
        /// NULL is returned.The order of the keys in the map is arbitrary and if the map is modified
        /// between calls to this function the behavior is undefined.
        /// If the map is modifeid then iteration should begin again by passing NULL to
        /// get the first key again.This function operates based on the address of the pointer, you cannot pass
        /// a copy of a key to get the next key.Example:```c
        /// printf("keys in the map:\n");
        /// const char * current_key = rcutils_string_map_get_next_key(
        /// &amp;map
        /// , NULL);
        /// while (current_key) {
        /// printf("  - %s\n", current_key);
        /// current_key = rcutils_string_map_get_next_key(
        /// &amp;map
        /// , current_key);
        /// }
        /// ```NULL can also be returned if NULL is given for the string_map or if the
        /// string_map is invalid.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcutils_string_map_get_next_key(RclNative.rcutils_string_map_t* string_map, byte* key);

        /// <summary>
        /// Copy all the key value pairs from one map into another, overwritting and resizing if needed.
        /// </summary>
        /// <param name="src_string_map">rcutils_string_map_t to be copied from</param>
        /// <param name="dst_string_map">rcutils_string_map_t to be copied to</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` for invalid arguments, or</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCUTILS_RET_STRING_MAP_INVALID` if the string map is invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unknown error occurs</returns>
        /// <remarks>
        /// If the destination string map does not have enough storage, then it is will
        /// be resized.
        /// If a key value pair exists in the destination map, its value will be
        /// replaced with the source map's value.It is possible for only some of the values to be copied if an error happens
        /// during the copying process, e.g. if memory allocation fails.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_string_map_copy(RclNative.rcutils_string_map_t* src_string_map, RclNative.rcutils_string_map_t* dst_string_map);

        /// <summary>
        /// Return a zero initialized uint8 array struct.
        /// </summary>
        /// <returns>rcutils_uint8_array_t a zero initialized uint8 array struct</returns>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_uint8_array_t rcutils_get_zero_initialized_uint8_array();

        /// <summary>
        /// Initialize a zero initialized uint8 array struct.
        /// </summary>
        /// <param name="uint8_array">a pointer to the to be initialized uint8 array struct</param>
        /// <param name="buffer_capacity">the size of the memory to allocate for the byte stream</param>
        /// <param name="allocator">the allocator to use for the memory allocation</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENTS` if any arguments are invalid, or</returns>
        /// <returns>'RCUTILS_RET_BAD_ALLOC` if no memory could be allocated correctly</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// This function may leak if the uint8 array struct is already initialized.
        /// If the capacity is set to 0, no memory is allocated and the internal buffer
        /// is still NULL.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_uint8_array_init(RclNative.rcutils_uint8_array_t* uint8_array, RclNative.size_t buffer_capacity, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize a uint8 array struct.
        /// </summary>
        /// <param name="uint8_array">pointer to the rcutils_uint8_array_t to be cleaned up</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENTS` if the uint8_array argument is invalid</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// Cleans up and deallocates any resources used in a rcutils_uint8_array_t.
        /// The array passed to this function needs to have been initialized by
        /// rcutils_uint8_array_init().
        /// Passing an uninitialized instance to this function leads to undefined
        /// behavior.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_uint8_array_fini(RclNative.rcutils_uint8_array_t* uint8_array);

        /// <summary>
        /// Resize the internal buffer of the uint8 array.
        /// </summary>
        /// <param name="uint8_array">pointer to the instance of rcutils_uint8_array_t which is
        /// being resized</param>
        /// <param name="new_size">the new size of the internal buffer</param>
        /// <returns>`RCUTILS_RET_OK` if successful, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if new_size is set to zero</returns>
        /// <returns>`RCUTILS_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unexpected error occurs</returns>
        /// <remarks>
        /// The internal buffer of the uint8 array can be resized dynamically if needed.
        /// If the new size is smaller than the current capacity, then the memory is
        /// truncated.
        /// Be aware, that this might deallocate the memory and therefore invalidates any
        /// pointers to this storage.
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_uint8_array_resize(RclNative.rcutils_uint8_array_t* uint8_array, RclNative.size_t new_size);

        /// <summary>
        /// This function returns the time from a system clock.
        /// The closest equivalent would be to std::chrono::system_clock::now();
        /// </summary>
        /// <param name="now">a datafield in which the current time is stored</param>
        /// <returns>`RCUTILS_RET_OK` if the current time was successfully obtained, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.The now argument must point to an allocated rcutils_time_point_value_t object,
        /// as the result is copied into this variable.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_system_time_now(RclNative.rcutils_time_point_value_t* now);

        /// <summary>
        /// Retrieve the current time as a rcutils_time_point_value_t object.
        /// </summary>
        /// <param name="now">a struct in which the current time is stored</param>
        /// <returns>`RCUTILS_RET_OK` if the current time was successfully obtained, or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// This function returns the time from a monotonically increasing clock.
        /// The closest equivalent would be to std::chrono::steady_clock::now();The resolution (e.g. nanoseconds vs microseconds) is not guaranteed.The now argument must point to an allocated rcutils_time_point_value_t object,
        /// as the result is copied into this variable.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_steady_time_now(RclNative.rcutils_time_point_value_t* now);

        /// <summary>
        /// Return a time point as nanoseconds in a string.
        /// </summary>
        /// <param name="time_point">the time to be made into a string</param>
        /// <param name="str">the output string in which it is stored</param>
        /// <param name="str_size">the size of the output string</param>
        /// <returns>`RCUTILS_RET_OK` if successful (even if truncated), or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The number is always fixed width, with left padding zeros up to the maximum
        /// number of digits the time point can represent.
        /// Right now that is 19 digits (so 19 characters) for a signed 64-bit integer.
        /// Negative values will have a leading `-`, so they will be one character
        /// longer than the positive values.The recommended minimum size of the input string is 32 characters, but
        /// 21 (` ` or `-` for sign, 19 digits, null terminator) should be sufficiently
        /// large for both positive and negative values.
        /// If the given string is not large enough, the result will be truncated.
        /// If you need a string with variable width, using `snprintf()` directly is
        /// recommended.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No [1]
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] if `snprintf()` does not allocate additional memory internally&lt;/i&gt;
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_time_point_value_as_nanoseconds_string(RclNative.rcutils_time_point_value_t* time_point, sbyte* str, RclNative.size_t str_size);

        /// <summary>
        /// Return a time point as floating point seconds in a string.
        /// </summary>
        /// <param name="time_point">the time to be made into a string</param>
        /// <param name="str">the output string in which it is stored</param>
        /// <param name="str_size">the size of the output string</param>
        /// <returns>`RCUTILS_RET_OK` if successful (even if truncated), or</returns>
        /// <returns>`RCUTILS_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCUTILS_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The number is always fixed width, with left padding zeros up to the maximum
        /// number of digits for the mantissa that the time point can represent and a
        /// characteristic (fractional-part) with a fixed width of 9 digits.
        /// Right now that means the mantissa is always 10 digits to add up to 19 total
        /// for the signed 64-bit time point type.
        /// Negative values will have a leading `-`, so they will be one character
        /// longer then positive values.The recommended minimum size of the input string is 32 characters, but
        /// 22 (` ` or `-` for sign, 19 digits, decimal point, null terminator) should
        /// be sufficient for now.
        /// If the given string is not large enough, the result will be truncated.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No [1]
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] if `snprintf()` does not allocate additional memory internally&lt;/i&gt;
        /// </remarks>
        [DllImport("rcutils", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcutils_ret_t rcutils_time_point_value_as_seconds_string(RclNative.rcutils_time_point_value_t* time_point, sbyte* str, RclNative.size_t str_size);

        /// <summary>
        /// Get zero initialized mesage info.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_message_info_t rmw_get_zero_initialized_message_info();

        /// <summary>
        /// Return a rcl_arguments_t struct with members initialized to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_arguments_t rcl_get_zero_initialized_arguments();

        /// <summary>
        /// Parse command line arguments into a structure usable by code.
        /// </summary>
        /// <param name="argc">The number of arguments in argv.</param>
        /// <param name="args_output">A structure that will contain the result of parsing.
        /// Must be zero initialized before use.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="argv">The values of the arguments.</param>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or</returns>
        /// <returns>`RCL_RET_OK` if the arguments were parsed successfully, or</returns>
        /// <remarks>
        /// ROS arguments are expected to be scoped by a leading `--ros-args` flag and a trailing double
        /// dash token `--` which may be elided if no non-ROS arguments follow after the last `--ros-args`.Remap rule parsing is supported via `-r/--remap` flags e.g. `--remap from:=to` or `-r from:=to`.
        /// Successfully parsed remap rules are stored in the order they were given in `argv`.
        /// If given arguments `{"__ns:=/foo", "__ns:=/bar"}` then the namespace used by nodes in this
        /// process will be `/foo` and not `/bar`.Parameter override rule parsing is supported via `-p/--param` flags e.g. `--param name:=value`
        /// or `-p name:=value`.The default log level will be parsed as `--log-level level`, where `level` is a name
        /// representing one of the log levels in the `RCUTILS_LOG_SEVERITY` enum, e.g. `info`, `debug`,
        /// `warn`, not case sensitive.
        /// If multiple of these rules are found, the last one parsed will be used.If an argument does not appear to be a valid ROS argument e.g. a `-r/--remap` flag followed by
        /// anything but a valid remap rule, parsing will fail immediately.If an argument does not appear to be a known ROS argument, then it is skipped and left unparsed.All arguments found outside a `--ros-args ... --` scope are skipped and left unparsed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_arguments_get_count_unparsed()"/>
        /// <seealso cref="rcl_arguments_get_unparsed_ros()"/>
        /// <seealso cref="rcl_arguments_get_count_unparsed_ros()"/>
        /// <seealso cref="rcl_remap_node_namespace()"/>
        /// <seealso cref="rcl_remap_node_name()"/>
        /// <seealso cref="rcl_remap_service_name()"/>
        /// <seealso cref="rcl_remap_topic_name()"/>
        /// <seealso cref="rcl_arguments_get_unparsed()"/>
        /// <seealso cref="rcl_get_zero_initialized_arguments()"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_parse_arguments(int argc, byte** argv, RclNative.rcl_allocator_t allocator, RclNative.rcl_arguments_t* args_output);

        /// <summary>
        /// Return the number of arguments that were not ROS specific arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of unparsed arguments, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_count_unparsed(RclNative.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of indices to non ROS specific arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="output_unparsed_indices">An allocated array of indices into the original argv array.
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no unparsed args then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Non ROS specific arguments may have been provided i.e. arguments outside a '--ros-args' scope.
        /// This function populates an array of indices to these arguments in the original argv array.
        /// Since the first argument is always assumed to be a process name, the list will always contain
        /// the index 0.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_get_unparsed(RclNative.rcl_arguments_t* args, RclNative.rcl_allocator_t allocator, int** output_unparsed_indices);

        /// <summary>
        /// Return the number of ROS specific arguments that were not successfully parsed.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of unparsed ROS specific arguments, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_count_unparsed_ros(RclNative.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of indices to unknown ROS specific arguments that were left unparsed.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="output_unparsed_ros_indices">An allocated array of indices into the original argv array.
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no unparsed ROS specific arguments then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Some ROS specific arguments may not have been recognized, or were not intended to be
        /// parsed by rcl.
        /// This function populates an array of indices to these arguments in the original argv array.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_get_unparsed_ros(RclNative.rcl_arguments_t* args, RclNative.rcl_allocator_t allocator, int** output_unparsed_ros_indices);

        /// <summary>
        /// Return the number of parameter yaml files given in the arguments.
        /// </summary>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <returns>number of yaml files, or</returns>
        /// <returns>-1 if args is `NULL` or zero initialized.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern int rcl_arguments_get_param_files_count(RclNative.rcl_arguments_t* args);

        /// <summary>
        /// Return a list of yaml parameter file paths specified on the command line.
        /// </summary>
        /// <param name="arguments">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="parameter_files">An allocated array of paramter file names.
        /// This array must be deallocated by the caller using the given allocator.
        /// The output is NULL if there were no paramter files.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_get_param_files(RclNative.rcl_arguments_t* arguments, RclNative.rcl_allocator_t allocator, sbyte*** parameter_files);

        /// <summary>
        /// Return all parameter overrides parsed from the command line.
        /// </summary>
        /// <param name="arguments">An arguments structure that has been parsed.</param>
        /// <param name="parameter_overrides">Parameter overrides as parsed from command line arguments.
        /// This structure must be finalized by the caller.
        /// The output is NULL if no parameter overrides were parsed.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Parameter overrides are parsed directly from command line arguments and
        /// parameter files provided in the command line.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_get_param_overrides(RclNative.rcl_arguments_t* arguments, RclNative.rcl_params_t** parameter_overrides);

        /// <summary>
        /// Return a list of arguments with ROS-specific arguments removed.
        /// </summary>
        /// <param name="argv">The argument vector</param>
        /// <param name="args">An arguments structure that has been parsed.</param>
        /// <param name="allocator">A valid allocator.</param>
        /// <param name="nonros_argc">The count of arguments that aren't ROS-specific</param>
        /// <param name="nonros_argv">An allocated array of arguments that aren't ROS-specific
        /// This array must be deallocated by the caller using the given allocator.
        /// If there are no non-ROS args, then the output will be set to NULL.</param>
        /// <returns>`RCL_RET_OK` if everything goes correctly, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Some arguments may not have been intended as ROS arguments.
        /// This function populates an array of the aruments in a new argv array.
        /// Since the first argument is always assumed to be a process name, the list
        /// will always contain the first value from the argument vector.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_remove_ros_arguments(byte** argv, RclNative.rcl_arguments_t* args, RclNative.rcl_allocator_t allocator, int* nonros_argc, byte*** nonros_argv);

        /// <summary>
        /// Copy one arguments structure into another.
        /// </summary>
        /// <param name="args">The structure to be copied.
        /// Its allocator is used to copy memory into the new structure.</param>
        /// <param name="args_out">A zero-initialized arguments structure to be copied into.</param>
        /// <returns>`RCL_RET_OK` if the structure was copied successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_copy(RclNative.rcl_arguments_t* args, RclNative.rcl_arguments_t* args_out);

        /// <summary>
        /// Reclaim resources held inside rcl_arguments_t structure.
        /// </summary>
        /// <param name="args">The structure to be deallocated.</param>
        /// <returns>`RCL_RET_OK` if the memory was successfully freed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_arguments_fini(RclNative.rcl_arguments_t* args);

        /// <summary>
        /// Return a zero initialized rcl_init_options_t struct.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_init_options_t rcl_get_zero_initialized_init_options();

        /// <summary>
        /// Initialize given init_options with the default values and implementation specific values.
        /// </summary>
        /// <param name="init_options">object to be setup</param>
        /// <param name="allocator">to be used during setup and during initialization</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if init_options has already be initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given allocator is used, if required, during setup of the init options,
        /// but is also used during initialization.In either case the given allocator is stored in the returned init options.The `impl` pointer should not be changed manually.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init_options_init(RclNative.rcl_init_options_t* init_options, RclNative.rcl_allocator_t allocator);

        /// <summary>
        /// Copy the given source init_options to the destination init_options.
        /// </summary>
        /// <param name="src">rcl_init_options_t object to be copied from</param>
        /// <param name="dst">rcl_init_options_t object to be copied into</param>
        /// <returns>`RCL_RET_OK` if the copy is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the dst has already be initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The allocator from the source is used for any allocations and stored in the
        /// destination.The destination should either be zero initialized with
        /// `rcl_get_zero_initialized_init_options()` or should have had
        /// `rcl_init_options_fini()` called on it.
        /// Giving an already initialized init options for the destination will result
        /// in a failure with return code `RCL_RET_ALREADY_INIT`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init_options_copy(RclNative.rcl_init_options_t* src, RclNative.rcl_init_options_t* dst);

        /// <summary>
        /// Finalize the given init_options.
        /// </summary>
        /// <param name="init_options">object to be setup</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given init_options must be non-`NULL` and valid, i.e. had
        /// `rcl_init_options_init()` called on it but not this function yet.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init_options_fini(RclNative.rcl_init_options_t* init_options);

        /// <summary>
        /// Return the domain_id stored in the init options.
        /// </summary>
        /// <param name="init_options">object from which the domain id should be retrieved.</param>
        /// <param name="domain_id">domain id to be set in init_options object.</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid.</returns>
        /// <remarks>
        /// Get the domain id from the specified rcl_init_options_t object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init_options_get_domain_id(RclNative.rcl_init_options_t* init_options, RclNative.size_t* domain_id);

        /// <summary>
        /// Set a domain id in the init options provided.
        /// </summary>
        /// <param name="init_options">objects in which to set the specified domain id.</param>
        /// <param name="domain_id">domain id to be set in init_options object.</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid.</returns>
        /// <remarks>
        /// Store the domain id in the specified init_options object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init_options_set_domain_id(RclNative.rcl_init_options_t* init_options, RclNative.size_t domain_id);

        /// <summary>
        /// Return the rmw init options which are stored internally.
        /// </summary>
        /// <param name="init_options">object from which the rmw init options should be retrieved</param>
        /// <returns>pointer to the the rcl init options, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - init_options is NULL
        /// - init_options is invalid, e.g. init_options-&gt;impl is NULLIf NULL is returned an error message will have been set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_init_options_t* rcl_init_options_get_rmw_init_options(RclNative.rcl_init_options_t* init_options);

        /// <summary>
        /// Return the allocator stored in the init_options.
        /// </summary>
        /// <param name="init_options">object from which the allocator should be retrieved</param>
        /// <returns>pointer to the rcl allocator, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - init_options is NULL
        /// - init_options is invalid, e.g. init_options-&gt;impl is NULLIf NULL is returned an error message will have been set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_allocator_t* rcl_init_options_get_allocator(RclNative.rcl_init_options_t* init_options);

        /// <summary>
        /// Return a zero initialization context object.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_context_t rcl_get_zero_initialized_context();

        /// <summary>
        /// Finalize a context.
        /// </summary>
        /// <param name="context">object to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the shutdown was completed successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The context to be finalized must have been previously initialized with
        /// `rcl_init()`, and then later invalidated with `rcl_shutdown()`.
        /// A zero-initialized context that has not been initialized can be finalized.
        /// If context is `NULL`, then `RCL_RET_INVALID_ARGUMENT` is returned.
        /// If context is zero-initialized, then `RCL_RET_OK` is returned.
        /// If context is initialized and valid (`rcl_shutdown()` was not called on it),
        /// then `RCL_RET_INVALID_ARGUMENT` is returned.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_context_fini(RclNative.rcl_context_t* context);

        /// <summary>
        /// Return the init options used during initialization for this context.
        /// </summary>
        /// <param name="context">object from which the init options should be retrieved</param>
        /// <returns>pointer to the the init options, or</returns>
        /// <returns>`NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail and return `NULL` if:
        /// - context is NULL
        /// - context is zero-initialized, e.g. context-&gt;impl is `NULL`If context is uninitialized then that is undefined behavior.If `NULL` is returned an error message will have been set.The options are for reference only, and therefore the returned pointer is
        /// const.
        /// Changing the values in the options is undefined behavior but will likely
        /// have no effect.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_init_options_t* rcl_context_get_init_options(RclNative.rcl_context_t* context);

        /// <summary>
        /// Returns an unsigned integer that is unique to the given context, or `0` if invalid.
        /// </summary>
        /// <param name="context">object from which the instance id should be retrieved</param>
        /// <returns>a unique id specific to this context instance, or</returns>
        /// <returns>`0` if invalid, or</returns>
        /// <returns>`0` if context is `NULL`</returns>
        /// <remarks>
        /// The given context must be non-`NULL`, but does not need to be initialized or valid.
        /// If context is `NULL`, then `0` will be returned.
        /// If context is uninitialized, then it is undefined behavior.The instance ID may be `0` if the context is zero-initialized or if the
        /// context has been invalidated by `rcl_shutdown()`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_context_instance_id_t rcl_context_get_instance_id(RclNative.rcl_context_t* context);

        /// <summary>
        /// Return `true` if the given context is currently valid, otherwise `false`.
        /// </summary>
        /// <param name="context">object which should be checked for validity</param>
        /// <returns>`true` if valid, otherwise `false`</returns>
        /// <remarks>
        /// If context is `NULL`, then `false` is returned.
        /// If context is zero-initialized, then `false` is returned.
        /// If context is uninitialized, then it is undefined behavior.Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_context_is_valid(RclNative.rcl_context_t* context);

        /// <summary>
        /// Return pointer to the rmw context if the given context is currently valid, otherwise `NULL`.
        /// </summary>
        /// <param name="context">object from which the rmw context should be retrieved.</param>
        /// <returns>pointer to rmw context if valid, otherwise `NULL`</returns>
        /// <remarks>
        /// If context is `NULL`, then `NULL` is returned.
        /// If context is zero-initialized, then `NULL` is returned.
        /// If context is uninitialized, then it is undefined behavior.Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_context_t* rcl_context_get_rmw_context(RclNative.rcl_context_t* context);

        /// <summary>
        /// Initialization of rcl.
        /// </summary>
        /// <param name="argc">number of strings in argv</param>
        /// <param name="argv">command line arguments; rcl specific arguments are removed</param>
        /// <param name="options">options used during initialization</param>
        /// <param name="context">resulting context object that represents this init</param>
        /// <returns>`RCL_RET_OK` if initialization is successful, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if rcl_init has already been called, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ROS_ARGS` if an invalid ROS argument is found, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function can be run any number of times, so long as the given context
        /// has been properly prepared.The given `rcl_context_t` must be zero initialized with the function
        /// `rcl_get_zero_initialized_context()` and must not be already initialized
        /// by this function.
        /// If the context is already initialized this function will fail and return the
        /// `RCL_RET_ALREADY_INIT` error code.
        /// A context may be initialized again after it has been finalized with the
        /// `rcl_shutdown()` function and zero initialized again with
        /// `rcl_get_zero_initialized_context()`.The `argc` and `argv` parameters may contain command line arguments for the
        /// program.
        /// rcl specific arguments will be parsed, but not removed.
        /// If `argc` is `0` and `argv` is `NULL` no parameters will be parsed.The `options` argument must be non-`NULL` and must have been initialized
        /// with `rcl_init_options_init()`.
        /// It is unmodified by this function, and the ownership is not transfered to
        /// the context, but instead a copy is made into the context for later reference.
        /// Therefore, the given options need to be cleaned up with
        /// `rcl_init_options_fini()` after this function returns.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_init(int argc, byte** argv, RclNative.rcl_init_options_t* options, RclNative.rcl_context_t* context);

        /// <summary>
        /// Shutdown a given rcl context.
        /// </summary>
        /// <param name="context">object to shutdown</param>
        /// <returns>`RCL_RET_OK` if the shutdown was completed successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_SHUTDOWN` if the context is not currently valid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occur.</returns>
        /// <remarks>
        /// The given context must have been initialized with `rcl_init()`.
        /// If not, this function will fail with `RCL_RET_ALREADY_SHUTDOWN`.When this function is called:
        /// - Any rcl objects created using this context are invalidated.
        /// - Functions called on invalid objects may or may not fail.
        /// - Calls to `rcl_context_is_initialized()` will return `false`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_shutdown(RclNative.rcl_context_t* context);

        /// <summary>
        /// Determine the default domain ID, based on the environment.
        /// </summary>
        /// <param name="domain_id">Must not be NULL.</param>
        /// <returns>RCL_RET_INVALID_ARGUMENT if an argument is invalid, or,</returns>
        /// <returns>RCL_RET_ERROR in case of an unexpected error, or,</returns>
        /// <returns>RCL_RET_OK.</returns>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_default_domain_id(RclNative.size_t* domain_id);

        /// <summary>
        /// Return the default node options in a rcl_node_options_t.
        /// </summary>
        /// <remarks>
        /// The default values are:- domain_id = RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID
        /// - allocator = rcl_get_default_allocator()
        /// - use_global_arguments = true
        /// - enable_rosout = true
        /// - arguments = rcl_get_zero_initialized_arguments()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_node_options_t rcl_node_get_default_options();

        /// <summary>
        /// Copy one options structure into another.
        /// </summary>
        /// <param name="options">The structure to be copied.
        /// Its allocator is used to copy memory into the new structure.</param>
        /// <param name="options_out">An options structure containing default values.</param>
        /// <returns>`RCL_RET_OK` if the structure was copied successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any function arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_node_options_copy(RclNative.rcl_node_options_t* options, RclNative.rcl_node_options_t* options_out);

        /// <summary>
        /// Finalize the given node_options.
        /// </summary>
        /// <param name="options">object to be finalized</param>
        /// <returns>`RCL_RET_OK` if setup is successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The given node_options must be non-`NULL` and valid, i.e. had
        /// `rcl_node_get_default_options()` called on it but not this function yet.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_node_options_fini(RclNative.rcl_node_options_t* options);

        /// <summary>
        /// Return a rcl_node_t struct with members initialized to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_node_t rcl_get_zero_initialized_node();

        /// <summary>
        /// Initialize a ROS node.
        /// </summary>
        /// <param name="options">the node options.
        /// The options are deep copied into the node.
        /// The caller is always responsible for freeing memory used options they
        /// pass in.</param>
        /// <param name="node">a preallocated rcl_node_t</param>
        /// <param name="name">the name of the node, must be a valid c-string</param>
        /// <param name="namespace_">the namespace of the node, must be a valid c-string</param>
        /// <param name="context">the context instance with which the node should be
        /// associated</param>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the namespace_ is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the name is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_OK` if the node was initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the node has already be initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <remarks>
        /// Calling this on a rcl_node_t makes it a valid node handle until rcl_shutdown
        /// is called or until rcl_node_fini is called on it.After calling, the ROS node object can be used to create other middleware
        /// primitives like publishers, services, parameters, etc.The name of the node must not be NULL and adhere to naming restrictions,
        /// see the rmw_validate_node_name() function for rules.The name of the node cannot coincide with another node of the same name.
        /// If a node of the same name is already in the domain, it will be shutdown.The namespace of the node should not be NULL and should also pass the
        /// rmw_validate_namespace() function's rules.Additionally this function allows namespaces which lack a leading forward
        /// slash.
        /// Because there is no notion of a relative namespace, there is no difference
        /// between a namespace which lacks a forward and the same namespace with a
        /// leasing forward slash.
        /// Therefore, a namespace like ``"foo/bar"`` is automatically changed to
        /// ``"/foo/bar"`` by this function.
        /// Similarly, the namespace ``""`` will implicitly become ``"/"`` which is a
        /// valid namespace.A node contains infrastructure for ROS parameters, which include advertising
        /// publishers and service servers.
        /// This function will create those external parameter interfaces even if
        /// parameters are not used later.The rcl_node_t given must be allocated and zero initialized.
        /// Passing an rcl_node_t which has already had this function called on it, more
        /// recently than rcl_node_fini, will fail.
        /// An allocated rcl_node_t with uninitialized memory is undefined behavior.Expected usage:```c
        /// rcl_context_t context = rcl_get_zero_initialized_context();
        /// // ... initialize the context with rcl_init()
        /// rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// // ... node options customization
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/node_ns", 
        /// &amp;context
        /// , 
        /// &amp;node
        /// _ops);
        /// // ... error handling and then use the node, but eventually deinitialize it:
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// the context handle must be allocated, initialized, and valid
        /// </pre>
        /// <pre>
        /// the node handle must be allocated, zero initialized, and invalid
        /// </pre>
        /// <todo>
        /// TODO(wjwwood):
        /// Parameter infrastructure is currently initialized in the language specific
        /// client library, e.g. rclcpp for C++, but will be initialized here in the
        /// future. When that happens there will be an option to avoid parameter
        /// infrastructure with an option in the rcl_node_options_t struct.
        /// </todo>
        /// <post>
        /// the node handle is valid and can be used in other `rcl_*` functions
        /// </post>
        /// <todo>
        /// TODO(wjwwood): node name uniqueness is no yet enforced
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_node_init(RclNative.rcl_node_t* node, byte* name, byte* namespace_, RclNative.rcl_context_t* context, RclNative.rcl_node_options_t* options);

        /// <summary>
        /// Finalize a rcl_node_t.
        /// </summary>
        /// <param name="node">rcl_node_t to be finalized</param>
        /// <returns>`RCL_RET_OK` if node was finalized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node pointer is null, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Destroys any automatically created infrastructure and deallocates memory.
        /// After calling, the rcl_node_t can be safely deallocated.All middleware primitives created by the user, e.g. publishers, services, etc,
        /// which were created from this node must be finalized using their respective
        /// `rcl_*_fini()` functions before this is called.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rcl_publisher_fini()"/>
        /// <seealso cref="rcl_subscription_fini()"/>
        /// <seealso cref="rcl_client_fini()"/>
        /// <seealso cref="rcl_service_fini()"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_node_fini(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return `true` if the node is valid, else `false`.
        /// </summary>
        /// <param name="node">rcl_node_t to be validated</param>
        /// <returns>`true` if the node and allocator are valid, otherwise `false`.</returns>
        /// <remarks>
        /// Also return `false` if the node pointer is `NULL` or the allocator is invalid.A node is invalid if:
        /// - the implementation is `NULL` (rcl_node_init not called or failed)
        /// - rcl_shutdown has been called since the node has been initialized
        /// - the node has been finalized with rcl_node_finiThere is a possible validity race condition.Consider:```c
        /// assert(rcl_node_is_valid(node));  // 
        /// &lt;
        /// -- thread 1
        /// rcl_shutdown();                   // 
        /// &lt;
        /// -- thread 2
        /// // use node as if valid           // 
        /// &lt;
        /// -- thread 1
        /// ```In the third line the node is now invalid, even though on the previous line
        /// of thread 1 it was checked to be valid.
        /// This is why this function is considered not thread-safe.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_node_is_valid(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return true if node is valid, except for the context being valid.
        /// </summary>
        /// <remarks>
        /// This is used in clean up functions that need to access the node, but do not
        /// need use any functions with the context.It is identical to rcl_node_is_valid except it ignores the state of the
        /// context associated with the node.
        /// </remarks>
        /// <seealso cref="rcl_node_is_valid()"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_node_is_valid_except_context(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal name string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_name(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the namespace of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal namespace string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_namespace(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the fully qualified name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>fully qualified name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal namespace and name combined string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_fully_qualified_name(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the rcl node options.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal options struct.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned struct is only valid as long as the given rcl_node_t is valid.
        /// The values in the struct may change if the options of the rcl_node_t changes,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_node_options_t* rcl_node_get_options(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the ROS domain ID that the node is using.
        /// </summary>
        /// <param name="node">the handle to the node being queried</param>
        /// <param name="domain_id">storage for the domain id</param>
        /// <returns>`RCL_RET_OK` if node the domain ID was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function returns the ROS domain ID that the node is in.This function should be used to determine what `domain_id` was used rather
        /// than checking the domain_id field in the node options, because if
        /// `RCL_NODE_OPTIONS_DEFAULT_DOMAIN_ID` is used when creating the node then
        /// it is not changed after creation, but this function will return the actual
        /// `domain_id` used.The `domain_id` field must point to an allocated `size_t` object to which
        /// the ROS domain ID will be written.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_node_get_domain_id(RclNative.rcl_node_t* node, RclNative.size_t* domain_id);

        /// <summary>
        /// Return the rmw node handle.
        /// </summary>
        /// <param name="node">pointer to the rcl node</param>
        /// <returns>rmw node handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned handle is made invalid if the node is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// node as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the node using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_node_t* rcl_node_get_rmw_handle(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the associated rcl instance id.
        /// </summary>
        /// <param name="node">pointer to the rcl node</param>
        /// <returns>rcl instance id captured during node init or `0` on error</returns>
        /// <remarks>
        /// This id is stored when rcl_node_init is called and can be compared with the
        /// value returned by rcl_get_instance_id() to check if this node was created in
        /// the current rcl context (since the latest call to rcl_init().This function can fail, and therefore return `0`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)This function will succeed even if rcl_shutdown() has been called
        /// since the node was created.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong rcl_node_get_rcl_instance_id(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return a guard condition which is triggered when the ROS graph changes.
        /// </summary>
        /// <param name="node">pointer to the rcl node</param>
        /// <returns>rcl guard condition handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to an internally held rcl guard condition.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node is invalidThe returned handle is made invalid if the node is finialized or if
        /// rcl_shutdown() is called.The guard condition will be triggered anytime a change to the ROS graph occurs.
        /// A ROS graph change includes things like (but not limited to) a new publisher
        /// advertises, a new subscription is created, a new service becomes available,
        /// a subscription is canceled, etc.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood): link to exhaustive list of graph events
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_guard_condition_t* rcl_node_get_graph_guard_condition(RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the logger name of the node.
        /// </summary>
        /// <param name="node">pointer to the node</param>
        /// <returns>logger_name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the node's internal logger name string.
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is `NULL`
        /// - node has not been initialized (the implementation is invalid)The returned string is only valid as long as the given rcl_node_t is valid.
        /// The value of the string may change if the value in the rcl_node_t changes,
        /// and therefore copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_node_get_logger_name(RclNative.rcl_node_t* node);

        /// <summary>
        /// Get the message type support handle specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to message type support</param>
        /// <param name="identifier">The typesupport identifier to get the handle function for</param>
        /// <returns>The associated message typesupport handle function.</returns>
        /// <remarks>
        /// The handle's message typesupport identifier function is returned or if the parameters are NULL
        /// then an assert will happen.
        /// </remarks>
        [DllImport("rosidl_runtime_c", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_message_type_support_t* get_message_typesupport_handle(RclNative.rosidl_message_type_support_t* handle, byte* identifier);

        /// <summary>
        /// Get the message type support handle function specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to message type support</param>
        /// <param name="identifier">The typesupport identifier to get the handle function for</param>
        /// <returns>if the identifier match's the handle's identifier then the handle's function
        /// is returned.</returns>
        /// <remarks>
        /// If the identifier is the same as this handle's typesupport_identifier the handle is simply
        /// returned or if the parameters are NULL then an assert will happen.
        /// </remarks>
        [DllImport("get", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_message_type_support_t* get_message_typesupport_handle_function(RclNative.rosidl_message_type_support_t* handle, byte* identifier);

        /// <summary>
        /// Return a rcl_publisher_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_publisher_t before passing to
        /// rcl_publisher_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_publisher_t rcl_get_zero_initialized_publisher();

        /// <summary>
        /// Initialize a rcl publisher.
        /// </summary>
        /// <param name="publisher">preallocated publisher structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the topic's type</param>
        /// <param name="topic_name">the name of the topic to publish on</param>
        /// <param name="options">publisher options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if the publisher was initialized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the publisher is already initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_publisher_t, it can be used to publish
        /// messages of the given type to the given topic using rcl_publish().The given rcl_node_t must be valid and the resulting rcl_publisher_t is only
        /// valid as long as the given rcl_node_t remains valid.The rosidl_message_type_support_t is obtained on a per .msg type basis.
        /// When the user defines a ROS message, code is generated which provides the
        /// required rosidl_message_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `std_msgs/String`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _typesupport_cpp/message_type_support.hpp&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.hpp&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// rosidl_typesupport_cpp::get_message_type_support_handle
        /// &lt;std
        /// _msgs::msg::String&gt;();
        /// ```The rosidl_message_type_support_t object contains message type specific
        /// information used to publish messages.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// publisher to allocate space for incidentals, e.g. the topic name string.Expected usage (for C messages):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_message_type_support_t * ts = ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// rcl_publisher_t publisher = rcl_get_zero_initialized_publisher();
        /// rcl_publisher_options_t publisher_ops = rcl_publisher_get_default_options();
        /// ret = rcl_publisher_init(
        /// &amp;publisher
        /// , 
        /// &amp;node
        /// , ts, "chatter", 
        /// &amp;publisher
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_publisher_fini(
        /// &amp;publisher
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_publisher_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_deinitialize_node()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_expand_topic_name"/>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publisher_init(RclNative.rcl_publisher_t* publisher, RclNative.rcl_node_t* node, RclNative.rosidl_message_type_support_t* type_support, byte* topic_name, RclNative.rcl_publisher_options_t* options);

        /// <summary>
        /// Finalize a rcl_publisher_t.
        /// </summary>
        /// <param name="publisher">handle to the publisher to be finalized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the publisher</param>
        /// <returns>`RCL_RET_OK` if publisher was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer be advertising that it is publishing
        /// on this topic (assuming this is the only publisher on this topic).After calling, calls to rcl_publish will fail when using this publisher.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publisher_fini(RclNative.rcl_publisher_t* publisher, RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the default publisher options in a rcl_publisher_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_default
        /// - allocator = rcl_get_default_allocator()
        /// - rmw_publisher_options = rmw_get_default_publisher_options()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_publisher_options_t rcl_publisher_get_default_options();

        /// <summary>
        /// Borrow a loaned message.
        /// </summary>
        /// <param name="publisher">Publisher to which the allocated message is associated.</param>
        /// <param name="type_support">Typesupport to which the internal ros message is allocated.</param>
        /// <param name="ros_message">The pointer to be filled to a valid ros message by the middleware.</param>
        /// <returns>`RCL_RET_OK` if the ros message was correctly initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if an argument other than the ros message is null, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if the ros message could not be correctly created, or</returns>
        /// <returns>`RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occured.</returns>
        /// <remarks>
        /// The memory allocated for the ros message belongs to the middleware and must not be deallocated
        /// other than by a call to&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No [0]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// [0] the underlying middleware might allocate new memory or returns an existing chunk form a pool.
        /// The function in rcl however does not allocate any additional memory.
        /// </remarks>
        /// <seealso cref="rcl_return_loaned_message_from_publisher."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_borrow_loaned_message(RclNative.rcl_publisher_t* publisher, RclNative.rosidl_message_type_support_t* type_support, void** ros_message);

        /// <summary>
        /// Return a loaned message previously borrowed from a publisher.
        /// </summary>
        /// <param name="publisher">Publisher to which the loaned message is associated.</param>
        /// <param name="loaned_message">Loaned message to be deallocated and destroyed.</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if an argument is null, or</returns>
        /// <returns>`RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occurs and no message can be initialized.</returns>
        /// <remarks>
        /// The ownership of the passed in ros message will be transferred back to the middleware.
        /// The middleware might deallocate and destroy the message so that the pointer is no longer
        /// guaranteed to be valid after that call.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_return_loaned_message_from_publisher(RclNative.rcl_publisher_t* publisher, void* loaned_message);

        /// <summary>
        /// Publish a ROS message on a topic using a publisher.
        /// </summary>
        /// <param name="publisher">handle to the publisher which will do the publishing</param>
        /// <param name="ros_message">type-erased pointer to the ROS message</param>
        /// <param name="allocation">structure pointer, used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was published successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_message
        /// parameter and the type associate with the publisher (via the type support)
        /// match.
        /// Passing a different type to publish produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.Calling rcl_publish() is a potentially blocking call.
        /// When called rcl_publish() will immediately do any publishing related work,
        /// including, but not limited to, converting the message into a different type,
        /// serializing the message, collecting publish statistics, etc.
        /// The last thing it will do is call the underlying middleware's publish
        /// function which may or may not block based on the quality of service settings
        /// given via the publisher options in rcl_publisher_init().
        /// For example, if the reliability is set to reliable, then a publish may block
        /// until space in the publish queue is available, but if the reliability is set
        /// to best effort then it should not block.The ROS message given by the `ros_message` void pointer is always owned by
        /// the calling code, but should remain constant during publish.This function is thread safe so long as access to both the publisher and the
        /// `ros_message` is synchronized.
        /// That means that calling rcl_publish() from multiple threads is allowed, but
        /// calling rcl_publish() at the same time as non-thread safe publisher
        /// functions is not, e.g. calling rcl_publish() and rcl_publisher_fini()
        /// concurrently is not allowed.
        /// Before calling rcl_publish() the message can change and after calling
        /// rcl_publish() the message can change, but it cannot be changed during the
        /// publish call.
        /// The same `ros_message`, however, can be passed to multiple calls of
        /// rcl_publish() simultaneously, even if the publishers differ.
        /// The `ros_message` is unmodified by rcl_publish().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of publishers and messages, see above for more&lt;/i&gt;
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood):
        /// The blocking behavior of publish is a still a point of dispute.
        /// This section should be updated once the behavior is clearly defined.
        /// See: https://github.com/ros2/ros2/issues/255
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publish(RclNative.rcl_publisher_t* publisher, void* ros_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Publish a serialized message on a topic using a publisher.
        /// </summary>
        /// <param name="publisher">handle to the publisher which will do the publishing</param>
        /// <param name="serialized_message">pointer to the already serialized message in raw form</param>
        /// <param name="allocation">structure pointer, used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was published successfully, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the serialized message
        /// parameter and the type associate with the publisher (via the type support)
        /// match.
        /// Even though this call to publish takes an already serialized serialized message,
        /// the publisher has to register its type as a ROS known message type.
        /// Passing a serialized message from a different type leads to undefined behavior on the subscriber side.
        /// The publish call might be able to send any abitrary serialized message, it is however
        /// not garantueed that the subscriber side successfully deserializes this byte stream.Apart from this, the `publish_serialized` function has the same behavior as `rcl_publish`
        /// expect that no serialization step is done.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of publishers and messages, see above for more&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publish_serialized_message(RclNative.rcl_publisher_t* publisher, RclNative.rcl_serialized_message_t* serialized_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Publish a loaned message on a topic using a publisher.
        /// </summary>
        /// <param name="publisher">handle to the publisher which will do the publishing</param>
        /// <param name="ros_message">pointer to the previously borrow loaned message</param>
        /// <param name="allocation">structure pointer, used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was published successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// A previously borrowed loaned message can be sent via this call to `rcl_publish_loaned_message`.
        /// By calling this function, the ownership of the loaned message is getting transferred back
        /// to the middleware.
        /// The pointer to the `ros_message` is not guaranteed to be valid after as the middleware
        /// migth deallocate the memory for this message internally.
        /// It is thus recommended to call this function only in combination withApart from this, the `publish_loaned_message` function has the same behavior as `rcl_publish`
        /// except that no serialization step is done.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No [0]
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[0] the middleware might deallocate the loaned message.
        /// The RCL function however does not allocate any memory.&lt;/i&gt;&lt;i&gt;[1] for unique pairs of publishers and messages, see above for more&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="`rcl_borrow_loaned_message`."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publish_loaned_message(RclNative.rcl_publisher_t* publisher, void* ros_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
        /// </summary>
        /// <param name="publisher">handle to the publisher that needs liveliness to be asserted</param>
        /// <returns>`RCL_RET_OK` if the liveliness assertion was completed successfully, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
        /// this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
        /// of the system that this Node is still alive.
        /// This function must be called at least as often as the qos_profile's liveliness_lease_duration&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publisher_assert_liveliness(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Get the topic name for the publisher.
        /// </summary>
        /// <param name="publisher">pointer to the publisher</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the publisher's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - publisher is `NULL`
        /// - publisher is invalid (never called init, called fini, or invalid node)The returned string is only valid as long as the rcl_publisher_t is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_publisher_get_topic_name(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return the rcl publisher options.
        /// </summary>
        /// <param name="publisher">pointer to the publisher</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the publisher's internal options struct.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - publisher is `NULL`
        /// - publisher is invalid (never called init, called fini, or invalid node)The returned struct is only valid as long as the rcl_publisher_t is valid.
        /// The values in the struct may change if the options of the publisher change,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_publisher_options_t* rcl_publisher_get_options(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return the rmw publisher handle.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>rmw publisher handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - publisher is `NULL`
        /// - publisher is invalid (never called init, called fini, or invalid node)The returned handle is made invalid if the publisher is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// publisher as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the publisher using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_publisher_t* rcl_publisher_get_rmw_handle(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return the context associated with this publisher.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>context if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if the:
        /// - publisher is `NULL`
        /// - publisher is invalid (never called init, called fini, etc.)The returned context is made invalid if the publisher is finalized or if
        /// rcl_shutdown() is called.
        /// Therefore it is recommended to get the handle from the publisher using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_context_t* rcl_publisher_get_context(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return true if the publisher is valid, otherwise false.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>`true` if `publisher` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `publisher` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_publisher_is_valid(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return true if the publisher is valid except the context, otherwise false.
        /// </summary>
        /// <remarks>
        /// This is used in clean up functions that need to access the publisher, but do
        /// not need use any functions with the context.It is identical to rcl_publisher_is_valid except it ignores the state of the
        /// context associated with the publisher.
        /// </remarks>
        /// <seealso cref="rcl_publisher_is_valid()"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_publisher_is_valid_except_context(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Get the number of subscriptions matched to a publisher.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <param name="subscription_count">number of matched subscriptions</param>
        /// <returns>`RCL_RET_OK` if the count was retrieved, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_PUBLISHER_INVALID` if the publisher is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Used to get the internal count of subscriptions matched to a publisher.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] only if the underlying rmw doesn't make use of this feature &lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publisher_get_subscription_count(RclNative.rcl_publisher_t* publisher, RclNative.size_t* subscription_count);

        /// <summary>
        /// Get the actual qos settings of the publisher.
        /// </summary>
        /// <param name="publisher">pointer to the rcl publisher</param>
        /// <returns>qos struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// Used to get the actual qos settings of the publisher.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the publisher, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.
        /// The returned struct is only valid as long as the rcl_publisher_t is valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_qos_profile_t* rcl_publisher_get_actual_qos(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Check if publisher instance can loan messages.
        /// </summary>
        /// <remarks>
        /// Depending on the middleware and the message type, this will return true if the middleware
        /// can allocate a ROS message instance.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_publisher_can_loan_messages(RclNative.rcl_publisher_t* publisher);

        /// <summary>
        /// Return an rmw_message_sequence_t struct with members initialized to `NULL`
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_message_sequence_t rmw_get_zero_initialized_message_sequence();

        /// <summary>
        /// Initialize an rmw_message_sequence_t object.
        /// </summary>
        /// <param name="sequence">sequence object to be initialized.</param>
        /// <param name="size">capacity of the sequence to be allocated.</param>
        /// <param name="allocator">the allcator used to allocate memory.</param>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_message_sequence_init(RclNative.rmw_message_sequence_t* sequence, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize an rmw_message_sequence_t object.
        /// </summary>
        /// <param name="sequence">sequence object to be finalized.</param>
        /// <remarks>
        /// The rmw_message_sequence_t struct has members which require memory to be allocated to them
        /// before setting values.
        /// This function reclaims any allocated resources within the object and zeroes out all other
        /// members.Note: This will not call `fini` or deallocate the underlying message structures.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_message_sequence_fini(RclNative.rmw_message_sequence_t* sequence);

        /// <summary>
        /// Return an rmw_message_info_sequence_t struct with members initialized to `NULL`
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_message_info_sequence_t rmw_get_zero_initialized_message_info_sequence();

        /// <summary>
        /// Initialize an rmw_message_info_sequence_t object.
        /// </summary>
        /// <param name="sequence">sequence object to be initialized.</param>
        /// <param name="size">capacity of the sequence to be allocated.</param>
        /// <param name="allocator">the allcator used to allocate memory.</param>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_message_info_sequence_init(RclNative.rmw_message_info_sequence_t* sequence, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize an rmw_message_sequence_t object.
        /// </summary>
        /// <param name="sequence">sequence object to be finalized.</param>
        /// <remarks>
        /// The rmw_message_sequence_t struct has members which require memory to be allocated to them
        /// before setting values.
        /// This function reclaims any allocated resources within the object and zeroes out all other
        /// members.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_message_info_sequence_fini(RclNative.rmw_message_info_sequence_t* sequence);

        /// <summary>
        /// Return a rcl_subscription_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_subscription_t before passing to
        /// rcl_subscription_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_subscription_t rcl_get_zero_initialized_subscription();

        /// <summary>
        /// Initialize a ROS subscription.
        /// </summary>
        /// <param name="subscription">preallocated subscription structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the topic's type</param>
        /// <param name="topic_name">the name of the topic</param>
        /// <param name="options">subscription options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if subscription was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the subcription is already initialized, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_TOPIC_NAME_INVALID` if the given topic name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_subscription_t, it can be used to take
        /// messages of the given type to the given topic using rcl_take().The given rcl_node_t must be valid and the resulting rcl_subscription_t is
        /// only valid as long as the given rcl_node_t remains valid.The rosidl_message_type_support_t is obtained on a per .msg type basis.
        /// When the user defines a ROS message, code is generated which provides the
        /// required rosidl_message_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;
        /// const rosidl_message_type_support_t * string_ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// ```For C++ a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _runtime_cpp/message_type_support.hpp&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msgs/string.hpp&gt;
        /// using rosidl_typesupport_cpp::get_message_type_support_handle;
        /// const rosidl_message_type_support_t * string_ts =
        /// get_message_type_support_handle
        /// &lt;std
        /// _msgs::msg::String&gt;();
        /// ```The rosidl_message_type_support_t object contains message type specific
        /// information used to publish messages.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when (de)initializing the
        /// subscription to allocate space for incidental things, e.g. the topic
        /// name string.Expected usage (for C messages):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/message_type_support_struct.h&gt;
        /// #include 
        /// &lt;std
        /// _msgs/msg/string.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_message_type_support_t * ts =
        /// ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String);
        /// rcl_subscription_t subscription = rcl_get_zero_initialized_subscription();
        /// rcl_subscription_options_t subscription_ops = rcl_subscription_get_default_options();
        /// ret = rcl_subscription_init(
        /// &amp;subscription
        /// , 
        /// &amp;node
        /// , ts, "chatter", 
        /// &amp;subscription
        /// _ops);
        /// // ... error handling, and when finished deinitialization
        /// ret = rcl_subscription_fini(
        /// &amp;subscription
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_subscription_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_expand_topic_name"/>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// For C a macro can be used (for example `std_msgs/String`):
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_subscription_init(RclNative.rcl_subscription_t* subscription, RclNative.rcl_node_t* node, RclNative.rosidl_message_type_support_t* type_support, byte* topic_name, RclNative.rcl_subscription_options_t* options);

        /// <summary>
        /// Finalize a rcl_subscription_t.
        /// </summary>
        /// <param name="subscription">handle to the subscription to be deinitialized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the subscription</param>
        /// <returns>`RCL_RET_OK` if subscription was deinitialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer be subscribed on this topic
        /// (assuming this is the only subscription on this topic in this node).After calling, calls to rcl_wait and rcl_take will fail when using this
        /// subscription.
        /// Additioanlly rcl_wait will be interrupted if currently blocking.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_subscription_fini(RclNative.rcl_subscription_t* subscription, RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the default subscription options in a rcl_subscription_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_default
        /// - allocator = rcl_get_default_allocator()
        /// - rmw_subscription_options = rmw_get_default_subscription_options();
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_subscription_options_t rcl_subscription_get_default_options();

        /// <summary>
        /// Take a ROS message from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take</param>
        /// <param name="ros_message">type-erased ptr to a allocated ROS message</param>
        /// <param name="message_info">rmw struct which contains meta-data for the message</param>
        /// <param name="allocation">structure pointer used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
        /// occurred in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_message
        /// argument and the type associated with the subscription, via the type
        /// support, match.
        /// Passing a different type to rcl_take produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.TODO(wjwwood) blocking of take?
        /// TODO(wjwwood) pre-, during-, and post-conditions for message ownership?
        /// TODO(wjwwood) is rcl_take thread-safe?
        /// TODO(wjwwood) Should there be an rcl_message_info_t?The ros_message pointer should point to an already allocated ROS message
        /// struct of the correct type, into which the taken ROS message will be copied
        /// if one is available.
        /// If taken is false after calling, then the ROS message will be unmodified.The taken boolean may be false even if a wait set reports that the
        /// subscription was ready to be taken from in some cases, e.g. when the
        /// state of the subscription changes it may cause the wait set to wake up
        /// but subsequent takes to fail to take anything.If allocation is required when taking the message, e.g. if space needs to
        /// be allocated for a dynamically sized array in the target message, then the
        /// allocator given in the subscription options is used.The rmw_message_info struct contains meta information about this particular
        /// message instance, like what the GUID of the publisher which published it
        /// originally or whether or not the message received from within the same
        /// process.
        /// The message_info argument should be an already allocated rmw_message_info_t
        /// structure.
        /// Passing `NULL` for message_info will result in the argument being ignored.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the message, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take(RclNative.rcl_subscription_t* subscription, void* ros_message, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take a sequence of messages from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take.</param>
        /// <param name="count">number of messages to attempt to take.</param>
        /// <param name="message_sequence">pointer to a (pre-allocated) message sequence.</param>
        /// <param name="message_info_sequence">pointer to a (pre-allocated) message info sequence.</param>
        /// <param name="allocation">structure pointer used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if one or more messages was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
        /// occurred in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// In contrast to `rcl_take`, this function can take multiple messages at
        /// the same time.
        /// It is the job of the caller to ensure that the type of the message_sequence
        /// argument and the type associated with the subscription, via the type
        /// support, match.The message_sequence pointer should point to an already allocated sequence
        /// of ROS messages of the correct type, into which the taken ROS messages will
        /// be copied if messages are available.
        /// The message_sequence `size` member will be set to the number of messages
        /// correctly taken.The rmw_message_info_sequence struct contains meta information about the
        /// corresponding message instance index.
        /// The message_info_sequence argument should be an already allocated
        /// rmw_message_info_sequence_t structure.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if storage in the serialized_message is insufficient&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_sequence(RclNative.rcl_subscription_t* subscription, RclNative.size_t count, RclNative.rmw_message_sequence_t* message_sequence, RclNative.rmw_message_info_sequence_t* message_info_sequence, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take a serialized raw message from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take</param>
        /// <param name="serialized_message">pointer to a (pre-allocated) serialized message.</param>
        /// <param name="message_info">rmw struct which contains meta-data for the message</param>
        /// <param name="allocation">structure pointer used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the message was published, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
        /// occurred in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// In contrast to `rcl_take`, this function stores the taken message in
        /// its raw binary representation.
        /// It is the job of the caller to ensure that the type associate with the subscription
        /// matches, and can optionally be deserialized into its ROS message via, the correct
        /// type support.
        /// If the `serialized_message` parameter contains enough preallocated memory, the incoming
        /// message can be taken without any additional memory allocation.
        /// If not, the function will dynamically allocate enough memory for the message.
        /// Passing a different type to rcl_take produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.Apart from the differences above, this function behaves like `rcl_take`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if storage in the serialized_message is insufficient&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_serialized_message(RclNative.rcl_subscription_t* subscription, RclNative.rcl_serialized_message_t* serialized_message, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take a loaned message from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take</param>
        /// <param name="loaned_message">a pointer to the loaned messages.</param>
        /// <param name="message_info">rmw struct which contains meta-data for the message.</param>
        /// <param name="allocation">structure pointer used for memory preallocation (may be NULL)</param>
        /// <returns>`RCL_RET_OK` if the loaned message sequence was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_TAKE_FAILED` if take failed but no error
        /// occurred in the middleware, or</returns>
        /// <returns>`RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Depending on the middleware, incoming messages can be loaned to the user's callback
        /// without further copying.
        /// The implicit contract here is that the middleware owns the memory allocated for this message.
        /// The user must not destroy the message, but rather has to return it with a call to&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_return_loaned_message to the middleware."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_loaned_message(RclNative.rcl_subscription_t* subscription, void** loaned_message, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Return a loaned message from a topic using a rcl subscription.
        /// </summary>
        /// <param name="subscription">the handle to the subscription from which to take</param>
        /// <param name="loaned_message">a pointer to the loaned messages.</param>
        /// <returns>`RCL_RET_OK` if the message was published, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_UNIMPLEMENTED` if the middleware does not support that feature, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// If a loaned message was previously obtained from the middleware with a call to&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="The user must not delete the message.that the user no longer needs that memory.rcl_take_loaned_message, this message has to be returned to indicate to the middleware"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_return_loaned_message_from_subscription(RclNative.rcl_subscription_t* subscription, void* loaned_message);

        /// <summary>
        /// Get the topic name for the subscription.
        /// </summary>
        /// <param name="subscription">the pointer to the subscription</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the subscription's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - subscription is `NULL`
        /// - subscription is invalid (never called init, called fini, or invalid)The returned string is only valid as long as the subscription is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_subscription_get_topic_name(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Return the rcl subscription options.
        /// </summary>
        /// <param name="subscription">pointer to the subscription</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the subscription's internal options struct.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - subscription is `NULL`
        /// - subscription is invalid (never called init, called fini, or invalid)The returned struct is only valid as long as the subscription is valid.
        /// The values in the struct may change if the subscription's options change,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_subscription_options_t* rcl_subscription_get_options(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Return the rmw subscription handle.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <returns>rmw subscription handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - subscription is `NULL`
        /// - subscription is invalid (never called init, called fini, or invalid)The returned handle is made invalid if the subscription is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// subscription as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the subscription using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_subscription_t* rcl_subscription_get_rmw_handle(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Check that the subscription is valid.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <returns>`true` if `subscription` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `subscription` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_subscription_is_valid(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Get the number of publishers matched to a subscription.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <param name="publisher_count">number of matched publishers</param>
        /// <returns>`RCL_RET_OK` if the count was retrieved, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SUBSCRIPTION_INVALID` if the subscription is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Used to get the internal count of publishers matched to a subscription.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] only if the underlying rmw doesn't make use of this feature &lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rcl_subscription_get_publisher_count(RclNative.rcl_subscription_t* subscription, RclNative.size_t* publisher_count);

        /// <summary>
        /// Get the actual qos settings of the subscription.
        /// </summary>
        /// <param name="subscription">pointer to the rcl subscription</param>
        /// <returns>qos struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// Used to get the actual qos settings of the subscription.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the subscription, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.
        /// The returned struct is only valid as long as the rcl_subscription_t is valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_qos_profile_t* rcl_subscription_get_actual_qos(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Check if subscription instance can loan messages.
        /// </summary>
        /// <remarks>
        /// Depending on the middleware and the message type, this will return true if the middleware
        /// can allocate a ROS message instance.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_subscription_can_loan_messages(RclNative.rcl_subscription_t* subscription);

        /// <summary>
        /// Get the service type support handle specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to service type support</param>
        /// <param name="identifier">The typesupport identifier to get the handle function for</param>
        /// <returns>The associated service typesupport handle function.</returns>
        /// <remarks>
        /// The handle's message typesupport identifier function is returned or if the parameters are NULL
        /// then an assert will happen.
        /// </remarks>
        [DllImport("get", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_service_type_support_t* get_service_typesupport_handle(RclNative.rosidl_service_type_support_t* handle, byte* identifier);

        /// <summary>
        /// Get the service type support handle function specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to service type support</param>
        /// <param name="identifier">The typesupport identifier to get the handle function for</param>
        /// <returns>if the identifier match's the handle's identifier then the handle's function
        /// is returned.</returns>
        /// <remarks>
        /// If the identifier is the same as this handle's typesupport_identifier the handle is simply
        /// returned or if the parameters are NULL then an assert will happen.
        /// </remarks>
        [DllImport("get", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_service_type_support_t* get_service_typesupport_handle_function(RclNative.rosidl_service_type_support_t* handle, byte* identifier);

        /// <summary>
        /// Return a rcl_client_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_client_t before passing to
        /// rcl_client_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_client_t rcl_get_zero_initialized_client();

        /// <summary>
        /// Initialize a rcl client.
        /// </summary>
        /// <param name="client">preallocated rcl_client_t structure</param>
        /// <param name="node">valid rcl_node_t</param>
        /// <param name="type_support">type support object for the service's type</param>
        /// <param name="service_name">the name of the service to request</param>
        /// <param name="options">client options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if the client was initialized successfully, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the client is already initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_client_t, it can be used to send
        /// requests of the given type by calling rcl_send_request().
        /// If the request is received by a (possibly remote) service and if the service
        /// sends a response, the client can access the response through
        /// rcl_take_response() once the response is available to the client.The given rcl_node_t must be valid and the resulting rcl_client_t is only
        /// valid as long as the given rcl_node_t remains valid.The rosidl_service_type_support_t is obtained on a per `.srv` type basis.
        /// When the user defines a ROS service, code is generated which provides the
        /// required rosidl_service_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `example_interfaces/AddTwoInts`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _typesupport_cpp/service_type_support.hpp&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.hpp&gt;using rosidl_typesupport_cpp::get_service_type_support_handle;
        /// const rosidl_service_type_support_t * ts =
        /// get_service_type_support_handle
        /// &lt;example
        /// _interfaces::srv::AddTwoInts&gt;();
        /// ```The rosidl_service_type_support_t object contains service type specific
        /// information used to send or take requests and responses.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// client to allocate space for incidentals, e.g. the service name string.Expected usage (for C services):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// rcl_client_t client = rcl_get_zero_initialized_client();
        /// rcl_client_options_t client_ops = rcl_client_get_default_options();
        /// ret = rcl_client_init(
        /// &amp;client
        /// , 
        /// &amp;node
        /// , ts, "add_two_ints", 
        /// &amp;client
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_client_fini(
        /// &amp;client
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_client_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_expand_topic_name"/>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_client_init(RclNative.rcl_client_t* client, RclNative.rcl_node_t* node, RclNative.rosidl_service_type_support_t* type_support, byte* service_name, RclNative.rcl_client_options_t* options);

        /// <summary>
        /// Finalize a rcl_client_t.
        /// </summary>
        /// <param name="client">handle to the client to be finalized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the client</param>
        /// <returns>`RCL_RET_OK` if client was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function, calls to rcl_send_request() and
        /// rcl_take_response() will fail when using this client.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_client_fini(RclNative.rcl_client_t* client, RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the default client options in a rcl_client_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_services_default
        /// - allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_client_options_t rcl_client_get_default_options();

        /// <summary>
        /// Send a ROS request using a client.
        /// </summary>
        /// <param name="client">handle to the client which will make the response</param>
        /// <param name="ros_request">type-erased pointer to the ROS request message</param>
        /// <param name="sequence_number">the sequence number</param>
        /// <returns>`RCL_RET_OK` if the request was sent successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_INVALID` if the client is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_request`
        /// parameter and the type associate with the client (via the type support)
        /// match.
        /// Passing a different type to `send_request` produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.rcl_send_request() is an non-blocking call.The ROS request message given by the `ros_request` void pointer is always
        /// owned by the calling code, but should remain constant during `send_request`.This function is thread safe so long as access to both the client and the
        /// `ros_request` is synchronized.
        /// That means that calling rcl_send_request() from multiple threads is allowed,
        /// but calling rcl_send_request() at the same time as non-thread safe client
        /// functions is not, e.g. calling rcl_send_request() and rcl_client_fini()
        /// concurrently is not allowed.
        /// Before calling rcl_send_request() the message can change and after calling
        /// rcl_send_request() the message can change, but it cannot be changed during
        /// the `send_request` call.
        /// The same `ros_request`, however, can be passed to multiple calls of
        /// rcl_send_request() simultaneously, even if the clients differ.
        /// The `ros_request` is unmodified by rcl_send_request().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of clients and requests, see above for more&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_send_request(RclNative.rcl_client_t* client, void* ros_request, long* sequence_number);

        /// <summary>
        /// Take a ROS response using a client
        /// </summary>
        /// <param name="client">handle to the client which will take the response</param>
        /// <param name="request_header">pointer to the request header</param>
        /// <param name="ros_response">type-erased pointer to the ROS response message</param>
        /// <returns>`RCL_RET_OK` if the response was taken successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_INVALID` if the client is invalid, or</returns>
        /// <returns>`RCL_RET_CLIENT_TAKE_FAILED` if take failed but no error occurred
        /// in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_response`
        /// parameter and the type associate with the client (via the type support)
        /// match.
        /// Passing a different type to take_response produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.
        /// The request_header is an rmw struct for meta-information about the request
        /// sent (e.g. the sequence number).
        /// The caller must provide a pointer to an allocated struct.
        /// This function will populate the struct's fields.
        /// `ros_response` should point to an already allocated ROS response message
        /// struct of the correct type, into which the response from the service will be
        /// copied.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the message, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_response_with_info(RclNative.rcl_client_t* client, RclNative.rmw_service_info_t* request_header, void* ros_response);

        /// <summary>
        /// backwards compatibility function that takes a rmw_request_id_t only
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_response(RclNative.rcl_client_t* client, RclNative.rmw_request_id_t* request_header, void* ros_response);

        /// <summary>
        /// Get the name of the service that this client will request a response from.
        /// </summary>
        /// <param name="client">pointer to the client</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the client's internal service name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - client is `NULL`
        /// - client is invalid (never called init, called fini, or invalid node)The returned string is only valid as long as the rcl_client_t is valid.
        /// The value of the string may change if the service name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_client_get_service_name(RclNative.rcl_client_t* client);

        /// <summary>
        /// Return the rcl client options.
        /// </summary>
        /// <param name="client">pointer to the client</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the client's internal options struct.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - client is `NULL`
        /// - client is invalid (never called init, called fini, or invalid node)The returned struct is only valid as long as the rcl_client_t is valid.
        /// The values in the struct may change if the options of the client change,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_client_options_t* rcl_client_get_options(RclNative.rcl_client_t* client);

        /// <summary>
        /// Return the rmw client handle.
        /// </summary>
        /// <param name="client">pointer to the rcl client</param>
        /// <returns>rmw client handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - client is `NULL`
        /// - client is invalid (never called init, called fini, or invalid node)The returned handle is made invalid if the client is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// client as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the client using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_client_t* rcl_client_get_rmw_handle(RclNative.rcl_client_t* client);

        /// <summary>
        /// Check that the client is valid.
        /// </summary>
        /// <param name="client">pointer to the rcl client</param>
        /// <returns>`true` if `client` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if client is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_client_is_valid(RclNative.rcl_client_t* client);

        /// <summary>
        /// Return a rcl_guard_condition_t struct with members set to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_guard_condition_t rcl_get_zero_initialized_guard_condition();

        /// <summary>
        /// Initialize a rcl guard_condition.
        /// </summary>
        /// <param name="guard_condition">preallocated guard_condition structure</param>
        /// <param name="context">the context instance with which the guard condition
        /// should be associated</param>
        /// <param name="options">the guard_condition's options</param>
        /// <returns>`RCL_RET_OK` if guard_condition was initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_guard_condition_t, it can be passed to
        /// rcl_wait() and then concurrently it can be triggered to wake-up rcl_wait().Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;// ... error handling
        /// rcl_guard_condition_t guard_condition = rcl_get_zero_initialized_guard_condition();
        /// // ... customize guard condition options
        /// rcl_ret_t ret = rcl_guard_condition_init(
        /// &amp;guard
        /// _condition, context, rcl_guard_condition_get_default_options());
        /// // ... error handling, and on shutdown do deinitialization:
        /// ret = rcl_guard_condition_fini(
        /// &amp;guard
        /// _condition);
        /// // ... error handling for rcl_guard_condition_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_guard_condition_init(RclNative.rcl_guard_condition_t* guard_condition, RclNative.rcl_context_t* context, RclNative.rcl_guard_condition_options_t options);

        /// <summary>
        /// Same as rcl_guard_condition_init(), but reusing an existing rmw handle.
        /// </summary>
        /// <param name="guard_condition">preallocated guard_condition structure</param>
        /// <param name="rmw_guard_condition">existing rmw guard condition to reuse</param>
        /// <param name="context">the context instance with which the rmw guard condition
        /// was initialized with, i.e. the rmw context inside rcl context needs to
        /// match rmw context in rmw guard condition</param>
        /// <param name="options">the guard_condition's options</param>
        /// <returns>`RCL_RET_OK` if guard_condition was initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the guard condition is already initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// In addition to the documentation for rcl_guard_condition_init(), the
        /// `rmw_guard_condition` parameter must not be `NULL` and must point to a valid
        /// rmw guard condition.Also the life time of the rcl guard condition is tied to the life time of
        /// the rmw guard condition.
        /// So if the rmw guard condition is destroyed before the rcl guard condition,
        /// the rcl guard condition becomes invalid.Similarly if the resulting rcl guard condition is fini'ed before the rmw
        /// guard condition, then the rmw guard condition is no longer valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_guard_condition_init_from_rmw(RclNative.rcl_guard_condition_t* guard_condition, RclNative.rmw_guard_condition_t* rmw_guard_condition, RclNative.rcl_context_t* context, RclNative.rcl_guard_condition_options_t options);

        /// <summary>
        /// Finalize a rcl_guard_condition_t.
        /// </summary>
        /// <param name="guard_condition">handle to the guard_condition to be finalized</param>
        /// <returns>`RCL_RET_OK` if guard_condition was finalized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, calls to rcl_trigger_guard_condition() will fail when using
        /// this guard condition.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] specifically not thread-safe with rcl_trigger_guard_condition()&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_guard_condition_fini(RclNative.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return the default options in a rcl_guard_condition_options_t struct.
        /// </summary>
        /// <remarks>
        /// The defaults are:- allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_guard_condition_options_t rcl_guard_condition_get_default_options();

        /// <summary>
        /// Trigger a rcl guard condition.
        /// </summary>
        /// <param name="guard_condition">handle to the guard_condition to be triggered</param>
        /// <returns>`RCL_RET_OK` if the guard condition was triggered, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function can fail, and return RCL_RET_INVALID_ARGUMENT, if the:
        /// - guard condition is `NULL`
        /// - guard condition is invalid (never called init or called fini)A guard condition can be triggered from any thread.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] it can be called concurrently with itself, even on the same guard condition&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_trigger_guard_condition(RclNative.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return the guard condition options.
        /// </summary>
        /// <param name="guard_condition">pointer to the rcl guard_condition</param>
        /// <returns>rcl guard condition options if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// Returned is a pointer to the internally held rcl_guard_condition_options_t.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - guard_condition is `NULL`
        /// - guard_condition is invalid (never called init, called fini, or invalid node)The returned pointer is made invalid if the guard condition is finalized.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_guard_condition_options_t* rcl_guard_condition_get_options(RclNative.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return the rmw guard condition handle.
        /// </summary>
        /// <param name="guard_condition">pointer to the rcl guard_condition</param>
        /// <returns>rmw guard condition handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - guard_condition is `NULL`
        /// - guard_condition is invalid (never called init, called fini, or invalid node)The returned handle is made invalid if the guard condition is finalized or
        /// if rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// guard condition as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the guard condition using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_guard_condition_t* rcl_guard_condition_get_rmw_handle(RclNative.rcl_guard_condition_t* guard_condition);

        /// <summary>
        /// Return a rcl_service_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_service_t before passing to
        /// rcl_service_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_service_t rcl_get_zero_initialized_service();

        /// <summary>
        /// Initialize a rcl service.
        /// </summary>
        /// <param name="service">preallocated service structure</param>
        /// <param name="node">valid rcl node handle</param>
        /// <param name="type_support">type support object for the service's type</param>
        /// <param name="service_name">the name of the service</param>
        /// <param name="options">service options, including quality of service settings</param>
        /// <returns>`RCL_RET_OK` if service was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the service is already initialized, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SERVICE_NAME_INVALID` if the given service name is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling this function on a rcl_service_t, it can be used to take
        /// requests of the given type to the given topic using rcl_take_request().
        /// It can also send a response to a request using rcl_send_response().The given rcl_node_t must be valid and the resulting rcl_service_t is
        /// only valid as long as the given rcl_node_t remains valid.The rosidl_service_type_support_t is obtained on a per .srv type basis.
        /// When the user defines a ROS service, code is generated which provides the
        /// required rosidl_service_type_support_t object.
        /// This object can be obtained using a language appropriate mechanism.For C, a macro can be used (for example `example_interfaces/AddTwoInts`):```c
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// ```For C++, a template function is used:```cpp
        /// #include 
        /// &lt;rosidl
        /// _runtime_cpp/service_type_support.hpp&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;
        /// using rosidl_typesupport_cpp::get_service_type_support_handle;
        /// const rosidl_service_type_support_t * ts =
        /// get_service_type_support_handle
        /// &lt;example
        /// _interfaces::srv::AddTwoInts&gt;();
        /// ```The rosidl_service_type_support_t object contains service type specific
        /// information used to send or take requests and responses.The topic name must be a c string which follows the topic and service name
        /// format rules for unexpanded names, also known as non-fully qualified names:The options struct allows the user to set the quality of service settings as
        /// well as a custom allocator which is used when initializing/finalizing the
        /// client to allocate space for incidentals, e.g. the service name string.Expected usage (for C services):```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;
        /// #include 
        /// &lt;rosidl
        /// _runtime_c/service_type_support_struct.h&gt;
        /// #include 
        /// &lt;example
        /// _interfaces/srv/add_two_ints.h&gt;rcl_node_t node = rcl_get_zero_initialized_node();
        /// rcl_node_options_t node_ops = rcl_node_get_default_options();
        /// rcl_ret_t ret = rcl_node_init(
        /// &amp;node
        /// , "node_name", "/my_namespace", 
        /// &amp;node
        /// _ops);
        /// // ... error handling
        /// const rosidl_service_type_support_t * ts =
        /// ROSIDL_GET_SRV_TYPE_SUPPORT(example_interfaces, srv, AddTwoInts);
        /// rcl_service_t service = rcl_get_zero_initialized_service();
        /// rcl_service_options_t service_ops = rcl_service_get_default_options();
        /// ret = rcl_service_init(
        /// &amp;service
        /// , 
        /// &amp;node
        /// , ts, "add_two_ints", 
        /// &amp;service
        /// _ops);
        /// // ... error handling, and on shutdown do finalization:
        /// ret = rcl_service_fini(
        /// &amp;service
        /// , 
        /// &amp;node
        /// );
        /// // ... error handling for rcl_service_fini()
        /// ret = rcl_node_fini(
        /// &amp;node
        /// );
        /// // ... error handling for rcl_node_fini()
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <seealso cref="rcl_expand_topic_name"/>
        /// <todo>
        /// TODO(wjwwood) write these instructions once and link to it instead
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_service_init(RclNative.rcl_service_t* service, RclNative.rcl_node_t* node, RclNative.rosidl_service_type_support_t* type_support, byte* service_name, RclNative.rcl_service_options_t* options);

        /// <summary>
        /// Finalize a rcl_service_t.
        /// </summary>
        /// <param name="service">handle to the service to be deinitialized</param>
        /// <param name="node">a valid (not finalized) handle to the node used to create the service</param>
        /// <returns>`RCL_RET_OK` if service was deinitialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// After calling, the node will no longer listen for requests for this service.
        /// (assuming this is the only service of this type in this node).After calling, calls to rcl_wait(), rcl_take_request(), and
        /// rcl_send_response() will fail when using this service.
        /// Additionally rcl_wait() will be interrupted if currently blocking.
        /// However, the given node handle is still valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_service_fini(RclNative.rcl_service_t* service, RclNative.rcl_node_t* node);

        /// <summary>
        /// Return the default service options in a rcl_service_options_t.
        /// </summary>
        /// <remarks>
        /// The defaults are:- qos = rmw_qos_profile_services_default
        /// - allocator = rcl_get_default_allocator()
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_service_options_t rcl_service_get_default_options();

        /// <summary>
        /// Take a pending ROS request using a rcl service.
        /// </summary>
        /// <param name="service">the handle to the service from which to take</param>
        /// <param name="request_header">ptr to the struct holding metadata about the request</param>
        /// <param name="ros_request">type-erased ptr to an allocated ROS request message</param>
        /// <returns>`RCL_RET_OK` if the request was taken, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_SERVICE_TAKE_FAILED` if take failed but no error occurred
        /// in the middleware, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the ros_request
        /// argument and the type associate with the service, via the type
        /// support, match.
        /// Passing a different type to rcl_take produces undefined behavior and cannot
        /// be checked by this function and therefore no deliberate error will occur.TODO(jacquelinekay) blocking of take?
        /// TODO(jacquelinekay) pre-, during-, and post-conditions for message ownership?
        /// TODO(jacquelinekay) is rcl_take_request thread-safe?
        /// TODO(jacquelinekay) Should there be an rcl_request_id_t?The ros_request pointer should point to an already allocated ROS request message
        /// struct of the correct type, into which the taken ROS request will be copied
        /// if one is available.
        /// If taken is false after calling, then the ROS request will be unmodified.If allocation is required when taking the request, e.g. if space needs to
        /// be allocated for a dynamically sized array in the target message, then the
        /// allocator given in the service options is used.request_header is a pointer to pre-allocated a rmw struct containing
        /// meta-information about the request (e.g. the sequence number).&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] only if required when filling the request, avoided for fixed sizes&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_request_with_info(RclNative.rcl_service_t* service, RclNative.rmw_service_info_t* request_header, void* ros_request);

        /// <summary>
        /// backwards compatibility version that takes a request_id only
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_request(RclNative.rcl_service_t* service, RclNative.rmw_request_id_t* request_header, void* ros_request);

        /// <summary>
        /// Send a ROS response to a client using a service.
        /// </summary>
        /// <param name="service">handle to the service which will make the response</param>
        /// <param name="response_header">ptr to the struct holding metadata about the request ID</param>
        /// <param name="ros_response">type-erased pointer to the ROS response message</param>
        /// <returns>`RCL_RET_OK` if the response was sent successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_SERVICE_INVALID` if the service is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// It is the job of the caller to ensure that the type of the `ros_response`
        /// parameter and the type associate with the service (via the type support)
        /// match.
        /// Passing a different type to send_response produces undefined behavior and
        /// cannot be checked by this function and therefore no deliberate error will
        /// occur.send_response() is an non-blocking call.The ROS response message given by the `ros_response` void pointer is always
        /// owned by the calling code, but should remain constant during
        /// rcl_send_response().This function is thread safe so long as access to both the service and the
        /// `ros_response` is synchronized.
        /// That means that calling rcl_send_response() from multiple threads is
        /// allowed, but calling rcl_send_response() at the same time as non-thread safe
        /// service functions is not, e.g. calling rcl_send_response() and
        /// rcl_service_fini() concurrently is not allowed.
        /// Before calling rcl_send_response() the message can change and after calling
        /// rcl_send_response() the message can change, but it cannot be changed during
        /// the rcl_send_response() call.
        /// The same `ros_response`, however, can be passed to multiple calls of
        /// rcl_send_response() simultaneously, even if the services differ.
        /// The `ros_response` is unmodified by rcl_send_response().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// &lt;i&gt;[1] for unique pairs of services and responses, see above for more&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_send_response(RclNative.rcl_service_t* service, RclNative.rmw_request_id_t* response_header, void* ros_response);

        /// <summary>
        /// Get the topic name for the service.
        /// </summary>
        /// <param name="service">the pointer to the service</param>
        /// <returns>name string if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the service's internal topic name string.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - service is `NULL`
        /// - service is invalid (never called init, called fini, or invalid)The returned string is only valid as long as the service is valid.
        /// The value of the string may change if the topic name changes, and therefore
        /// copying the string is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rcl_service_get_service_name(RclNative.rcl_service_t* service);

        /// <summary>
        /// Return the rcl service options.
        /// </summary>
        /// <param name="service">pointer to the service</param>
        /// <returns>options struct if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// This function returns the service's internal options struct.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - service is `NULL`
        /// - service is invalid (never called init, called fini, or invalid)The returned struct is only valid as long as the service is valid.
        /// The values in the struct may change if the service's options change,
        /// and therefore copying the struct is recommended if this is a concern.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_service_options_t* rcl_service_get_options(RclNative.rcl_service_t* service);

        /// <summary>
        /// Return the rmw service handle.
        /// </summary>
        /// <param name="service">pointer to the rcl service</param>
        /// <returns>rmw service handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - service is `NULL`
        /// - service is invalid (never called init, called fini, or invalid)The returned handle is made invalid if the service is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// service as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the service using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_service_t* rcl_service_get_rmw_handle(RclNative.rcl_service_t* service);

        /// <summary>
        /// Check that the service is valid.
        /// </summary>
        /// <param name="service">pointer to the rcl service</param>
        /// <returns>`true` if `service` is valid, otherwise `false`</returns>
        /// <remarks>
        /// The bool returned is `false` if `service` is invalid.
        /// The bool returned is `true` otherwise.
        /// In the case where `false` is to be returned, an error message is set.
        /// This function cannot fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_service_is_valid(RclNative.rcl_service_t* service);

        /// <summary>
        /// Check if the clock has valid values.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being queried</param>
        /// <returns>true if the source is believed to be valid, otherwise return false.</returns>
        /// <remarks>
        /// This function returns true if the time source appears to be valid.
        /// It will check that the type is not uninitialized, and that pointers
        /// are not invalid.
        /// Note that if data is uninitialized it may give a false positive.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_clock_valid(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Initialize a clock based on the passed type.
        /// </summary>
        /// <param name="clock_type">the type identifying the time source to provide</param>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <param name="allocator">The allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will allocate all necessary internal structures, and initialize variables.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes [1]
        /// Thread-Safe        | No [2]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] If `clock_type` is `RCL_ROS_TIME`&lt;/i&gt;&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_clock_init(RclNative.rcl_clock_type_t clock_type, RclNative.rcl_clock_t* clock, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a clock.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being finalized</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully finalized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will deallocate all necessary internal structures, and clean up any variables.
        /// It can be combined with any of the init functions.Passing a clock with type RCL_CLOCK_UNINITIALIZED will result in
        /// RCL_RET_INVALID_ARGUMENT being returned.This function is not thread-safe with any other function operating on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_clock_fini(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Initialize a clock as a RCL_ROS_TIME time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <param name="allocator">The allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will allocate all necessary internal structures, and initialize variables.
        /// It is specifically setting up a RCL_ROS_TIME time source.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_ros_clock_init(RclNative.rcl_clock_t* clock, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a clock as a `RCL_ROS_TIME` time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully finalized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will deallocate all necessary internal structures, and clean up any variables.
        /// It is specifically setting up a `RCL_ROS_TIME` time source. It is expected
        /// to be paired with the init fuction.This function is not thread-safe with any other function operating on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_ros_clock_fini(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Initialize a clock as a `RCL_STEADY_TIME` time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <param name="allocator">The allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will allocate all necessary internal structures, and initialize variables.
        /// It is specifically setting up a `RCL_STEADY_TIME` time source.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_steady_clock_init(RclNative.rcl_clock_t* clock, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a clock as a `RCL_STEADY_TIME` time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully finalized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// Finalize the clock as a `RCL_STEADY_TIME` time source.This will deallocate all necessary internal structures, and clean up any variables.
        /// It is specifically setting up a steady time source. It is expected to be
        /// paired with the init fuction.This function is not thread-safe with any other function operating on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_steady_clock_fini(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Initialize a clock as a `RCL_SYSTEM_TIME` time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized</param>
        /// <param name="allocator">The allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully initialized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// Initialize the clock as a `RCL_SYSTEM_TIME` time source.This will allocate all necessary internal structures, and initialize variables.
        /// It is specifically setting up a system time source.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_system_clock_init(RclNative.rcl_clock_t* clock, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a clock as a `RCL_SYSTEM_TIME` time source.
        /// </summary>
        /// <param name="clock">the handle to the clock which is being initialized.</param>
        /// <returns>`RCL_RET_OK` if the time source was successfully finalized, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// Finalize the clock as a `RCL_SYSTEM_TIME` time source.This will deallocate all necessary internal structures, and clean up any variables.
        /// It is specifically setting up a system time source. It is expected to be paired with
        /// the init fuction.This function is not thread-safe with any function operating on the same clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_system_clock_fini(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Compute the difference between two time points
        /// </summary>
        /// <param name="start">The time point for the start of the duration.</param>
        /// <param name="finish">The time point for the end of the duration.</param>
        /// <param name="delta">The duration between the start and finish.</param>
        /// <returns>`RCL_RET_OK` if the difference was computed successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function takes two time points and computes the duration between them.
        /// The two time points must be using the same time abstraction, and the
        /// resultant duration will also be of the same abstraction.The value will be computed as duration = finish - start. If start is after
        /// finish the duration will be negative.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_difference_times(RclNative.rcl_time_point_t* start, RclNative.rcl_time_point_t* finish, RclNative.rcl_duration_t* delta);

        /// <summary>
        /// Fill the time point value with the current value of the associated clock.
        /// </summary>
        /// <param name="clock">The time source from which to set the value.</param>
        /// <param name="time_point_value">The time_point value to populate.</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will populate the data of the time_point_value object with the
        /// current value from it's associated time abstraction.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes [1]
        /// Lock-Free          | Yes&lt;i&gt;[1] If `clock` is of `RCL_ROS_TIME` type.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_clock_get_now(RclNative.rcl_clock_t* clock, RclNative.rcl_time_point_value_t* time_point_value);

        /// <summary>
        /// Enable the ROS time abstraction override.
        /// </summary>
        /// <param name="clock">The clock to enable.</param>
        /// <returns>`RCL_RET_OK` if the time source was enabled successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This method will enable the ROS time abstraction override values,
        /// such that the time source will report the set value instead of falling
        /// back to system time.This function is not thread-safe with `rcl_clock_add_jump_callback`,
        /// nor `rcl_clock_remove_jump_callback` functions when used on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence [1]
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [2]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Only applies to the function itself, as jump callbacks may not abide to it.&lt;/i&gt;&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_enable_ros_time_override(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Disable the ROS time abstraction override.
        /// </summary>
        /// <param name="clock">The clock to disable.</param>
        /// <returns>`RCL_RET_OK` if the time source was disabled successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This method will disable the `RCL_ROS_TIME` time abstraction override values,
        /// such that the time source will report the system time even if a custom
        /// value has been set.This function is not thread-safe with `rcl_clock_add_jump_callback`,
        /// nor `rcl_clock_remove_jump_callback` functions when used on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence [1]
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [2]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Only applies to the function itself, as jump callbacks may not abide to it.&lt;/i&gt;&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_disable_ros_time_override(RclNative.rcl_clock_t* clock);

        /// <summary>
        /// Check if the `RCL_ROS_TIME` time source has the override enabled.
        /// </summary>
        /// <param name="clock">The clock to query.</param>
        /// <param name="is_enabled">Whether the override is enabled..</param>
        /// <returns>`RCL_RET_OK` if the time source was queried successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This will populate the is_enabled object to indicate if the
        /// time overide is enabled. If it is enabled, the set value will be returned.
        /// Otherwise this time source will return the equivalent to system time abstraction.This function is not thread-safe with `rcl_enable_ros_time_override` nor
        /// `rcl_disable_ros_time_override` functions when used on the same clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_is_enabled_ros_time_override(RclNative.rcl_clock_t* clock, bool* is_enabled);

        /// <summary>
        /// Set the current time for this `RCL_ROS_TIME` time source.
        /// </summary>
        /// <param name="clock">The clock to update.</param>
        /// <param name="time_value">The new current time.</param>
        /// <returns>`RCL_RET_OK` if the time source was set successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will update the internal storage for the `RCL_ROS_TIME`
        /// time source.
        /// If queried and override enabled the time source will return this value,
        /// otherwise it will return the system time.This function is not thread-safe with `rcl_clock_add_jump_callback`,
        /// nor `rcl_clock_remove_jump_callback` functions when used on the same
        /// clock object.&lt;hr&gt;Attribute          | Adherence [1]
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No [2]
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes&lt;i&gt;[1] Only applies to the function itself, as jump callbacks may not abide to it.&lt;/i&gt;&lt;i&gt;[2] Function is reentrant, but concurrent calls on the same `clock` object are not safe.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_set_ros_time_override(RclNative.rcl_clock_t* clock, RclNative.rcl_time_point_value_t time_value);

        /// <summary>
        /// Add a callback to be called when a time jump exceeds a threshold.
        /// </summary>
        /// <param name="clock">A clock to add a jump callback to.</param>
        /// <param name="threshold">Criteria indicating when to call the callback.</param>
        /// <param name="callback">A callback to call.</param>
        /// <param name="user_data">A pointer to be passed to the callback.</param>
        /// <returns>`RCL_RET_OK` if the callback was added successfully, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if a memory allocation failed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occurs.</returns>
        /// <remarks>
        /// The callback is called twice when the threshold is exceeded: once before the clock is
        /// updated, and once after.
        /// The user_data pointer is passed to the callback as the last argument.
        /// A callback and user_data pair must be unique among the callbacks added to a clock.This function is not thread-safe with `rcl_clock_remove_jump_callback`,
        /// `rcl_enable_ros_time_override`, `rcl_disable_ros_time_override` nor
        /// `rcl_set_ros_time_override` functions when used on the same clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_clock_add_jump_callback(RclNative.rcl_clock_t* clock, RclNative.rcl_jump_threshold_t threshold, delegate* unmanaged[Cdecl]<RclNative.rcl_time_jump_t*, bool, void*, void> callback, void* user_data);

        /// <summary>
        /// Remove a previously added time jump callback.
        /// </summary>
        /// <param name="clock">The clock to remove a jump callback from.</param>
        /// <param name="callback">The callback to call.</param>
        /// <param name="user_data">A pointer to be passed to the callback.</param>
        /// <returns>`RCL_RET_OK` if the callback was added successfully, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if a memory allocation failed, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` the callback was not found or an unspecified error occurs.</returns>
        /// <remarks>
        /// This function is not thread-safe with `rcl_clock_add_jump_callback`
        /// `rcl_enable_ros_time_override`, `rcl_disable_ros_time_override` nor
        /// `rcl_set_ros_time_override` functions when used on the same clock object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No [1]
        /// Uses Atomics       | No
        /// Lock-Free          | Yes&lt;i&gt;[1] Function is reentrant, but concurrent calls on the same `clock` object are not safe.
        /// Thread-safety is also affected by that of the `allocator` object associated with the
        /// `clock` object.&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_clock_remove_jump_callback(RclNative.rcl_clock_t* clock, delegate* unmanaged[Cdecl]<RclNative.rcl_time_jump_t*, bool, void*, void> callback, void* user_data);

        /// <summary>
        /// Get the message bounds handle specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to service type support</param>
        /// <param name="identifier">The identifier to get the handle for</param>
        /// <returns>The associated sequence bound handle function.</returns>
        /// <remarks>
        /// The handle's sequence bound is simply returned or if the parameters are NULL then an assert
        /// will happen.
        /// </remarks>
        [DllImport("get", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_runtime_c__Sequence__bound* get_sequence_bound_handle(RclNative.rosidl_runtime_c__Sequence__bound* handle, byte* identifier);

        /// <summary>
        /// Get the message bounds handle function specific to this identifier.
        /// </summary>
        /// <param name="handle">Handle to service type support</param>
        /// <param name="identifier">The identifier to get the handle function for</param>
        /// <returns>if the identifier match's the handle's identifier then the handle's function
        /// is returned.</returns>
        /// <remarks>
        /// If the identifier is the same as this handle function's identifier the handle is simply returned
        /// or if the parameters are NULL then an assert will happen.
        /// </remarks>
        [DllImport("get", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rosidl_runtime_c__Sequence__bound* get_sequence_bound_handle_function(RclNative.rosidl_runtime_c__Sequence__bound* handle, byte* identifier);

        /// <summary>
        /// Return a rmw_subscription_options_t initialized with default values.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_subscription_options_t rmw_get_default_subscription_options();

        /// <summary>
        /// Get the name of the rmw implementation being used
        /// </summary>
        /// <returns>Name of rmw implementation</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rmw_get_implementation_identifier();

        /// <summary>
        /// Get the unique serialization format for this middleware.
        /// </summary>
        /// <returns>serialization format</returns>
        /// <remarks>
        /// Return the format in which binary data is serialized.
        /// One middleware can only have one encoding.
        /// In contrast to the implementation identifier, the serialization format can be equal between
        /// multiple RMW implementations.
        /// This means, that the same binary messages can be deserialized by RMW implementations with the
        /// same format.
        /// </remarks>
        /// <seealso cref="rmw_serialize"/>
        /// <seealso cref="rmw_deserialize"/>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte* rmw_get_serialization_format();

        /// <summary>
        /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
        /// Create a node and return a handle to that node.
        /// </summary>
        /// <param name="context">init context that this node should be associated with</param>
        /// <param name="name">the node name</param>
        /// <param name="namespace_">the node namespace</param>
        /// <returns>rmw node handle, or `NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - name is not a valid non-null node name
        /// - namespace_ is not a valid non-null namespace
        /// - context is not valid i.e. it is zero-initialized, or
        /// its implementation identifier does not match that of
        /// this API implementation, or has been invalidated by
        /// `rmw_shutdown()`
        /// - memory allocation fails during node creation
        /// - an unspecified error occurs&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No [1]
        /// Lock-Free          | No [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;This should be defined by the rmw implementation.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_node_t* rmw_create_node(RclNative.rmw_context_t* context, byte* name, byte* namespace_, RclNative.size_t domain_id, bool localhost_only);

        /// <summary>
        /// Finalize a given node handle, reclaim the resources, and deallocate the node handle.
        /// </summary>
        /// <param name="node">the node handle to be destroyed</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if node is invalid, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given node handle unchanged.
        /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
        /// the node handle. Usage of a deallocated node handle is undefined behavior.
        /// </remarks>
        /// <pre>
        /// All publishers, subscribers, services, and clients created from this node must
        /// have been destroyed prior to this call. Some rmw implementations may verify this,
        /// returning `RMW_RET_ERROR` and setting a human readable error message if any entity
        /// created from this node has not yet been destroyed. However, this is not guaranteed
        /// and so callers should ensure that this is the case before calling this function.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_node(RclNative.rmw_node_t* node);

        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_node_assert_liveliness(RclNative.rmw_node_t* node);

        /// <summary>
        /// Return a guard condition which is triggered when the ROS graph changes.
        /// </summary>
        /// <param name="node">Node to retrieve the guard condition from.</param>
        /// <returns>Guard condition if successful, or `NULL` if
        /// `node` is `NULL`, or an unspecified error occurs.</returns>
        /// <remarks>
        /// The guard condition will be triggered anytime a change to the ROS graph occurs.
        /// A ROS graph change occurs whenever:
        /// - A node joins or leaves the ROS graph.
        /// This change will be reflected in rmw_get_node_names() and
        /// rmw_get_node_names_with_enclaves() outcome.
        /// - A topic subscription joins or leaves the ROS graph.
        /// This change will be reflected in rmw_get_topic_names_and_types(),
        /// rmw_get_subscriber_names_and_types_by_node(), and
        /// rmw_get_subscriptions_info_by_topic() outcome.
        /// - A topic publisher joins or leaves the ROS graph.
        /// This change will be reflected in rmw_get_topic_names_and_types(),
        /// rmw_get_publisher_names_and_types_by_node(), and
        /// rmw_get_publishers_info_by_topic() outcome.
        /// - A topic subscription matches a topic publisher with compatible QoS policies.
        /// This change will be reflected in rmw_subscription_count_matched_publishers() outcome.
        /// - A topic publisher matches a topic subscription with compatible QoS policies.
        /// This change will be reflected in rmw_publisher_count_matched_subscriptions() outcome.
        /// - A service server joins or leaves the ROS graph.
        /// This change will be reflected in rmw_get_service_names_and_types() and
        /// rmw_get_service_names_and_types_by_node() outcome.
        /// - A service client joins or leaves the ROS graph.
        /// This change will be reflected in rmw_get_service_names_and_types() and
        /// rmw_get_client_names_and_types_by_node() outcome.
        /// - A service client matches a service server with compatible QoS policies.
        /// This change will be reflected in rmw_service_server_is_available() outcome.The guard condition is owned and internally held by the `node`.
        /// It will be invalidated if `node` is finalized using rmw_destroy_node().
        /// It is undefined behavior to use an invalidated guard condition.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <note>
        /// The state of the ROS graph, and any changes that may take place,
        /// are reported as seen by the associated `node`.
        /// </note>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_guard_condition_t* rmw_node_get_graph_guard_condition(RclNative.rmw_node_t* node);

        /// <summary>
        /// Initialize a publisher allocation to be used with later publications.
        /// </summary>
        /// <param name="type_support">Type support of the message to be preallocated.</param>
        /// <param name="message_bounds">Bounds structure of the message to be preallocated.</param>
        /// <param name="allocation">Allocation structure to be passed to `rmw_publish`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if it's unimplemented</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if an argument is null, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This creates an allocation object that can be used in conjunction with
        /// the rmw_publish method to perform more carefully control memory allocations.This will allow the middleware to preallocate the correct amount of memory
        /// for a given message type and message bounds.
        /// As allocation is performed in this method, it will not be necessary to allocate
        /// in the `rmw_publish` method.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init_publisher_allocation(RclNative.rosidl_message_type_support_t* type_support, RclNative.rosidl_runtime_c__Sequence__bound* message_bounds, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Destroy a publisher allocation object.
        /// </summary>
        /// <param name="allocation">Allocation object to be destroyed.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if it's unimplemented</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if argument is null, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This deallocates any memory allocated by `rmw_init_publisher_allocation`.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_fini_publisher_allocation(RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Return a rmw_publisher_options_t initialized with default values.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_publisher_options_t rmw_get_default_publisher_options();

        /// <summary>
        /// Create a publisher and return a handle to that publisher.
        /// </summary>
        /// <param name="node">Handle to node with which to register this publisher</param>
        /// <param name="type_support">Type support for the messages to be published</param>
        /// <param name="topic_name">Name of the topic to publish to, often a fully qualified
        /// topic name unless `qos_profile` is configured to avoid ROS namespace conventions
        /// i.e. to create a native topic publisher</param>
        /// <param name="qos_profile">QoS policies for this publisher</param>
        /// <param name="publisher_options">Options to configure this publisher</param>
        /// <returns>rmw publisher handle, or `NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is not a valid non-null handle for this rmw implementation,
        /// as returned by `rmw_create_node()`
        /// - type_support is a not valid non-null message type support, as returned by
        /// `ROSIDL_GET_MSG_TYPE_SUPPORT()`
        /// - topic_name is not a valid non-null topic name, according to
        /// `rmw_validate_full_topic_name()`
        /// - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
        /// - publisher_options is not a valid non-null option set, as returned by
        /// `rmw_get_default_publisher_options()`
        /// - memory allocation fails during publisher creation
        /// - an unspecified error occurs&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_publisher_t* rmw_create_publisher(RclNative.rmw_node_t* node, RclNative.rosidl_message_type_support_t* type_support, byte* topic_name, RclNative.rmw_qos_profile_t* qos_profile, RclNative.rmw_publisher_options_t* publisher_options);

        /// <summary>
        /// Finalize a given publisher handle, reclaim the resources, and deallocate the publisher handle.
        /// </summary>
        /// <param name="node">Handle to node with which the given publisher is registered</param>
        /// <param name="publisher">Handle to publisher to be finalized</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if node or publisher is `NULL`, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or publisher
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given publisher handle unchanged.
        /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
        /// the publisher handle. Usage of a deallocated publisher handle is undefined behavior.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given node must be the one the publisher was registered with.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_publisher(RclNative.rmw_node_t* node, RclNative.rmw_publisher_t* publisher);

        /// <summary>
        /// Borrow a loaned ROS message.
        /// </summary>
        /// <param name="publisher">Publisher to which the loaned ROS message will be associated.</param>
        /// <param name="type_support">Message type support of the loaned ROS message.</param>
        /// <param name="ros_message">Pointer to type erased ROS message loaned by the middleware.</param>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occured.</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
        /// does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `*ros_message` is not NULL (to prevent leaks), or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `type_support` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or</returns>
        /// <remarks>
        /// This ROS message is owned by the middleware, that will keep it alive (i.e. in valid
        /// memory space) until the caller publishes it using rmw_publish_loaned_message() or
        /// returns it using rmw_return_loaned_message_from_publisher().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to borrow ROS messages from the same publisher concurrently.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on borrow or not.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when using ROS message loaning support.
        /// </par>
        /// <pre>
        /// Given `type_support` must be a valid `rosidl` message type support, matching the
        /// one registered with the `publisher` on creation.
        /// </pre>
        /// <par>
        /// Runtime behavior
        /// To borrow a ROS message is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_borrow_loaned_message(RclNative.rmw_publisher_t* publisher, RclNative.rosidl_message_type_support_t* type_support, void** ros_message);

        /// <summary>
        /// Return a loaned message previously borrowed from a publisher.
        /// </summary>
        /// <param name="publisher">Publisher to which the loaned ROS message is associated.</param>
        /// <param name="loaned_message">Type erased loaned ROS message to be returned.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation identifier
        /// does not match this implementation, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs and no message can be initialized.</returns>
        /// <remarks>
        /// Tells the middleware that a borrowed ROS message is no longer needed by the caller.
        /// Ownership of the ROS message is given back to the middleware.
        /// If this function fails early due to a logical error, such as an invalid argument,
        /// the loaned ROS message will be left unchanged.
        /// Otherwise, ownership of the ROS message will be given back to the middleware.
        /// It is up to the middleware what will be made of the returned ROS message.
        /// It is undefined behavior to use a loaned ROS message after returning it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// To return a ROS message is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to return borrowed ROS messages to the same publisher concurrently.
        /// However, since ownership of the loaned ROS message is given back to the middleware and
        /// this transfer is not synchronized, it is not safe to return the same loaned ROS message
        /// concurrently.
        /// </par>
        /// <pre>
        /// Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
        /// </pre>
        /// <pre>
        /// Given `loaned_message` must have been previously borrowed from the same publisher
        /// using rmw_borrow_loaned_message().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_return_loaned_message_from_publisher(RclNative.rmw_publisher_t* publisher, void* loaned_message);

        /// <summary>
        /// Publish a ROS message.
        /// </summary>
        /// <param name="publisher">Publisher to be used to send message.</param>
        /// <param name="ros_message">Type erased ROS message to be sent.</param>
        /// <param name="allocation">Pre-allocated memory to be used. May be NULL.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Send a ROS message to all subscriptions with matching QoS policies using the given publisher.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// It is implementation defined whether to publish a ROS message is a
        /// synchronous or asynchronous, blocking or non-blocking operation.
        /// However, asynchronous implementations are not allowed to access the
        /// given ROS message after this function returns.
        /// Check the implementation documentation to learn about publish behavior.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on publish or not.
        /// For instance, implementations that serialize ROS messages to send it over the
        /// wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A publisher allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when publishing ROS messages with and without publisher allocations.
        /// </par>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to publish using the same publisher concurrently.
        /// However, when publishing regular ROS messages:
        /// - Access to the ROS message is read-only but it is not synchronized.
        /// Concurrent `ros_message` reads are safe, but concurrent reads and writes are not.
        /// - Access to the publisher allocation is not synchronized, unless specifically stated
        /// otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
        /// Check the implementation documentation to learn about publisher allocations' thread-safety.
        /// </par>
        /// <pre>
        /// Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
        /// </pre>
        /// <pre>
        /// Given `ros_message` must be a valid message, whose type matches the message type
        /// support the `publisher` was registered with on creation.
        /// </pre>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid publisher allocation, initialized
        /// with rmw_publisher_allocation_init() with a message type support that matches the
        /// one registered with `publisher` on creation.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publish(RclNative.rmw_publisher_t* publisher, void* ros_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Publish a loaned ROS message.
        /// </summary>
        /// <param name="allocation">Pre-allocated memory to be used. May be NULL.</param>
        /// <param name="publisher">Publisher to be used to send message.</param>
        /// <param name="ros_message">Loaned type erased ROS message to be sent.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support ROS message loaning, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <remarks>
        /// Send a previously borrowed ROS message to all subscriptions with matching QoS policies
        /// using the given publisher, then return ROS message ownership to the middleware.If this function fails early due to a logical error, such as an invalid argument,
        /// the loaned ROS message will be left unchanged.
        /// Otherwise, ownership of the ROS message will be given back to the middleware.
        /// It is up to the middleware what will be made of the returned ROS message.
        /// It is undefined behavior to use a loaned ROS message after publishing it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check the implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `ros_message` must be a valid message, borrowed from the same publisher using
        /// rmw_borrow_loaned_message().
        /// </pre>
        /// <pre>
        /// Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to publish using the same publisher concurrently.
        /// However, when publishing loaned ROS messages:
        /// - Ownership of the loaned ROS message is given back to the middleware.
        /// This transfer is not synchronized, and thus it is not safe to publish the
        /// same loaned ROS message concurrently.
        /// - Access to the publisher allocation is not synchronized, unless specifically stated
        /// otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
        /// Check the implementation documentation to learn about publisher allocations' thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on publish or not.
        /// For instance, implementations that serialize ROS messages to send it over the
        /// wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A publisher allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when publishing loaned ROS messages with and without publisher allocations.
        /// </par>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid publisher allocation, initialized
        /// with rmw_publisher_allocation_init() with a message type support that matches the
        /// one registered with `publisher` on creation.
        /// </pre>
        /// <par>
        /// Runtime behavior
        /// It is implementation defined whether to publish a loaned ROS message is a
        /// synchronous or asynchronous, blocking or non-blocking operation.
        /// Check the implementation documentation to learn about publish behavior.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publish_loaned_message(RclNative.rmw_publisher_t* publisher, void* ros_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Retrieve the number of matched subscriptions to a publisher.
        /// </summary>
        /// <param name="publisher">the publisher object to inspect</param>
        /// <param name="subscription_count">the number of subscriptions matched</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if either argument is null, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Query the underlying middleware to determine how many subscriptions are
        /// matched to a given publisher.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publisher_count_matched_subscriptions(RclNative.rmw_publisher_t* publisher, RclNative.size_t* subscription_count);

        /// <summary>
        /// Retrieve the actual qos settings of the publisher.
        /// </summary>
        /// <param name="publisher">the publisher object to inspect</param>
        /// <param name="qos">the actual qos settings</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if either argument is null, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if publisher
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Query the underlying middleware to determine the qos settings
        /// of the publisher.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the publisher, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <note>
        /// The value of avoid_ros_namespace_conventions field is not resolved
        /// with this function. The rcl function `rcl_publisher_get_actual_qos()`
        /// resolves it.
        /// </note>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publisher_get_actual_qos(RclNative.rmw_publisher_t* publisher, RclNative.rmw_qos_profile_t* qos);

        /// <summary>
        /// Publish a ROS message as a byte stream.
        /// </summary>
        /// <param name="publisher">Publisher to be used to send message.</param>
        /// <param name="ros_message">Serialized ROS message to be sent.</param>
        /// <param name="allocation">Pre-allocated memory to be used. May be NULL.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if `publisher` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Send a ROS message serialized as a byte stream to all subscriptions with
        /// matching QoS policies using the given publisher.
        /// A ROS message can be serialized manually using rmw_serialize().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check the implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// It is implementation defined whether to publish a loaned ROS message is a
        /// synchronous or asynchronous, blocking or non-blocking operation.
        /// However, asynchronous implementations are not allowed to access the
        /// given byte stream after this function returns.
        /// Check the implementation documentation to learn about publish behavior.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on publish or not.
        /// Even if a publisher allocation is provided, an implementation may ignore it.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when publishing serialized messages with and without publisher allocations.
        /// </par>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to publish using the same publisher concurrently.
        /// However, when publishing serialized ROS messages:
        /// - Access to the byte stream is read-only but it is not synchronized.
        /// Concurrent `serialized_message` reads are safe, but concurrent reads and writes are not.
        /// - Access to the publisher allocation is not synchronized, unless specifically stated
        /// otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_publish() uses it.
        /// Check the implementation documentation to learn about publisher allocations' thread-safety.
        /// </par>
        /// <pre>
        /// Given `publisher` must be a valid publisher, as returned by rmw_create_publisher().
        /// </pre>
        /// <pre>
        /// Given `serialized_message` must be a valid serialized message, initialized by
        /// rmw_serialized_message_init() and containing the serialization of a ROS message whose
        /// type matches the message type support the `publisher` was registered with on creation.
        /// </pre>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid publisher allocation, initialized
        /// with rmw_publisher_allocation_init() with a message type support that matches the
        /// one registered with `publisher` on creation.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publish_serialized_message(RclNative.rmw_publisher_t* publisher, RclNative.rmw_serialized_message_t* serialized_message, RclNative.rmw_publisher_allocation_t* allocation);

        /// <summary>
        /// Compute the size of a serialized message.
        /// </summary>
        /// <param name="type_support">The type support of the message to compute.</param>
        /// <param name="bounds">Artifical bounds to use on unbounded fields.</param>
        /// <param name="size">The computed size of the serialized message.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if either argument is null, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if it's unimplemented, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Given a message definition and bounds, compute the serialized size.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_get_serialized_message_size(RclNative.rosidl_message_type_support_t* type_support, RclNative.rosidl_runtime_c__Sequence__bound* message_bounds, RclNative.size_t* size);

        /// <summary>
        /// Manually assert that this Publisher is alive (for RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC)
        /// </summary>
        /// <param name="publisher">handle to the publisher that needs liveliness to be asserted</param>
        /// <returns>`RMW_RET_OK` if the liveliness assertion was completed successfully, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the rmw implementation does not support asserting liveliness.</returns>
        /// <remarks>
        /// If the rmw Liveliness policy is set to RMW_QOS_POLICY_LIVELINESS_MANUAL_BY_TOPIC, the creator of
        /// this publisher may manually call `assert_liveliness` at some point in time to signal to the rest
        /// of the system that this Node is still alive.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_publisher_assert_liveliness(RclNative.rmw_publisher_t* publisher);

        /// <summary>
        /// Serialize a ROS message into a rmw_serialized_message_t.
        /// </summary>
        /// <param name="ros_message">the typed ROS message</param>
        /// <param name="type_support">the typesupport for the ROS message</param>
        /// <param name="serialized_message">the destination for the serialize ROS message</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// The ROS message is serialized into a byte stream contained within the
        /// rmw_serialized_message_t structure.
        /// The serialization format depends on the underlying implementation.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [2]
        /// Lock-Free          | Maybe [2]
        /// &lt;i&gt;[1] if the given serialized message does not have enough capacity to hold
        /// the ROS message serialization&lt;/i&gt;&lt;i&gt;[2] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given ROS message must be a valid non-null instance, initialized
        /// by the caller and matching the provided typesupport.
        /// </pre>
        /// <pre>
        /// Given typesupport must be a valid non-null instance, as provided
        /// by `rosidl` APIs.
        /// </pre>
        /// <pre>
        /// Given serialized message must be a valid non-null instance, initialized
        /// by the caller.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_serialize(void* ros_message, RclNative.rosidl_message_type_support_t* type_support, RclNative.rmw_serialized_message_t* serialized_message);

        /// <summary>
        /// Deserialize a ROS message.
        /// </summary>
        /// <param name="serialized_message">the serialized message holding the byte stream</param>
        /// <param name="type_support">the typesupport for the typed ros message</param>
        /// <param name="ros_message">destination for the deserialized ROS message</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// The given rmw_serialized_message_t's internal byte stream buffer is deserialized
        /// into the given ROS message.
        /// The serialization format expected in the rmw_serialized_message_t depends on the
        /// underlying implementation.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [2]
        /// Lock-Free          | Maybe [2]
        /// &lt;i&gt;[1] if the given ROS message contains unbounded fields&lt;/i&gt;&lt;i&gt;[2] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given serialized message must be a valid non-null instance, such
        /// as that returned by `rmw_serialize()`, matching provided typesupport
        /// and ROS message.
        /// </pre>
        /// <pre>
        /// Given typesupport must be a valid non-null instance, as provided
        /// by `rosidl` APIs.
        /// </pre>
        /// <pre>
        /// Given ROS message must be a valid non-null instance, initialized
        /// by the caller.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_deserialize(RclNative.rmw_serialized_message_t* serialized_message, RclNative.rosidl_message_type_support_t* type_support, void* ros_message);

        /// <summary>
        /// Initialize a subscription allocation to be used with later `take`s.
        /// </summary>
        /// <param name="type_support">Type support of the message to be preallocated.</param>
        /// <param name="message_bounds">Bounds structure of the message to be preallocated.</param>
        /// <param name="allocation">Allocation structure to be passed to `rmw_take`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if it's unimplemented</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if an argument is null, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This creates an allocation object that can be used in conjunction with
        /// the rmw_take method to perform more carefully control memory allocations.This will allow the middleware to preallocate the correct amount of memory
        /// for a given message type and message bounds.
        /// As allocation is performed in this method, it will not be necessary to allocate
        /// in the `rmw_take` method.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_init_subscription_allocation(RclNative.rosidl_message_type_support_t* type_support, RclNative.rosidl_runtime_c__Sequence__bound* message_bounds, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Destroy a publisher allocation object.
        /// </summary>
        /// <param name="allocation">Allocation object to be destroyed.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if it's unimplemented</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if argument is null, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This deallocates memory allocated by `rmw_init_subscription_allocation`.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_fini_subscription_allocation(RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Create a subscription and return a handle to that subscription.
        /// </summary>
        /// <param name="node">Handle to node with which to register this subscription</param>
        /// <param name="type_support">Type support for the messages to be subscribed to</param>
        /// <param name="topic_name">Name of the topic to subscribe to, often a fully qualified
        /// topic name unless `qos_profile` is configured to avoid ROS namespace conventions
        /// i.e. to create a native topic subscription</param>
        /// <param name="qos_profile">QoS policies for this subscription</param>
        /// <param name="subscription_options">Options for configuring this subscription</param>
        /// <returns>rmw subscription handle, or `NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - node is not a valid non-null handle for this rmw implementation,
        /// as returned by `rmw_create_node()`
        /// - type_support is a not valid non-null message type support, as returned by
        /// `ROSIDL_GET_MSG_TYPE_SUPPORT()`
        /// - topic_name is not a valid non-null topic name, according to
        /// `rmw_validate_full_topic_name()` if ROS namespace conventions apply
        /// - qos_profile is not a fully specified non-null profile i.e. no UNKNOWN policies
        /// - subscription_options is not a valid non-null option set, such as the one
        /// returned by `rmw_get_default_subscription_options()`
        /// - memory allocation fails during subscription creation
        /// - an unspecified error occurs&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_subscription_t* rmw_create_subscription(RclNative.rmw_node_t* node, RclNative.rosidl_message_type_support_t* type_support, byte* topic_name, RclNative.rmw_qos_profile_t* qos_policies, RclNative.rmw_subscription_options_t* subscription_options);

        /// <summary>
        /// Finalize a given subscription handle, reclaim the resources, and deallocate the subscription
        /// handle.
        /// </summary>
        /// <param name="node">Handle to node with which the given subscription is registered</param>
        /// <param name="subscription">Handle to subscription to be finalized</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if node or subscription is `NULL`, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if node or subscription
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// This function will return early if a logical error, namely `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given subscription handle
        /// unchanged.
        /// Otherwise, it will proceed despite errors, freeing as many resources as it can, including
        /// the subscription handle, and return `RMW_RET_ERROR`. Usage of a deallocated subscription
        /// handle is undefined behavior.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given node must be the one the subscription was registered with.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_subscription(RclNative.rmw_node_t* node, RclNative.rmw_subscription_t* subscription);

        /// <summary>
        /// Retrieve the number of matched publishers to a subscription.
        /// </summary>
        /// <param name="subscription">the subscription object to inspect</param>
        /// <param name="publisher_count">the number of publishers matched</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if either argument is null, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Query the underlying middleware to determine how many publishers are
        /// matched to a given subscription.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_subscription_count_matched_publishers(RclNative.rmw_subscription_t* subscription, RclNative.size_t* publisher_count);

        /// <summary>
        /// Retrieve the actual qos settings of the subscription.
        /// </summary>
        /// <param name="subscription">the subscription object to inspect</param>
        /// <param name="qos">the actual qos settings</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if either argument is null, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if subscription
        /// implementation identifier does not match, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Query the underlying middleware to determine the qos settings
        /// of the subscription.
        /// The actual configuration applied when using RMW_*_SYSTEM_DEFAULT
        /// can only be resolved after the creation of the subscription, and it
        /// depends on the underlying rmw implementation.
        /// If the underlying setting in use can't be represented in ROS terms,
        /// it will be set to RMW_*_UNKNOWN.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <note>
        /// The value of avoid_ros_namespace_conventions field is not resolved
        /// with this function. The rcl function `rcl_subscription_get_actual_qos()`
        /// resolves it.
        /// </note>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_subscription_get_actual_qos(RclNative.rmw_subscription_t* subscription, RclNative.rmw_qos_profile_t* qos);

        /// <summary>
        /// Take an incoming ROS message.
        /// </summary>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="subscription">Subscription to take message from.</param>
        /// <param name="ros_message">Type erased ROS message to write to.</param>
        /// <param name="allocation">Pre-allocated memory to be used. May be NULL.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <remarks>
        /// The same ROS message cannot be taken twice.
        /// Callers do not have to deal with duplicates.Take a ROS message already received by the given subscription, removing it from internal queues.
        /// This function will succeed even if no ROS message was received, but `taken` will be false.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with the `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `ros_message` must be a valid message, whose type matches the message type support
        /// registered with the `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking regular ROS messages:
        /// - Access to the given ROS message is not synchronized.
        /// It is not safe to read or write `ros_message` while rmw_take() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take() uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_take() uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS messages received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when taking ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `ros_message` will remain a valid message.
        /// It will be left unchanged if this function fails early due to a logical error, such as an
        /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a ROS message is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
        /// but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take(RclNative.rmw_subscription_t* subscription, void* ros_message, bool* taken, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take an incoming ROS message with its metadata.
        /// </summary>
        /// <param name="message_info">Taken ROS message metadata.</param>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <param name="ros_message">Type erased ROS message to write to.</param>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="allocation">Pre-allocated memory to be used. May be NULL.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <remarks>
        /// Same as rmw_take(), except it also takes ROS message metadata.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation
        /// initialized with rmw_subscription_allocation_init() with a message type support
        /// that matches the one registered with the `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `ros_message` must be a valid message, whose type matches
        /// the message type support registered with the `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking regular ROS messages with metadata:
        /// - Access to the given ROS message is not synchronized.
        /// It is not safe to read or write `ros_message` while rmw_take_with_info() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_with_info() uses it.
        /// - Access to the given ROS message metadata is not synchronized.
        /// It is not safe to read or write `message_info` while rmw_take_with_info() uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_take_with_info()
        /// uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS messages received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when taking ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `ros_message` will remain a valid message, and
        /// `message_info`, valid message metadata.
        /// Both will be left unchanged if this function fails early due to a logical error, such as
        /// an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
        /// Both will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a ROS message with its metadata is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
        /// but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_with_info(RclNative.rmw_subscription_t* subscription, void* ros_message, bool* taken, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take multiple incoming ROS messages with their metadata.
        /// </summary>
        /// <param name="allocation">Pre-allocated memory to use. May be NULL.</param>
        /// <param name="taken">Number of messages actually taken from subscription.</param>
        /// <param name="message_info_sequence">Sequence of additional message metadata.
        /// Message info sequence capacity has to be enough to hold all requested messages
        /// metadata i.e. capacity has to be equal or greater than `count`.
        /// It does not have to match that of `message_sequence`.</param>
        /// <param name="message_sequence">Sequence of type erase ROS messages to write to.
        /// Message sequence capacity has to be enough to hold all requested messages
        /// i.e. capacity has to be equal or greater than `count`.
        /// It does not have to match that of `message_info_sequence`.</param>
        /// <param name="count">Number of messages to attempt to take.</param>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `count` is 0, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_sequence` capacity is less than `count`, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_info_sequence` capacity is less than `count`, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_sequence` is NULL, or</returns>
        /// <remarks>
        /// Once taken, ROS messages in the sequence cannot be taken again.
        /// Callers do not have to deal with duplicates.Take a sequence of consecutive ROS messages already received by the given
        /// subscription, removing them from internal queues.
        /// While `count` ROS messages may be requested, fewer messages may have been
        /// received by the subscription.
        /// This function will only take what has been already received, and it will
        /// succeed even if fewer (or zero) messages were received.
        /// In this case, only currently available messages will be returned.
        /// The `taken` flag indicates the number of ROS messages actually taken.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `message_info_sequence` must be a valid message metadata sequence,
        /// initialized by rmw_message_info_sequence_init().
        /// </pre>
        /// <pre>
        /// Given `message_sequence` must be a valid message sequence, initialized
        /// by rmw_message_sequence_init() and populated with ROS messages whose
        /// type matches the message type support registered with the `subscription`
        /// on creation.
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// Moreover, the sequence of ROS messages taken is guaranteed to be consecutive and to
        /// preserve the order in the subscription queues, despite any concurrent takes.
        /// However, when taking a sequence of ROS messages with metadata:
        /// - Access to the given ROS message sequence is not synchronized.
        /// It is not safe to read or write `message_sequence` while rmw_take_sequence() uses it.
        /// - Access to the given ROS message metadata sequence is not synchronized.
        /// It is not safe to read or write `message_info_sequence` while rmw_take_sequence() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_sequence() uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while rmw_take_sequence()
        /// uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS messages received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when taking ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `message_sequence` will remain a valid message sequence, and
        /// `message_info_sequence`, a valid message metadata sequence.
        /// Both will be left unchanged if this function fails early due to a logical error, such as
        /// an invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
        /// Both will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a sequence of ROS messages is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
        /// but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_sequence(RclNative.rmw_subscription_t* subscription, RclNative.size_t count, RclNative.rmw_message_sequence_t* message_sequence, RclNative.rmw_message_info_sequence_t* message_info_sequence, RclNative.size_t* taken, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take an incoming ROS message as a byte stream.
        /// </summary>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <param name="serialized_message">Byte stream to write to.</param>
        /// <param name="allocation">Pre-allocated memory to use. May be NULL.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <remarks>
        /// The same ROS message, serialized or not, cannot be taken twice.
        /// Callers do not have to deal with duplicates.Take a ROS message already received by the given subscription, removing it from internal queues.
        /// This function will succeed even if no ROS message was received, but `taken` will be false.
        /// Unlike rmw_take(), the ROS message is taken in its serialized form, as a byte stream.
        /// If needed, this byte stream can then be deserialized into a ROS message with rmw_deserialize().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `serialized_message` must be a valid serialized message, initialized by
        /// rmw_serialized_message_init().
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned by
        /// rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking serialized ROS messages:
        /// - Access to the given byte stream for serialized ROS messages is not synchronized.
        /// It is not safe to read or write `serialized_message` while
        /// rmw_take_serialized_message() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_serialized_message() uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while
        /// rmw_take_serialized_message() uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// For ROS messages that only contain bounded (fixed-size) fields, callers can query
        /// their size using rmw_get_serialized_message_size() and resize `serialized_message`
        /// using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
        /// on take.
        /// Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations may have to perform additional memory allocations
        /// when dealing with ROS messages that contain unbounded (dynamically-sized) fields
        /// i.e. these implementations may have to resize the given byte stream.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation guarantees
        /// when taking serialized ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `serialized_message` will remain a valid serialized message.
        /// It will be left unchanged if this function fails early due to a logical error,
        /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
        /// runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a ROS message a byte stream is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
        /// but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_serialized_message(RclNative.rmw_subscription_t* subscription, RclNative.rmw_serialized_message_t* serialized_message, bool* taken, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take an incoming ROS message as a byte stream with its metadata.
        /// </summary>
        /// <param name="message_info">Taken ROS message metadata.</param>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <param name="serialized_message">Byte stream to write to.</param>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="allocation">Pre-allocated memory to use. May be NULL.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `serialized_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <remarks>
        /// Same as rmw_take_serialized_message(), except it also takes ROS message metadata.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `serialized_message` must be a valid serialized message, initialized by
        /// rmw_serialized_message_init().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking serialized ROS messages with metadata:
        /// - Access to the given byte stream for serialized ROS messages is not synchronized.
        /// It is not safe to read or write `serialized_message` while
        /// rmw_take_serialized_message_with_info() uses it.
        /// - Access to the given ROS message metadata is not synchronized.
        /// It is not safe to read or write `message_info` while
        /// rmw_take_serialized_message_with_info() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_serialized_message_with_info()
        /// uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while
        /// rmw_take_serialized_message_with_info() uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// For ROS messages that only contain bounded (fixed-size) fields, callers can query
        /// their size using rmw_get_serialized_message_size() and resize `serialized_message`
        /// using rmw_serialized_message_resize() accordingly to prevent byte stream resizing
        /// on take.
        /// Nonetheless, byte stream resizing is not guaranteed to be the sole memory operation.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations may have to perform additional memory allocations
        /// when dealing with ROS messages that contain unbounded (dynamically-sized) fields
        /// i.e. these implementations may have to resize the given byte stream.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation guarantees
        /// when taking serialized ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `serialized_message` will remain a valid serialized message, and `message_info`,
        /// valid message metadata.
        /// Both will be left unchanged if this function fails early due to a logical error,
        /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
        /// runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a ROS message a byte stream with its metadata is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive,
        /// but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_serialized_message_with_info(RclNative.rmw_subscription_t* subscription, RclNative.rmw_serialized_message_t* serialized_message, bool* taken, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take an incoming ROS message, loaned by the middleware.
        /// </summary>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <param name="loaned_message">Pointer to type erased ROS message taken
        /// and loaned by the middleware.</param>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="allocation">Pre-allocated memory to use. May be NULL.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL (to prevent leaks), or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or</returns>
        /// <remarks>
        /// The same ROS message, loaned or not, cannot be taken twice.
        /// Callers do not have to deal with duplicates.Take a ROS message already received by the given subscription, removing it from internal queues.
        /// This function will succeed even if no ROS message was received, but `taken` will be false.
        /// The loaned ROS message is owned by the middleware, which will keep it alive (i.e. in valid
        /// memory space) until the caller returns it using rmw_return_loaned_message_from_subscription().&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking loaned ROS messages:
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` nor `loaned_message`
        /// while rmw_take_loaned_message() uses them.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while
        /// rmw_take_loaned_message() uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS messages received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when taking loaned ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `loaned_message` will remain unchanged, or point to a valid message if
        /// this function was successful and `taken` is true.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a loaned ROS message is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
        /// nor for internal memory loaning pools, if any, to be replenished, but it is not
        /// guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_loaned_message(RclNative.rmw_subscription_t* subscription, void** loaned_message, bool* taken, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Take a loaned message and with its additional message information.
        /// </summary>
        /// <param name="allocation">Pre-allocated memory to use. May be NULL.</param>
        /// <param name="subscription">Subscription to take ROS message from.</param>
        /// <param name="loaned_message">Pointer to type erased ROS message taken
        /// and loaned by the middleware.</param>
        /// <param name="taken">Boolean flag indicating if a ROS message was taken or not.</param>
        /// <param name="message_info">Taken ROS message metadata.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `message_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `*loaned_message` is not NULL to prevent leaks, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or</returns>
        /// <remarks>
        /// Same as rmw_take_loaned_message(), except it also takes ROS message metadata.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <post>
        /// Given `loaned_message` will remain unchanged, or point to a valid message if
        /// this function was successful and `taken` is true.
        /// </post>
        /// <pre>
        /// If not NULL, given `allocation` must be a valid subscription allocation initialized
        /// with rmw_subscription_allocation_init() with a message type support that matches the
        /// one registered with `subscription` on creation.
        /// </pre>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take from the same subscription concurrently.
        /// However, when taking loaned ROS messages with metadata:
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` nor `loaned_message`
        /// while rmw_take_loaned_message_with_info() uses them.
        /// - Access to the given ROS message metadata is not synchronized.
        /// It is not safe to read or write `message_info` while
        /// rmw_take_loaned_message_with_info() uses it.
        /// - Access to the given subscription allocation is not synchronized,
        /// unless specifically stated otherwise by the implementation.
        /// Thus, it is generally not safe to read or write `allocation` while
        /// rmw_take_loaned_message_with_info() uses it.
        /// Check the implementation documentation to learn about subscription allocations'
        /// thread-safety.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS messages received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// A subscription allocation, if provided, may or may not be used.
        /// Check the implementation documentation to learn about memory allocation
        /// guarantees when taking loaned ROS messages with and without subscription allocations.
        /// </par>
        /// <post>
        /// Given `message_info` will remain valid message metadata.
        /// It will be left unchanged if this function fails early due to a logical error,
        /// such as an invalid argument, or in an unknown yet valid state if it fails due to a
        /// runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To take a loaned ROS message with its metadata is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS messages to arrive
        /// nor for internal memory loaning pools, if any, to be replenished, but it is not
        /// guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_loaned_message_with_info(RclNative.rmw_subscription_t* subscription, void** loaned_message, bool* taken, RclNative.rmw_message_info_t* message_info, RclNative.rmw_subscription_allocation_t* allocation);

        /// <summary>
        /// Return a loaned ROS message previously taken from a subscription.
        /// </summary>
        /// <param name="subscription">Subscription the ROS message was taken and loaned from.</param>
        /// <param name="loaned_message">Loaned type erased ROS message to be returned to the middleware.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `subscription` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `loaned_message` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `subscription` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_UNSUPPORTED` if the implementation does not support loaned ROS messages, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Tells the middleware that previously loaned ROS message is no longer needed by the caller.
        /// If this function fails early due to a logical error, such as an invalid argument,
        /// the loaned ROS message will be left unchanged.
        /// Otherwise, ownership of the ROS message will be given back to the middleware.
        /// It is up to the middleware what will be made of the returned ROS message.
        /// It is undefined behavior to use a loaned ROS message after returning it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// To return a loaned ROS message is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        /// <par>
        /// Thread-safety
        /// Subscriptions are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to return loaned ROS messages to the same subscription concurrently.
        /// However, since ownership of the loaned ROS message is given back to middleware and this
        /// transfer is not synchronized, it is not safe to return the same loaned ROS message
        /// concurrently.
        /// </par>
        /// <pre>
        /// Given `subscription` must be a valid subscription, as returned
        /// by rmw_create_subscription().
        /// </pre>
        /// <pre>
        /// Given `loaned_message` must be a loaned ROS message, previously taken from
        /// `subscription` using rmw_take_loaned_message() or rmw_take_loaned_message_with_info().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_return_loaned_message_from_subscription(RclNative.rmw_subscription_t* subscription, void* loaned_message);

        /// <summary>
        /// Create a service client that can send requests to and receive replies from a service server.
        /// </summary>
        /// <param name="node">Node with which to register this service client.</param>
        /// <param name="type_support">Type support of the service to be used.</param>
        /// <param name="service_name">Name of the service to be used, often a fully qualified
        /// service name unless `qos_profile` is configured to avoid ROS namespace conventions
        /// i.e. to create a native service client.</param>
        /// <param name="qos_profile">QoS policies for this service client's connections.</param>
        /// <returns>rmw service client handle, or `NULL` if there was an error.</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - `node` is `NULL`, or
        /// - `node` does not belong to this implementation
        /// i.e. it does not have a matching implementation identifier, or
        /// - `type_support` is `NULL`, or
        /// - `service_name` is `NULL`, or
        /// - `service_name` is an empty string, or
        /// - (if ROS namespace conventions apply) `service_name` is invalid by
        /// rmw_validate_full_topic_name() definition, or
        /// - `qos_profile` is `NULL`, or
        /// - `qos_profile` has invalid or unknown policies, or
        /// - memory allocation fails during service client creation, or
        /// - an unspecified error occurs.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node` must be a valid node, as returned by rmw_create_node().
        /// </pre>
        /// <pre>
        /// Given `type_support` must be a valid `rosidl` service type support, as
        /// returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_client_t* rmw_create_client(RclNative.rmw_node_t* node, RclNative.rosidl_service_type_support_t* type_support, byte* service_name, RclNative.rmw_qos_profile_t* qos_policies);

        /// <summary>
        /// Destroy and unregister a service client from its node.
        /// </summary>
        /// <param name="node">Node with which the given service client is registered.</param>
        /// <param name="client">Service client to be destroyed.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `client` is `NULL`, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will reclaim all associated resources, including the service client itself.
        /// Use of a destroyed service client is undefined behavior.
        /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service client unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node` must be the one the service client was registered with.
        /// </pre>
        /// <pre>
        /// Given `client` must be a valid service client, as returned by rmw_create_service().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_client(RclNative.rmw_node_t* node, RclNative.rmw_client_t* client);

        /// <summary>
        /// Send a ROS service request.
        /// </summary>
        /// <param name="sequence_id">Sequence number for the `ros_request` just sent
        /// i.e. a unique identification number for it, populated on success.</param>
        /// <param name="client">Service client to send a request with.</param>
        /// <param name="ros_request">ROS service request to be sent.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `sequence_id` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <remarks>
        /// Send a ROS service request to one or more service servers, with matching QoS policies,
        /// using the given client.On success, this function will return a sequence number.
        /// It is up to callers to save the returned sequence number to pair the ROS service request
        /// just sent with future ROS service responses (taken using rmw_take_response()).&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `client` must be a valid client, as returned by rmw_create_client().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Service clients are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to send requests using the same service client concurrently.
        /// However:
        /// - Access to the given ROS service request is read-only but it is not synchronized.
        /// Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `sequence_id` while rmw_send_request() uses it.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on send or not.
        /// For instance, implementations that serialize ROS service requests may need to
        /// perform additional memory allocations when dealing with unbounded (dynamically-sized)
        /// fields.
        /// </par>
        /// <par>
        /// Runtime behavior
        /// It is implementation defined whether sending a ROS service request is a
        /// synchronous or asynchronous, and blocking or non-blocking, operation.
        /// However, asynchronous implementations are not allowed to access the
        /// given ROS service request after this function returns.
        /// Check the implementation documentation to learn about request behavior.
        /// </par>
        /// <pre>
        /// Given `ros_request` must be a valid service request, whose type matches the
        /// service type support registered with the `client` on creation.
        /// </pre>
        /// <note>
        /// It is implementation defined how many service servers may get, and potentially react to,
        /// the same request, considering there may be more than one server for the same service
        /// in the ROS graph.
        /// </note>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_send_request(RclNative.rmw_client_t* client, void* ros_request, long* sequence_id);

        /// <summary>
        /// Take an incoming ROS service response.
        /// </summary>
        /// <param name="taken">Boolean flag indicating if a ROS service response was taken or not.</param>
        /// <param name="client">Service client to take response from.</param>
        /// <param name="response_header">Service response header to write to.</param>
        /// <param name="ros_request">Type erased ROS service response to write to.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `client`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `response_header` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `client` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <remarks>
        /// The same ROS service response cannot be taken twice.
        /// Callers do not have to deal with duplicates.Take a ROS service response already received by the given service server, removing
        /// it from internal queues.
        /// The response header (i.e. its metadata), containing at least the writer guid and
        /// sequence number, is also retrieved.
        /// Both writer guid and sequence number allow callers to pair, potentially for each
        /// remote service server, a ROS service response with its corresponding ROS service
        /// request, previously sent using rmw_send_request().This function will succeed even if no ROS service request was received,
        /// but `taken` will be false.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `ros_response` must be a valid service response, whose type matches the
        /// service type support registered with the `client` on creation.
        /// </pre>
        /// <pre>
        /// Given `client` must be a valid client, as returned by rmw_create_client().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Service clients are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take responses from the same service client concurrently.
        /// However:
        /// - Access to the given ROS service response is not synchronized.
        /// It is not safe to read or write `ros_response` while rmw_take_request() uses it.
        /// - Access to the given ROS service response header is not synchronized.
        /// It is not safe to read or write `response_header` while rmw_take_response() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_response() uses it.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS service responses received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// </par>
        /// <par>
        /// Runtime behavior
        /// Taking a ROS service response is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS service responses
        /// to arrive, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        /// <post>
        /// Given `ros_response` will remain a valid service response.
        /// It will be left unchanged if this function fails early due to a logical error, such as an
        /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <note>
        /// It is implementation defined how many responses a given request may get,
        /// considering there may be more than one server for the same service in the ROS graph.
        /// </note>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_response(RclNative.rmw_client_t* client, RclNative.rmw_service_info_t* request_header, void* ros_response, bool* taken);

        /// <summary>
        /// Create a service server that can receive requests from and send replies to a service client.
        /// </summary>
        /// <param name="node">Node with which to register this service server.</param>
        /// <param name="type_support">Type support of the service to be served.</param>
        /// <param name="service_name">Name of the service to be served, often a fully qualified
        /// service name unless `qos_profile` is configured to avoid ROS namespace conventions
        /// i.e. to create a native service server.</param>
        /// <param name="qos_profile">QoS policies for this service server's connections.</param>
        /// <returns>rmw service handle, or `NULL` if there was an error.</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - `node` is `NULL`, or
        /// - `node` does not belong to this implementation
        /// i.e. it does not have a matching implementation identifier, or
        /// - `type_support` is `NULL`, or
        /// - `service_name` is `NULL`, or
        /// - `service_name` is an empty string, or
        /// - (if ROS namespace conventions apply) `service_name` is invalid by
        /// rmw_validate_full_topic_name() definition, or
        /// - `qos_profile` is `NULL`, or
        /// - `qos_profile` has invalid or unknown policies, or
        /// - memory allocation fails during service server creation, or
        /// - an unspecified error occurs&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node` must be a valid node, as returned by rmw_create_node().
        /// </pre>
        /// <pre>
        /// Given `type_support` must be a valid `rosidl` service type support, as
        /// returned by ROSIDL_GET_SRV_TYPE_SUPPORT().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_service_t* rmw_create_service(RclNative.rmw_node_t* node, RclNative.rosidl_service_type_support_t* type_support, byte* service_name, RclNative.rmw_qos_profile_t* qos_profile);

        /// <summary>
        /// Destroy and unregister a service server from its node.
        /// </summary>
        /// <param name="node">Node with which the given service server is registered.</param>
        /// <param name="service">Service server to be destroyed.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is `NULL`, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `service` is `NULL`, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will reclaim all associated resources, including the service server itself.
        /// Use of a destroyed service server is undefined behavior.
        /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given service server unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node` must be the one the service server was registered with.
        /// </pre>
        /// <pre>
        /// Given `service` must be a valid service server, as returned by rmw_create_service().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_service(RclNative.rmw_node_t* node, RclNative.rmw_service_t* service);

        /// <summary>
        /// Take an incoming ROS service request.
        /// </summary>
        /// <param name="taken">Boolean flag indicating if a ROS service request was taken or not.</param>
        /// <param name="service">Service server to take request from.</param>
        /// <param name="request_header">Service request header to write to.</param>
        /// <param name="ros_request">Type erased ROS service request to write to.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `taken` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_request` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or</returns>
        /// <remarks>
        /// The same ROS service request cannot be taken twice.
        /// Callers do not have to deal with duplicates.Take a ROS service request already received by the given service server, removing
        /// it from internal queues.
        /// The request header (i.e. its metadata), containing at least the writer guid and
        /// sequence number, is also retrieved.
        /// Both writer guid and sequence number allow callers to pair, for each remote service
        /// client, a ROS service request with its corresponding ROS service response, to be later
        /// sent using rmw_send_response().This function will succeed even if no ROS service request was received,
        /// but `taken` will be false.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `ros_request` must be a valid service request, whose type matches the
        /// service type support registered with the `service` on creation.
        /// </pre>
        /// <pre>
        /// Given `service` must be a valid service, as returned by rmw_create_service().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Service servers are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to take requests from the same service server concurrently.
        /// However:
        /// - Access to the given ROS service request is not synchronized.
        /// It is not safe to read or write `ros_request` while rmw_take_request() uses it.
        /// - Access to the given ROS service request header is not synchronized.
        /// It is not safe to read or write `request_header` while rmw_take_request() uses it.
        /// - Access to given primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `taken` while rmw_take_request() uses it.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on take or not.
        /// For instance, implementations that deserialize ROS service requests received over
        /// the wire may need to perform additional memory allocations when dealing with
        /// unbounded (dynamically-sized) fields.
        /// </par>
        /// <post>
        /// Given `ros_request` will remain a valid service request.
        /// It will be left unchanged if this function fails early due to a logical error, such as an
        /// invalid argument, or in an unknown yet valid state if it fails due to a runtime error.
        /// It will also be left unchanged if this function succeeds but `taken` is false.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// Taking a ROS service request is a synchronous operation.
        /// It is also non-blocking, to the extent it will not wait for new ROS service requests
        /// to arrive, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_take_request(RclNative.rmw_service_t* service, RclNative.rmw_service_info_t* request_header, void* ros_request, bool* taken);

        /// <summary>
        /// Send a ROS service response.
        /// </summary>
        /// <param name="ros_response">ROS service response to be sent.</param>
        /// <param name="client">Service server to send a response with.</param>
        /// <param name="request_header">Service response header, same as the one taken
        /// with the corresponding ROS service request.</param>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `service`
        /// implementation identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `ros_response` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `request_header` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `service` is NULL, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <remarks>
        /// Send a ROS service response to the service client, with matching QoS policies,
        /// from which the previously taken ROS service request was originally sent.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `request_header` must be the one previously taken along with the ROS service
        /// request to which we reply.
        /// </pre>
        /// <pre>
        /// Given `service` must be a valid service server, as returned by rmw_create_service().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Service servers are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to send responses using the same service server concurrently.
        /// However:
        /// - Access to the given ROS service request header is read-only but it is not synchronized.
        /// Concurrent `request_header` reads are safe, but concurrent reads and writes are not.
        /// - Access to the given ROS service response is read-only but it is not synchronized.
        /// Concurrent `ros_request` reads are safe, but concurrent reads and writes are not.
        /// </par>
        /// <par>
        /// Memory allocation
        /// It is implementation defined whether memory will be allocated on send or not.
        /// For instance, implementations that serialize ROS service responses may need to
        /// perform additional memory allocations when dealing with unbounded (dynamically-sized)
        /// fields.
        /// </par>
        /// <pre>
        /// Given `ros_response` must be a valid service response, whose type matches the
        /// service type support registered with the `service` on creation.
        /// </pre>
        /// <par>
        /// Runtime behavior
        /// It is implementation defined whether sending a ROS service response is a
        /// synchronous or asynchronous, and blocking or non-blocking, operation.
        /// However, asynchronous implementations are not allowed to access the
        /// given ROS service request after this function returns.
        /// Check the implementation documentation to learn about request behavior.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_send_response(RclNative.rmw_service_t* service, RclNative.rmw_request_id_t* request_header, void* ros_response);

        /// <summary>
        /// TODO(wjwwood): refactor this API to return a return code when updated to use an allocator
        /// Create a guard condition and return a handle to that guard condition.
        /// </summary>
        /// <param name="context">init context that this node should be associated with</param>
        /// <returns>rmw guard condition handle or `NULL` if there was an error</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - context is `NULL`
        /// - context is invalid
        /// - memory allocation fails during guard condition creation
        /// - an unspecified error occursThe context must be non-null and valid, i.e. it has been initialized
        /// by `rmw_init()` and has not been finalized by `rmw_shutdown()`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No [1]
        /// Lock-Free          | No [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;This should be defined by the rmw implementation.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_guard_condition_t* rmw_create_guard_condition(RclNative.rmw_context_t* context);

        /// <summary>
        /// Finalize a given guard condition handle, reclaim the resources, and deallocate the handle.
        /// </summary>
        /// <param name="guard_condition">the guard condition handle to be destroyed</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if guard_condition is null, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unexpected error occurs.</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_guard_condition(RclNative.rmw_guard_condition_t* guard_condition);

        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_trigger_guard_condition(RclNative.rmw_guard_condition_t* guard_condition);

        /// <summary>
        /// Create a wait set to store conditions that the middleware can wait on.
        /// </summary>
        /// <param name="context">Context to associate the wait set with.</param>
        /// <param name="max_conditions">The maximum number of conditions that can be attached to, and stored by, the wait set.
        /// Can be set to zero (0) for the wait set to support an unbounded number of conditions.</param>
        /// <returns>An rmw wait set, or `NULL` if an error occurred.</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - context is `NULL`
        /// - context is zero initialized, as provided by rmw_get_zero_initialized_context()
        /// - context does not belong to this implementation i.e. does not have a matching
        /// implementation identifier
        /// - memory allocation fails during wait set creation
        /// - an unspecified error occurs&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Contexts are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to create multiple wait sets in the same context concurrently.
        /// </par>
        /// <pre>
        /// Given `context` must be a valid context, initialized by rmw_init().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_wait_set_t* rmw_create_wait_set(RclNative.rmw_context_t* context, RclNative.size_t max_conditions);

        /// <summary>
        /// Destroy a wait set.
        /// </summary>
        /// <param name="wait_set">Wait set to be finalized.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `wait_set` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will reclaim all associated resources, including the wait set.
        /// Use of a wait set after destruction is undefined behavior.
        /// This function will return early if a logical error, such as `RMW_RET_INVALID_ARGUMENT`
        /// or `RMW_RET_INCORRECT_RMW_IMPLEMENTATION`, ensues, leaving the given wait set unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_destroy_wait_set(RclNative.rmw_wait_set_t* wait_set);

        /// <summary>
        /// Waits on sets of different entities and returns when one is ready.
        /// </summary>
        /// <param name="wait_set">Wait set to use for waiting.</param>
        /// <param name="subscriptions">Array of subscriptions to wait on.
        /// Can be `NULL` if there are no subscriptions to wait on.</param>
        /// <param name="guard_conditions">Array of guard conditions to wait on
        /// Can be `NULL` if there are no guard conditions to wait on.</param>
        /// <param name="services">Array of services to wait on.
        /// Can be `NULL` if there are no services to wait on.</param>
        /// <param name="clients">Array of clients to wait on.
        /// Can be `NULL` if there are no clients to wait on.</param>
        /// <param name="events">Array of events to wait on.
        /// Can be `NULL` if there are no events to wait on.</param>
        /// <param name="wait_timeout">If `NULL`, block indefinitely until an entity becomes ready.
        /// If zero, do not block -- check only for immediately available entities.
        /// Else, this represents the maximum amount of time to wait for an entity to become ready.</param>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `wait_set` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_TIMEOUT` if wait timed out, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `wait_set` is `NULL`, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if an array entry is `NULL`, or</returns>
        /// <remarks>
        /// Elapsed time is measured against the system clock.
        /// Timeout granularity is thus bound to that of the aforementioned clock and,
        /// depending on the underlying implementation, to that of platform-specific
        /// APIs to sleep and/or wait.The amount of time this function actually waits may be either above or
        /// below the specified timeout.Arrays' memory management is external to this function.This function adds middleware-specific conditions to the wait set and waits
        /// until one or more become ready, or until the timeout is reached.Arrays contain type-erased, middleware-specific conditions associated with
        /// waitable entities, which this function casts and adds to the wait set.
        /// `NULL` entries in arrays prior to wait are considered invalid.
        /// When the wait is over, entries in each array that correspond to
        /// conditions that were @b not triggered are set to `NULL`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Maybe [1]
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `wait_set` must be a valid wait set, as returned by rmw_create_wait_set().
        /// </pre>
        /// <pre>
        /// All given entities must be associated with nodes that, in turn, were registered
        /// with the same context the given `wait_set` was registered with on creation.
        /// </pre>
        /// <par>
        /// Thread-safety
        /// To wait is a reentrant procedure, but:
        /// - It is not safe to use the same wait set to wait in two or more threads concurrently.
        /// - It is not safe to wait for the same entity using different wait sets in two or
        /// more threads concurrently.
        /// - Access to the given timeout is read-only but it is not synchronized.
        /// Concurrent `wait_timeout` reads are safe, but concurrent reads and writes are not.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_wait(RclNative.rmw_subscriptions_t* subscriptions, RclNative.rmw_guard_conditions_t* guard_conditions, RclNative.rmw_services_t* services, RclNative.rmw_clients_t* clients, RclNative.rmw_events_t* events, RclNative.rmw_wait_set_t* wait_set, RclNative.rmw_time_t* wait_timeout);

        /// <summary>
        /// Return the name and namespace of all nodes in the ROS graph.
        /// </summary>
        /// <param name="node">Node to query the ROS graph.</param>
        /// <param name="node_names">Array of discovered node names, populated on success.
        /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().</param>
        /// <param name="node_namespaces">Array of discovered node namespaces, populated on success.
        /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().</param>
        /// <returns>`RMW_RET_OK` if the query was successful, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or</returns>
        /// <remarks>
        /// This function will return an array of node names and an array of node namespaces,
        /// as discovered so far by the given node.
        /// The two arrays represent name and namespace pairs for each discovered node.
        /// Both arrays will be the same length and the same index will refer to the same node.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node_namespaces` must be a valid string array, zero-initialized
        /// as returned by rcutils_get_zero_initialized_string_array().
        /// </pre>
        /// <pre>
        /// Given `node_names` must be a valid string array, zero-initialized
        /// as returned by rcutils_get_zero_initialized_string_array().
        /// </pre>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to query the ROS graph using the same node concurrently.
        /// However, access to string arrays is not synchronized.
        /// It is not safe to read or write `node_names` nor `node_namespaces`
        /// while rmw_get_node_names() uses them.
        /// </par>
        /// <post>
        /// Given `node_names` and `node_namespaces` will remain valid arrays.
        /// These will be left unchanged if this function fails early due to a logical error,
        /// such as an invalid argument, or in an unknown yet valid state if it fails due to
        /// a runtime error.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To query the ROS graph is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_get_node_names(RclNative.rmw_node_t* node, RclNative.rcutils_string_array_t* node_names, RclNative.rcutils_string_array_t* node_namespaces);

        /// <summary>
        /// Return the name, namespae, and enclave name of all nodes in the ROS graph.
        /// </summary>
        /// <param name="node">Node to query the ROS graph.</param>
        /// <param name="node_names">Array of discovered node names, populated on success.
        /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().</param>
        /// <param name="node_namespaces">Array of discovered node namespaces, populated on success.
        /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().</param>
        /// <param name="enclaves">Array of discovered node enclave names, populated on success.
        /// It is up to the caller to finalize this array later on, using rcutils_string_array_fini().</param>
        /// <returns>`RMW_RET_OK` if the query was successful, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `enclaves` is not a zero-initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `enclaves` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is not a zero-initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_names` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_names` is not a zero-initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_namespaces` is NULL, or</returns>
        /// <remarks>
        /// This is similar to rmw_get_node_names(), but it also provides enclave names.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `enclaves` must be a zero-initialized string array,
        /// as returned by rcutils_get_zero_initialized_string_array().
        /// </pre>
        /// <pre>
        /// Given `node_namespaces` must be a valid string array, zero-initialized
        /// as returned by rcutils_get_zero_initialized_string_array().
        /// </pre>
        /// <pre>
        /// Given `node_names` must be a valid string array, zero-initialized
        /// as returned by rcutils_get_zero_initialized_string_array().
        /// </pre>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to query the ROS graph using the same node concurrently.
        /// However, access to string arrays is not synchronized.
        /// It is not safe to read or write `node_names`, `node_namespaces`, nor `enclaves`
        /// while rmw_get_node_names_with_enclaves() uses them.
        /// </par>
        /// <post>
        /// Given `node_names`, `node_namespaces`, and `enclaves` will remain valid arrays.
        /// These will be left unchanged if this function fails early due to a logical error,
        /// such as an invalid argument, or in an unknown yet valid state if it fails due to
        /// a runtime error.
        /// </post>
        /// <par>
        /// Runtime behavior
        /// To query the ROS graph is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_get_node_names_with_enclaves(RclNative.rmw_node_t* node, RclNative.rcutils_string_array_t* node_names, RclNative.rcutils_string_array_t* node_namespaces, RclNative.rcutils_string_array_t* enclaves);

        /// <summary>
        /// Count the number of known publishers matching a topic name.
        /// </summary>
        /// <param name="node">Handle to node to use to query the ROS graph.</param>
        /// <param name="topic_name">Fully qualified ROS topic name.</param>
        /// <param name="count">Number of publishers matching the given topic name.</param>
        /// <returns>`RMW_RET_OK` if the query was successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
        /// by rmw_validate_full_topic_name() definition, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function returns the numbers of publishers of a given topic in the ROS graph,
        /// as discovered so far by the given node.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// To query the ROS graph is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        /// <par>
        /// Thread-safety
        /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is to query the ROS graph using the same node concurrently.
        /// However, access to primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `topic_name` or `count` while rmw_count_publishers()
        /// uses them.
        /// </par>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_count_publishers(RclNative.rmw_node_t* node, byte* topic_name, RclNative.size_t* count);

        /// <summary>
        /// Count the number of known subscribers matching a topic name.
        /// </summary>
        /// <param name="node">Handle to node to use to query the ROS graph.</param>
        /// <param name="topic_name">Fully qualified ROS topic name.</param>
        /// <param name="count">Number of subscribers matching the given topic name.</param>
        /// <returns>`RMW_RET_OK` if the query was successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_name` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_name` is not a fully qualified topic name,
        /// by rmw_validate_full_topic_name() definition, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `count` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function returns the numbers of subscribers of a given topic in the ROS graph,
        /// as discovered so far by the given node.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Runtime behavior
        /// To query the ROS graph is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        /// <par>
        /// Thread-safety
        /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is to query the ROS graph using the same node concurrently.
        /// However, access to primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `topic_name` or `count` while rmw_count_subscribers()
        /// uses them.
        /// </par>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_count_subscribers(RclNative.rmw_node_t* node, byte* topic_name, RclNative.size_t* count);

        /// <summary>
        /// Get the unique identifier (gid) of a publisher.
        /// </summary>
        /// <param name="publisher">Publisher to get a gid from.</param>
        /// <param name="gid">Publisher's unique identifier, populated on success
        /// but left unchanged on failure.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `publisher` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Publishers are thread-safe objects, and so are all operations on them except for
        /// finalization.
        /// Therefore, it is safe to get the unique identifier from the same publisher concurrently.
        /// However, access to the gid is not synchronized.
        /// It is not safe to read or write `gid` while rmw_get_gid_for_publisher() uses it.
        /// </par>
        /// <pre>
        /// Given `publisher` must be a valid subscription, as returned by rmw_create_publisher().
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_get_gid_for_publisher(RclNative.rmw_publisher_t* publisher, RclNative.rmw_gid_t* gid);

        /// <summary>
        /// Check if two unique identifiers (gids) are equal.
        /// </summary>
        /// <param name="gid1">First unique identifier to compare.</param>
        /// <param name="gid2">Second unique identifier to compare.</param>
        /// <param name="bool">true if both gids are equal, false otherwise.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `gid1` or `gid2` is NULL, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the implementation
        /// identifier of `gid1` or `gid2` does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]&lt;i&gt;[1] implementation defined, check implementation documentation.&lt;/i&gt;
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Unique identifier comparison is a reentrant function, but:
        /// - Access to both gids is read-only but it is not synchronized.
        /// Concurrent `gid1` and `gid2` reads are safe, but concurrent reads and writes are not.
        /// - Access to primitive data-type arguments is not synchronized.
        /// It is not safe to read or write `result` while rmw_compare_gids_equal() uses it.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_compare_gids_equal(RclNative.rmw_gid_t* gid1, RclNative.rmw_gid_t* gid2, bool* result);

        /// <summary>
        /// Check if a service server is available for the given service client.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="client">the handle to the service client being queried</param>
        /// <param name="is_available">set to true if there is a service server available, else false</param>
        /// <returns>`RMW_RET_OK` if node the check was made successfully, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `publisher` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will return true for `is_available` if there is a service
        /// server available for the given client.The node parameter must not be `NULL`, and must point to a valid node.The client parameter must not be `NULL`, and must point to a valid client.The given client and node must match, i.e. the client must have been created
        /// using the given node.The is_available parameter must not be `NULL`, and must point to a bool
        /// variable.
        /// The result of the check will be stored in the is_available parameter.This function does manipulate heap memory.
        /// This function is not thread-safe.
        /// This function is lock-free.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_service_server_is_available(RclNative.rmw_node_t* node, RclNative.rmw_client_t* client, bool* is_available);

        /// <summary>
        /// Set the current log severity
        /// </summary>
        /// <param name="severity">The log severity to set</param>
        /// <returns>RMW_RET_OK if successful, otherwise an appropriate error code</returns>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_set_log_severity(RclNative.rmw_log_severity_t severity);

        /// <summary>
        /// Return a zero initialized timer.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_timer_t rcl_get_zero_initialized_timer();

        /// <summary>
        /// Initialize a timer.
        /// </summary>
        /// <param name="timer">the timer handle to be initialized</param>
        /// <param name="clock">the clock providing the current time</param>
        /// <param name="context">the context that this timer is to be associated with</param>
        /// <param name="period">the duration between calls to the callback in nanoseconds</param>
        /// <param name="callback">the user defined function to be called every period</param>
        /// <param name="allocator">the allocator to use for allocations</param>
        /// <returns>`RCL_RET_OK` if the timer was initialized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the timer was already initialized, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// A timer consists of a clock, a callback function and a period.
        /// A timer can be added to a wait set and waited on, such that the wait set
        /// will wake up when a timer is ready to be executed.A timer simply holds state and does not automatically call callbacks.
        /// It does not create any threads, register interrupts, or consume signals.
        /// For blocking behavior it can be used in conjunction with a wait set and
        /// rcl_wait().
        /// When rcl_timer_is_ready() returns true, the timer must still be called
        /// explicitly using rcl_timer_call().The timer handle must be a pointer to an allocated and zero initialized
        /// rcl_timer_t struct.
        /// Calling this function on an already initialized timer will fail.
        /// Calling this function on a timer struct which has been allocated but not
        /// zero initialized is undefined behavior.The clock handle must be a pointer to an initialized rcl_clock_t struct.
        /// The life time of the clock must exceed the life time of the timer.The period is a non-negative duration (rather an absolute time in the
        /// future).
        /// If the period is `0` then it will always be ready.The callback is an optional argument.
        /// Valid inputs are either a pointer to the function callback, or `NULL` to
        /// indicate that no callback will be stored in rcl.
        /// If the callback is `NULL`, the caller client library is responsible for
        /// firing the timer callback.
        /// Else, it must be a function which returns void and takes two arguments,
        /// the first being a pointer to the associated timer, and the second a int64_t
        /// which is the time since the previous call, or since the timer was created
        /// if it is the first call to the callback.Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;void my_timer_callback(rcl_timer_t * timer, int64_t last_call_time)
        /// {
        /// // Do timer work...
        /// // Optionally reconfigure, cancel, or reset the timer...
        /// }rcl_context_t * context;  // initialized previously by rcl_init()...
        /// rcl_clock_t clock;
        /// rcl_allocator_t allocator = rcl_get_default_allocator();
        /// rcl_ret_t ret = rcl_clock_init(RCL_STEADY_TIME, 
        /// &amp;clock
        /// , 
        /// &amp;allocator
        /// );
        /// // ... error handlingrcl_timer_t timer = rcl_get_zero_initialized_timer();
        /// ret = rcl_timer_init(
        /// &amp;timer
        /// , 
        /// &amp;clock
        /// , context, RCL_MS_TO_NS(100), my_timer_callback, allocator);
        /// // ... error handling, use the timer with a wait set, or poll it manually, then cleanup
        /// ret = rcl_timer_fini(
        /// &amp;timer
        /// );
        /// // ... error handling
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1][2][3]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`&lt;/i&gt;&lt;i&gt;[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;&lt;i&gt;[3] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_init(RclNative.rcl_timer_t* timer, RclNative.rcl_clock_t* clock, RclNative.rcl_context_t* context, long period, delegate* unmanaged[Cdecl]<RclNative.rcl_timer_t*, long, void> callback, RclNative.rcl_allocator_t allocator);

        /// <summary>
        /// Finalize a timer.
        /// </summary>
        /// <param name="timer">the handle to the timer to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the timer was finalized successfully, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will deallocate any memory and make the timer invalid.A timer that is already invalid (zero initialized) or `NULL` will not fail.This function is not thread-safe with any rcl_timer_* functions used on the
        /// same timer object.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1][2][3]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_uintptr_t`&lt;/i&gt;&lt;i&gt;[2] if `atomic_is_lock_free()` returns true for `atomic_uint_least64_t`&lt;/i&gt;&lt;i&gt;[3] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_fini(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Call the timer's callback and set the last call time.
        /// </summary>
        /// <param name="timer">the handle to the timer to call</param>
        /// <returns>`RCL_RET_OK` if the timer was called successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_CANCELED` if the timer has been canceled, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will call the callback and change the last call time even if
        /// the timer's period has not yet elapsed.
        /// It is up to the calling code to make sure the period has elapsed by first
        /// calling rcl_timer_is_ready().
        /// If the callback pointer is `NULL` (either set in init or exchanged after
        /// initialized), no callback is fired.
        /// However, this function should still be called by the client library to
        /// update the state of the timer.
        /// The order of operations in this command are as follows:- Ensure the timer has not been canceled.
        /// - Get the current time into a temporary rcl_steady_time_point_t.
        /// - Exchange the current time with the last call time of the timer.
        /// - Call the callback, passing this timer and the time since the last call.
        /// - Return after the callback has completed.During the callback the timer can be canceled or have its period and/or
        /// callback modified.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes [1]
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [2]
        /// &lt;i&gt;[1] user callback might not be thread-safe&lt;/i&gt;&lt;i&gt;[2] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_call(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Retrieve the clock of the timer.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being queried</param>
        /// <param name="clock">the rcl_clock_t * in which the clock is stored</param>
        /// <returns>`RCL_RET_OK` if the period was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function retrieves the clock pointer and copies it into the given variable.The clock argument must be a pointer to an already allocated rcl_clock_t *.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_clock(RclNative.rcl_timer_t* timer, RclNative.rcl_clock_t** clock);

        /// <summary>
        /// Calculates whether or not the timer should be called.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being checked</param>
        /// <param name="is_ready">the bool used to store the result of the calculation</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// The result is true if the time until next call is less than, or equal to, 0
        /// and the timer has not been canceled.
        /// Otherwise the result is false, indicating the timer should not be called.The is_ready argument must point to an allocated bool object, as the result
        /// is copied into it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_is_ready(RclNative.rcl_timer_t* timer, bool* is_ready);

        /// <summary>
        /// Calculate and retrieve the time until the next call in nanoseconds.
        /// </summary>
        /// <param name="timer">the handle to the timer that is being queried</param>
        /// <param name="time_until_next_call">the output variable for the result</param>
        /// <returns>`RCL_RET_OK` if the timer until next call was successfully calculated, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function calculates the time until the next call by adding the timer's
        /// period to the last call time and subtracting that sum from the current time.
        /// The calculated time until the next call can be positive, indicating that it
        /// is not ready to be called as the period has not elapsed since the last call.
        /// The calculated time until the next call can also be 0 or negative,
        /// indicating that the period has elapsed since the last call and the timer
        /// should be called.
        /// A negative value indicates the timer call is overdue by that amount.The `time_until_next_call` argument must point to an allocated int64_t, as
        /// the time until is copied into that instance.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_get_time_until_next_call(RclNative.rcl_timer_t* timer, long* time_until_next_call);

        /// <summary>
        /// Retrieve the time since the previous call to rcl_timer_call() occurred.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being queried</param>
        /// <param name="time_since_last_call">the struct in which the time is stored</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function calculates the time since the last call and copies it into
        /// the given int64_t variable.Calling this function within a callback will not return the time since the
        /// previous call but instead the time since the current callback was called.The time_since_last_call argument must be a pointer to an already allocated
        /// int64_t.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_get_time_since_last_call(RclNative.rcl_timer_t* timer, long* time_since_last_call);

        /// <summary>
        /// Retrieve the period of the timer.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being queried</param>
        /// <param name="period">the int64_t in which the period is stored</param>
        /// <returns>`RCL_RET_OK` if the period was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function retrieves the period and copies it into the given variable.The period argument must be a pointer to an already allocated int64_t.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_get_period(RclNative.rcl_timer_t* timer, long* period);

        /// <summary>
        /// Exchange the period of the timer and return the previous period.
        /// </summary>
        /// <param name="timer">the handle to the timer which is being modified</param>
        /// <param name="new_period">the int64_t to exchange into the timer</param>
        /// <param name="old_period">the int64_t in which the previous period is stored</param>
        /// <returns>`RCL_RET_OK` if the period was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function exchanges the period in the timer and copies the old one into
        /// the given variable.Exchanging (changing) the period will not affect already waiting wait sets.The old_period argument must be a pointer to an already allocated int64_t.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_exchange_period(RclNative.rcl_timer_t* timer, long new_period, long* old_period);

        /// <summary>
        /// Return the current timer callback.
        /// </summary>
        /// <param name="timer">handle to the timer from the callback should be returned</param>
        /// <returns>function pointer to the callback, or `NULL` if an error occurred</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - timer is `NULL`
        /// - timer has not been initialized (the implementation is invalid)&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern delegate* unmanaged[Cdecl]<RclNative.rcl_timer_t*, long, void> rcl_timer_get_callback(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Exchange the current timer callback and return the current callback.
        /// </summary>
        /// <param name="timer">handle to the timer from the callback should be exchanged</param>
        /// <param name="new_callback">the callback to be exchanged into the timer</param>
        /// <returns>function pointer to the old callback, or `NULL` if an error occurred</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - timer is `NULL`
        /// - timer has not been initialized (the implementation is invalid)This function can set callback to `NULL`, in which case the callback is
        /// ignored when rcl_timer_call is called.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern delegate* unmanaged[Cdecl]<RclNative.rcl_timer_t*, long, void> rcl_timer_exchange_callback(RclNative.rcl_timer_t* timer, delegate* unmanaged[Cdecl]<RclNative.rcl_timer_t*, long, void> new_callback);

        /// <summary>
        /// Cancel a timer.
        /// </summary>
        /// <param name="timer">the timer to be canceled</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// When a timer is canceled, rcl_timer_is_ready() will return false for that
        /// timer, and rcl_timer_call() will fail with RCL_RET_TIMER_CANCELED.A canceled timer can be reset with rcl_timer_reset(), and then used again.
        /// Calling this function on an already canceled timer will succeed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_cancel(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Retrieve the canceled state of a timer.
        /// </summary>
        /// <param name="timer">the timer to be queried</param>
        /// <param name="is_canceled">storage for the is canceled bool</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// If the timer is canceled true will be stored in the is_canceled argument.
        /// Otherwise false will be stored in the is_canceled argument.The is_canceled argument must point to an allocated bool, as the result is
        /// copied into this variable.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_bool`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_is_canceled(RclNative.rcl_timer_t* timer, bool* is_canceled);

        /// <summary>
        /// Reset a timer.
        /// </summary>
        /// <param name="timer">the timer to be reset</param>
        /// <returns>`RCL_RET_OK` if the last call time was retrieved successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_TIMER_INVALID` if the timer is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function can be called on a timer, canceled or not.
        /// For all timers it will reset the last call time to now.
        /// For canceled timers it will additionally make the timer not canceled.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Yes
        /// Lock-Free          | Yes [1]
        /// &lt;i&gt;[1] if `atomic_is_lock_free()` returns true for `atomic_int_least64_t`&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_timer_reset(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Return the allocator for the timer.
        /// </summary>
        /// <param name="timer">handle to the timer object</param>
        /// <returns>pointer to the allocator, or `NULL` if an error occurred</returns>
        /// <remarks>
        /// This function can fail, and therefore return `NULL`, if:
        /// - timer is `NULL`
        /// - timer has not been initialized (the implementation is invalid)The returned pointer is only valid as long as the timer object is valid.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_allocator_t* rcl_timer_get_allocator(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Retrieve a guard condition used by the timer to wake the waitset when using ROSTime.
        /// </summary>
        /// <param name="timer">the timer to be queried</param>
        /// <returns>`NULL` if the timer is invalid or does not have a guard condition, or</returns>
        /// <returns>a guard condition pointer.</returns>
        /// <remarks>
        /// &lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_guard_condition_t* rcl_timer_get_guard_condition(RclNative.rcl_timer_t* timer);

        /// <summary>
        /// Return a rcl_event_t struct with members set to `NULL`.
        /// </summary>
        /// <remarks>
        /// Should be called to get a null rcl_event_t before passing to
        /// rcl_event_init().
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_event_t rcl_get_zero_initialized_event();

        /// <summary>
        /// Initialize an rcl_event_t with a publisher.
        /// </summary>
        /// <param name="event">pointer to fill</param>
        /// <param name="publisher">to get events from</param>
        /// <param name="event_type">to listen for</param>
        /// <returns>`RCL_RET_OK` if the rcl_event_t is filled, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_UNSUPPORTED` if event_type is not supported, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Fill the rcl_event_t with the publisher and desired event_type.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_publisher_event_init(RclNative.rcl_event_t* @event, RclNative.rcl_publisher_t* publisher, RclNative.rcl_publisher_event_type_t event_type);

        /// <summary>
        /// Initialize an rcl_event_t with a subscription.
        /// </summary>
        /// <param name="event">pointer to fill</param>
        /// <param name="subscription">to get events from</param>
        /// <param name="event_type">to listen for</param>
        /// <returns>`RCL_RET_OK` if the rcl_event_t is filled, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory fails, or</returns>
        /// <returns>`RCL_RET_UNSUPPORTED` if event_type is not supported, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Fill the rcl_event_t with the subscription and desired event_type.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_subscription_event_init(RclNative.rcl_event_t* @event, RclNative.rcl_subscription_t* subscription, RclNative.rcl_subscription_event_type_t event_type);

        /// <summary>
        /// Take event using the event handle.
        /// </summary>
        /// <param name="event">event object to take from</param>
        /// <param name="event_info">event info object to write taken data into</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation failed, or</returns>
        /// <returns>`RCL_RET_EVENT_TAKE_FAILED` if the take event failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Take an event from the event handle.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_take_event(RclNative.rcl_event_t* @event, void* event_info);

        /// <summary>
        /// Finalize an event.
        /// </summary>
        /// <param name="event">to finalize</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_EVENT_INVALID` if event is null, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unexpected error occurs.</returns>
        /// <remarks>
        /// Finalize an event.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_event_fini(RclNative.rcl_event_t* @event);

        /// <summary>
        /// Return the rmw event handle.
        /// </summary>
        /// <param name="event">pointer to the rcl event</param>
        /// <returns>rmw event handle if successful, otherwise `NULL`</returns>
        /// <remarks>
        /// The handle returned is a pointer to the internally held rmw handle.
        /// This function can fail, and therefore return `NULL`, if the:
        /// - event is `NULL`
        /// - event is invalid (never called init, called fini, or invalid node)The returned handle is made invalid if the event is finalized or if
        /// rcl_shutdown() is called.
        /// The returned handle is not guaranteed to be valid for the life time of the
        /// event as it may be finalized and recreated itself.
        /// Therefore it is recommended to get the handle from the event using
        /// this function each time it is needed and avoid use of the handle
        /// concurrently with functions that might change it.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_event_t rcl_event_get_rmw_handle(RclNative.rcl_event_t* @event);

        /// <summary>
        /// Return a rcl_wait_set_t struct with members set to `NULL`.
        /// </summary>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_wait_set_t rcl_get_zero_initialized_wait_set();

        /// <summary>
        /// Initialize a rcl wait set with space for items to be waited on.
        /// </summary>
        /// <param name="wait_set">the wait set struct to be initialized</param>
        /// <param name="context">the context that the wait set should be associated with</param>
        /// <param name="number_of_events">non-zero size of the events set</param>
        /// <param name="number_of_services">non-zero size of the services set</param>
        /// <param name="allocator">the allocator to use when allocating space in the sets</param>
        /// <param name="number_of_timers">non-zero size of the timers set</param>
        /// <param name="number_of_guard_conditions">non-zero size of the guard conditions set</param>
        /// <param name="number_of_subscriptions">non-zero size of the subscriptions set</param>
        /// <param name="number_of_clients">non-zero size of the clients set</param>
        /// <returns>`RCL_RET_OK` if the wait set is initialized successfully, or</returns>
        /// <returns>`RCL_RET_ALREADY_INIT` if the wait set is not zero initialized, or</returns>
        /// <returns>`RCL_RET_NOT_INIT` if the given context is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function allocates space for the subscriptions and other wait-able
        /// entities that can be stored in the wait set.
        /// It also sets the allocator to the given allocator and initializes the pruned
        /// member to be false.The wait_set struct should be allocated and initialized to `NULL`.
        /// If the wait_set is allocated but the memory is uninitialized the behavior is
        /// undefined.
        /// Calling this function on a wait set that has already been initialized will
        /// result in an error.
        /// A wait set can be reinitialized if rcl_wait_set_fini() was called on it.To use the default allocator use rcl_get_default_allocator().Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /wait.h&gt;rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
        /// rcl_ret_t ret =
        /// rcl_wait_set_init(
        /// &amp;wait
        /// _set, 42, 42, 42, 42, 42, 
        /// &amp;context
        /// , rcl_get_default_allocator());
        /// // ... error handling, then use it, then call the matching fini:
        /// ret = rcl_wait_set_fini(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_init(RclNative.rcl_wait_set_t* wait_set, RclNative.size_t number_of_subscriptions, RclNative.size_t number_of_guard_conditions, RclNative.size_t number_of_timers, RclNative.size_t number_of_clients, RclNative.size_t number_of_services, RclNative.size_t number_of_events, RclNative.rcl_context_t* context, RclNative.rcl_allocator_t allocator);

        /// <summary>
        /// Finalize a rcl wait set.
        /// </summary>
        /// <param name="wait_set">the wait set struct to be finalized.</param>
        /// <returns>`RCL_RET_OK` if the finalization was successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is not destroyed properly, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// Deallocates any memory in the wait set that was allocated in
        /// rcl_wait_set_init() using the allocator given in the initialization.Calling this function on a zero initialized wait set will do nothing and
        /// return RCL_RET_OK.
        /// Calling this function on uninitialized memory results in undefined behavior.
        /// After calling this function the wait set will once again be zero initialized
        /// and so calling this function or rcl_wait_set_init() immediately after will
        /// succeed.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_fini(RclNative.rcl_wait_set_t* wait_set);

        /// <summary>
        /// Retrieve the wait set's allocator.
        /// </summary>
        /// <param name="wait_set">the handle to the wait set</param>
        /// <param name="allocator">the rcl_allocator_t struct to which the result is copied</param>
        /// <returns>`RCL_RET_OK` if the allocator was successfully retrieved, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The allocator must be an allocated rcl_allocator_t struct, as the result is
        /// copied into this variable.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_get_allocator(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Store a pointer to the given subscription in the next empty spot in the set.
        /// </summary>
        /// <param name="wait_set">struct in which the subscription is to be stored</param>
        /// <param name="subscription">the subscription to be added to the wait set</param>
        /// <param name="index">the index of the added subscription in the storage container.
        /// This parameter is optional and can be set to `NULL` to be ignored.</param>
        /// <returns>`RCL_RET_OK` if added successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_FULL` if the subscription set is full, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function does not guarantee that the subscription is not already in the
        /// wait set.Also add the rmw representation to the underlying rmw array and increment
        /// the rmw array count.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_subscription(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_subscription_t* subscription, RclNative.size_t* index);

        /// <summary>
        /// Remove (sets to `NULL`) all entities in the wait set.
        /// </summary>
        /// <param name="wait_set">struct to have its entities cleared</param>
        /// <returns>`RCL_RET_OK` if cleared successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function should be used after passing using rcl_wait, but before
        /// adding new entities to the set.
        /// Sets all of the entries in the underlying rmw array to `NULL`, and sets the
        /// count in the rmw array to `0`.Calling this on an uninitialized (zero initialized) wait set will fail.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_clear(RclNative.rcl_wait_set_t* wait_set);

        /// <summary>
        /// Reallocate space for entities in the wait set.
        /// </summary>
        /// <param name="wait_set">struct to be resized</param>
        /// <param name="subscriptions_size">a size for the new subscriptions set</param>
        /// <param name="guard_conditions_size">a size for the new guard conditions set</param>
        /// <param name="timers_size">a size for the new timers set</param>
        /// <param name="clients_size">a size for the new clients set</param>
        /// <param name="services_size">a size for the new services set</param>
        /// <param name="events_size">a size for the new events set</param>
        /// <returns>`RCL_RET_OK` if resized successfully, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if allocating memory failed, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will deallocate and reallocate the memory for all entity sets.A size of 0 will just deallocate the memory and assign `NULL` to the array.Allocation and deallocation is done with the allocator given during the
        /// wait set's initialization.After calling this function all values in the set will be set to `NULL`,
        /// effectively the same as calling rcl_wait_set_clear().
        /// Similarly, the underlying rmw representation is reallocated and reset:
        /// all entries are set to `NULL` and the count is set to zero.If the requested size matches the current size, no allocation will be done.This can be called on an uninitialized (zero initialized) wait set.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_resize(RclNative.rcl_wait_set_t* wait_set, RclNative.size_t subscriptions_size, RclNative.size_t guard_conditions_size, RclNative.size_t timers_size, RclNative.size_t clients_size, RclNative.size_t services_size, RclNative.size_t events_size);

        /// <summary>
        /// Store a pointer to the guard condition in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_guard_condition(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_guard_condition_t* guard_condition, RclNative.size_t* index);

        /// <summary>
        /// Store a pointer to the timer in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_timer(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_timer_t* timer, RclNative.size_t* index);

        /// <summary>
        /// Store a pointer to the client in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_client(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_client_t* client, RclNative.size_t* index);

        /// <summary>
        /// Store a pointer to the service in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_service(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_service_t* service, RclNative.size_t* index);

        /// <summary>
        /// Store a pointer to the event in the next empty spot in the set.
        /// </summary>
        /// <remarks>
        /// This function behaves exactly the same as for subscriptions.
        /// </remarks>
        /// <seealso cref="rcl_wait_set_add_subscription"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait_set_add_event(RclNative.rcl_wait_set_t* wait_set, RclNative.rcl_event_t* @event, RclNative.size_t* index);

        /// <summary>
        /// Block until the wait set is ready or until the timeout has been exceeded.
        /// </summary>
        /// <param name="wait_set">the set of things to be waited on and to be pruned if not ready</param>
        /// <param name="timeout">the duration to wait for the wait set to be ready, in nanoseconds</param>
        /// <returns>`RCL_RET_OK` something in the wait set became ready, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_INVALID` if the wait set is zero initialized, or</returns>
        /// <returns>`RCL_RET_WAIT_SET_EMPTY` if the wait set contains no items, or</returns>
        /// <returns>`RCL_RET_TIMEOUT` if the timeout expired before something was ready, or</returns>
        /// <returns>`RCL_RET_ERROR` an unspecified error occur.</returns>
        /// <remarks>
        /// This function will collect the items in the rcl_wait_set_t and pass them
        /// to the underlying rmw_wait function.The items in the wait set will be either left untouched or set to `NULL` after
        /// this function returns.
        /// Items that are not `NULL` are ready, where ready means different things based
        /// on the type of the item.
        /// For subscriptions this means there may be messages that can be taken, or
        /// perhaps that the state of the subscriptions has changed, in which case
        /// rcl_take may succeed but return with taken == false.
        /// For guard conditions this means the guard condition was triggered.Expected usage:```c
        /// #include 
        /// &lt;rcl
        /// /rcl.h&gt;// rcl_init() called successfully before here...
        /// rcl_node_t node;  // initialize this, see rcl_node_init()
        /// rcl_subscription_t sub1;  // initialize this, see rcl_subscription_init()
        /// rcl_subscription_t sub2;  // initialize this, see rcl_subscription_init()
        /// rcl_guard_condition_t gc1;  // initialize this, see rcl_guard_condition_init()
        /// rcl_wait_set_t wait_set = rcl_get_zero_initialized_wait_set();
        /// rcl_ret_t ret = rcl_wait_set_init(
        /// &amp;wait
        /// _set, 2, 1, 0, 0, 0, rcl_get_default_allocator());
        /// // ... error handling
        /// do {
        /// ret = rcl_wait_set_clear(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ret = rcl_wait_set_add_subscription(
        /// &amp;wait
        /// _set, 
        /// &amp;sub
        /// 1);
        /// // ... error handling
        /// ret = rcl_wait_set_add_subscription(
        /// &amp;wait
        /// _set, 
        /// &amp;sub
        /// 2);
        /// // ... error handling
        /// ret = rcl_wait_set_add_guard_condition(
        /// &amp;wait
        /// _set, 
        /// &amp;gc
        /// 1);
        /// // ... error handling
        /// ret = rcl_wait(
        /// &amp;wait
        /// _set, RCL_MS_TO_NS(1000));  // 1000ms == 1s, passed as ns
        /// if (ret == RCL_RET_TIMEOUT) {
        /// continue;
        /// }
        /// for (int i = 0; i 
        /// &lt;
        /// wait_set.size_of_subscriptions; ++i) {
        /// if (wait_set.subscriptions[i]) {
        /// // The subscription is ready...
        /// }
        /// }
        /// for (int i = 0; i 
        /// &lt;
        /// wait_set.size_of_guard_conditions; ++i) {
        /// if (wait_set.guard_conditions[i]) {
        /// // The subscription is ready...
        /// }
        /// }
        /// } while(check_some_condition());
        /// // ... fini node, and subscriptions and guard conditions...
        /// ret = rcl_wait_set_fini(
        /// &amp;wait
        /// _set);
        /// // ... error handling
        /// ```The wait set struct must be allocated, initialized, and should have been
        /// cleared and then filled with items, e.g. subscriptions and guard conditions.
        /// Passing a wait set with no wait-able items in it will fail.
        /// `NULL` items in the sets are ignored, e.g. it is valid to have as input:
        /// - `subscriptions[0]` = valid pointer
        /// - `subscriptions[1]` = `NULL`
        /// - `subscriptions[2]` = valid pointer
        /// - `size_of_subscriptions` = 3
        /// Passing an uninitialized (zero initialized) wait set struct will fail.
        /// Passing a wait set struct with uninitialized memory is undefined behavior.The unit of timeout is nanoseconds.
        /// If the timeout is negative then this function will block indefinitely until
        /// something in the wait set is valid or it is interrupted.
        /// If the timeout is 0 then this function will be non-blocking; checking what's
        /// ready now, but not waiting if nothing is ready yet.
        /// If the timeout is greater than 0 then this function will return after
        /// that period of time has elapsed or the wait set becomes ready, which ever
        /// comes first.
        /// Passing a timeout struct with uninitialized memory is undefined behavior.This function is thread-safe for unique wait sets with unique contents.
        /// This function cannot operate on the same wait set in multiple threads, and
        /// the wait sets may not share content.
        /// For example, calling rcl_wait() in two threads on two different wait sets
        /// that both contain a single, shared guard condition is undefined behavior.
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_wait(RclNative.rcl_wait_set_t* wait_set, long timeout);

        /// <summary>
        /// Return `true` if the wait set is valid, else `false`.
        /// </summary>
        /// <param name="wait_set">the rcl_wait_set_t to be validated</param>
        /// <returns>`true` if the wait_set is valid, otherwise `false`.</returns>
        /// <remarks>
        /// A wait set is invalid if:
        /// - the implementation is `NULL` (rcl_wait_set_init not called or failed)
        /// - the wait set has been finalized with rcl_wait_set_finiAlso return `false` if the wait set pointer is `NULL`.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern bool rcl_wait_set_is_valid(RclNative.rcl_wait_set_t* wait_set);

        /// <summary>
        /// Return a zero initialized array of names and types.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_names_and_types_t rmw_get_zero_initialized_names_and_types();

        /// <summary>
        /// Check that the given `names_and_types` array is zero initialized.
        /// </summary>
        /// <param name="names_and_types">Array to be checked.</param>
        /// <returns>RMW_RET_OK if array is zero initialized, RMW_RET_INVALID_ARGUMENT otherwise.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Access to the array of names and types is read-only, but it is not synchronized.
        /// Concurrent `names_and_types` reads are safe, but concurrent reads and writes are not.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_names_and_types_check_zero(RclNative.rmw_names_and_types_t* names_and_types);

        /// <summary>
        /// Initialize an array of names and types.
        /// </summary>
        /// <param name="names_and_types">Array to be initialized on success,
        /// but left unchanged on failure.</param>
        /// <param name="size">Size of the array.</param>
        /// <param name="allocator">Allocator to be used to populate `names_and_types`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `names_and_types` is not
        /// a zero initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,
        /// by rcutils_allocator_is_valid() definition, or</returns>
        /// <returns>`RMW_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function initializes the string array for the names and allocates space
        /// for all the string arrays for the types according to the given size, but
        /// it does not initialize the string array for each setup of types.
        /// However, the string arrays for each set of types is zero initialized.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Initialization is a reentrant procedure, but:
        /// - Access to arrays of names and types is not synchronized.
        /// It is not safe to read or write `names_and_types` during initialization.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_names_and_types_init(RclNative.rmw_names_and_types_t* names_and_types, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize an array of names and types.
        /// </summary>
        /// <param name="names_and_types">Array to be finalized.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `names_and_types` is NULL, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function deallocates the string array of names and the array of string arrays of types,
        /// and zero initializes the given array.
        /// If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will return
        /// early, leaving the given array unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Finalization is a reentrant procedure, but access to arrays of names and types
        /// is not synchronized.
        /// It is not safe to read or write `names_and_types` during initialization.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_names_and_types_fini(RclNative.rmw_names_and_types_t* names_and_types);

        /// <summary>
        /// Return all topic names and types in the ROS graph.
        /// </summary>
        /// <param name="node">Node to query the ROS graph.</param>
        /// <param name="allocator">Allocator to be used when populating the `topic_names_and_types` array.</param>
        /// <param name="no_demangle">Whether to demangle all topic names following ROS conventions or not.</param>
        /// <param name="topic_names_and_types">Array of topic names and their types,
        /// populated on success but left unchanged on failure.
        /// If populated, it is up to the caller to finalize this array later on
        /// using rmw_names_and_types_fini().</param>
        /// <returns>`RMW_RET_OK` if the query was successful, or</returns>
        /// <returns>`RMW_RET_ERROR` if an unspecified error occurs.</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_INCORRECT_RMW_IMPLEMENTATION` if the `node` implementation
        /// identifier does not match this implementation, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is not valid, by rcutils_allocator_is_valid()
        /// definition, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_names_and_types` is not a
        /// zero-initialized array, or</returns>
        /// <remarks>
        /// This function returns an array of all topic names and types in the ROS graph
        /// i.e. for which a publisher and/or a subscription exists, as discovered so far
        /// by the given local node.Unless `no_demangle` is true, some demangling and filtering may take place when
        /// listing topics as implemented by the middleware.
        /// Whether demangling applies or not, and how it applies, depends on the underlying
        /// implementation.
        /// See http://design.ros2.org/articles/topic_and_service_names.html for an example
        /// on how it is used in DDS and RTPS based implementations.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | Yes
        /// Uses Atomics       | Maybe [1]
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] rmw implementation defined, check the implementation documentation&lt;/i&gt;
        /// </remarks>
        /// <pre>
        /// Given `node` must be a valid node handle, as returned by rmw_create_node().
        /// </pre>
        /// <par>
        /// Thread-safety
        /// Nodes are thread-safe objects, and so are all operations on them except for finalization.
        /// Therefore, it is safe to query the ROS graph using the same node concurrently.
        /// However, when querying topic names and types:
        /// - Access to the array of names and types is not synchronized.
        /// It is not safe to read or write `topic_names_and_types`
        /// while rmw_get_topic_names_and_types() uses it.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `topic_names_and_types` must be a zero-initialized array of names and types,
        /// as returned by rmw_get_zero_initialized_names_and_types().
        /// </pre>
        /// <par>
        /// Runtime behavior
        /// To query the ROS graph is a synchronous operation.
        /// It is also non-blocking, but it is not guaranteed to be lock-free.
        /// Generally speaking, implementations may synchronize access to internal resources using
        /// locks but are not allowed to wait for events with no guaranteed time bound (barring
        /// the effects of starvation due to OS scheduling).
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_get_topic_names_and_types(RclNative.rmw_node_t* node, RclNative.rcutils_allocator_t* allocator, bool no_demangle, RclNative.rmw_names_and_types_t* topic_names_and_types);

        /// <summary>
        /// Return zero initialized topic endpoint info data structure.
        /// </summary>
        /// <remarks>
        /// Endpoint type will be invalid.
        /// Endpoint QoS profile will be the system default.
        /// </remarks>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_topic_endpoint_info_t rmw_get_zero_initialized_topic_endpoint_info();

        /// <summary>
        /// Finalize a topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be finalized.</param>
        /// <param name="allocator">Allocator used to populate the given `topic_endpoint_info`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,
        /// by rcutils_allocator_is_valid() definition, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function deallocates all allocated members of the given data structure,
        /// and then zero initializes it.
        /// If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function
        /// will return early, leaving the given data structure unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Finalization is a reentrant procedure, but:
        /// - Access to the topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write `topic_endpoint` during finalization.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_fini(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Set the topic type in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="topic_type">Type name to be set.</param>
        /// <param name="allocator">Allocator to be used.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_type` is NULL, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions allocates memory and copies the value of the `topic_type`
        /// argument to set the data structure `topic_type` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but:
        /// - Access to the topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `topic_type` member of the given `topic_endpoint`
        /// while setting it.
        /// - Access to C-style string arguments is read-only but it is not synchronized.
        /// Concurrent `topic_type` reads are safe, but concurrent reads and writes are not.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `topic_type` is a valid C-style string i.e. NULL terminated.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_topic_type(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, byte* topic_type, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Set the node name in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="node_name">Node name to be set.</param>
        /// <param name="allocator">Allocator to be used.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_name` is NULL, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions allocates memory and copies the value of the `node_name`
        /// argument to set the data structure `node_name` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but:
        /// - Access to the topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `node_name` member of the given `topic_endpoint`
        /// while setting it.
        /// - Access to C-style string arguments is read-only but it is not synchronized.
        /// Concurrent `node_name` reads are safe, but concurrent reads and writes are not.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `node_name` is a valid C-style string i.e. NULL terminated.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_node_name(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, byte* node_name, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Set the node namespace in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="node_namespace">Node namespace to be set.</param>
        /// <param name="allocator">Allocator to be used.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `node_namespace` is NULL, or</returns>
        /// <returns>`RMW_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions allocates memory and copies the value of the `node_namespace`
        /// argument to set the data structure `node_namespace` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but:
        /// - Access to the topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `node_namespace` member of the given `topic_endpoint`
        /// while setting it.
        /// - Access to C-style string arguments is read-only but it is not synchronized.
        /// Concurrent `node_namespace` reads are safe, but concurrent reads and writes are not.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `node_namespace` is a valid C-style string i.e. NULL terminated.
        /// </pre>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_node_namespace(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, byte* node_namespace, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Set the endpoint type in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="type">Endpoint type to be set.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions assigns the value of the `type` argument to the data structure
        /// `endpoint_type` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but access to the
        /// topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `endpoint_type` member of the
        /// given `topic_endpoint` while setting it.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_endpoint_type(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, RclNative.rmw_endpoint_type_t type);

        /// <summary>
        /// Set the endpoint gid in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="gid">Endpoint gid to be set.</param>
        /// <param name="size">Size of the given `gid`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `gid` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `size` is greater than RMW_GID_STORAGE_SIZE, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions copies the value of the `gid` argument to the data structure
        /// `endpoint_gid` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but access to the
        /// topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `gid` member of the
        /// given `topic_endpoint` while setting it.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_gid(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, byte* gid, RclNative.size_t size);

        /// <summary>
        /// Set the endpoint QoS profile in the given topic endpoint info data structure.
        /// </summary>
        /// <param name="topic_endpoint_info">Data structure to be populated.</param>
        /// <param name="qos_profile">QoS profile to be set.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `qos_profile` is NULL, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This functions assigns the value of the `qos_profile` argument to the data structure
        /// `qos_profile` member.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Setting a member is a reentrant procedure, but access to the
        /// topic endpoint info data structure is not synchronized.
        /// It is not safe to read or write the `qos_profile` member of the
        /// given `topic_endpoint` while setting it.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_set_qos_profile(RclNative.rmw_topic_endpoint_info_t* topic_endpoint_info, RclNative.rmw_qos_profile_t* qos_profile);

        /// <summary>
        /// Return a zero initialized array of topic endpoint information.
        /// </summary>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_topic_endpoint_info_array_t rmw_get_zero_initialized_topic_endpoint_info_array();

        /// <summary>
        /// Check that the given `topic_endpoint_info_array` is zero initialized.
        /// </summary>
        /// <param name="topic_endpoint_info_array">Array to be checked.</param>
        /// <returns>`RMW_RET_OK` if array is zero initialized, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or</returns>
        /// <returns>`RMW_RET_ERROR` if `topic_endpoint_info_array` is not zero initialized.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | Yes
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Access to the array of topic endpoint information is read-only, but it is not synchronized.
        /// Concurrent `topic_endpoint_info_array` reads are safe, but concurrent reads
        /// and writes are not.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_array_check_zero(RclNative.rmw_topic_endpoint_info_array_t* topic_endpoint_info_array);

        /// <summary>
        /// Initialize an array of topic endpoint information.
        /// </summary>
        /// <param name="topic_endpoint_info_array">Array to be initialized on success,
        /// but left unchanged on failure.</param>
        /// <param name="size">Size of the array.</param>
        /// <param name="allocator">Allocator to be used to populate `names_and_types`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is not
        /// a zero initialized array, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,
        /// by rcutils_allocator_is_valid() definition, or</returns>
        /// <returns>`RMW_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function allocates space to hold `size` topic endpoint information elements.
        /// Both `info_array` and `size` members are updated accordingly.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Initialization is a reentrant procedure, but:
        /// - Access to the array of topic endpoint information is not synchronized.
        /// It is not safe to read or write `topic_endpoint_info_array` during initialization.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        [DllImport("rmw_implementation", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_array_init_with_size(RclNative.rmw_topic_endpoint_info_array_t* topic_endpoint_info_array, RclNative.size_t size, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Finalize an array of topic endpoint information.
        /// </summary>
        /// <param name="topic_endpoint_info_array">object to be finalized.</param>
        /// <param name="allocator">Allocator used to populate the given `topic_endpoint_info_array`.</param>
        /// <returns>`RMW_RET_OK` if successful, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `topic_endpoint_info_array` is NULL, or</returns>
        /// <returns>`RMW_RET_INVALID_ARGUMENT` if `allocator` is invalid,
        /// by rcutils_allocator_is_valid() definition, or</returns>
        /// <returns>`RMW_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function sets the RMW error state on failure.This function deallocates the given array storage, and then zero initializes it.
        /// If a logical error, such as `RMW_RET_INVALID_ARGUMENT`, ensues, this function will
        /// return early, leaving the given array unchanged.
        /// Otherwise, it will proceed despite errors.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        /// <par>
        /// Thread-safety
        /// Finalization is a reentrant procedure, but:
        /// - Access to the array of topic endpoint information is not synchronized.
        /// It is not safe to read or write `topic_endpoint_info_array` during finalization.
        /// - The default allocators are thread-safe objects, but any custom `allocator` may not be.
        /// Check your allocator documentation for further reference.
        /// </par>
        /// <pre>
        /// Given `allocator` must be the same used to initialize the given `topic_endpoint_info_array`.
        /// </pre>
        [DllImport("rmw", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rmw_ret_t rmw_topic_endpoint_info_array_fini(RclNative.rmw_topic_endpoint_info_array_t* topic_endpoint_info_array, RclNative.rcutils_allocator_t* allocator);

        /// <summary>
        /// Return a list of topic names and types for publishers associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="no_demangle">if true, list all topics without any demangling</param>
        /// <param name="node_name">the node name of the topics to return</param>
        /// <param name="node_namespace">the node namespace of the topics to return</param>
        /// <param name="topic_names_and_types">list of topic names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.There may be some demangling that occurs when listing the names from the middleware
        /// implementation.
        /// If the `no_demangle` argument is set to `true`, then this will be avoided and the names will be
        /// returned as they appear to the middleware.The returned names are not automatically remapped by this function.
        /// Attempting to create publishers or subscribers using names returned by this function may not
        /// result in the desired topic name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rmw_get_topic_names_and_types for more details on no_demangle"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_publisher_names_and_types_by_node(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, bool no_demangle, byte* node_name, byte* node_namespace, RclNative.rcl_names_and_types_t* topic_names_and_types);

        /// <summary>
        /// Return a list of topic names and types for subscriptions associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="no_demangle">if true, list all topics without any demangling</param>
        /// <param name="node_name">the node name of the topics to return</param>
        /// <param name="node_namespace">the node namespace of the topics to return</param>
        /// <param name="topic_names_and_types">list of topic names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create publishers or subscribers using names returned by this function may not
        /// result in the desired topic name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_subscriber_names_and_types_by_node(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, bool no_demangle, byte* node_name, byte* node_namespace, RclNative.rcl_names_and_types_t* topic_names_and_types);

        /// <summary>
        /// Return a list of service names and types associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="node_name">the node name of the services to return</param>
        /// <param name="node_namespace">the node namespace of the services to return</param>
        /// <param name="service_names_and_types">list of service names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `service_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create service clients using names returned by this function may not
        /// result in the desired service name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_service_names_and_types_by_node(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, byte* node_name, byte* node_namespace, RclNative.rcl_names_and_types_t* service_names_and_types);

        /// <summary>
        /// Return a list of service client names and types associated with a node.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="node_name">the node name of the services to return</param>
        /// <param name="node_namespace">the node namespace of the services to return</param>
        /// <param name="service_names_and_types">list of service client names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_NAME_NON_EXISTENT` if the node name wasn't found, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `service_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create service servers using names returned by this function may not
        /// result in the desired service name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_client_names_and_types_by_node(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, byte* node_name, byte* node_namespace, RclNative.rcl_names_and_types_t* service_names_and_types);

        /// <summary>
        /// Return a list of topic names and their types.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="no_demangle">if true, list all topics without any demangling</param>
        /// <param name="topic_names_and_types">list of topic names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAME` if the node name is invalid, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID_NAMESPACE` if the node namespace is invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `topic_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create publishers or subscribers using names returned by this function may not
        /// result in the desired topic name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rcl_get_publisher_names_and_types_by_node for details on the `no_demangle` parameter."/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_topic_names_and_types(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, bool no_demangle, RclNative.rcl_names_and_types_t* topic_names_and_types);

        /// <summary>
        /// Return a list of service names and their types.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for strings</param>
        /// <param name="service_names_and_types">list of service names and their types</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `service_names_and_types` parameter must be allocated and zero initialized.
        /// This function allocates memory for the returned list of names and types and so it is the
        /// callers responsibility to pass `service_names_and_types` to rcl_names_and_types_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.The returned names are not automatically remapped by this function.
        /// Attempting to create clients or services using names returned by this function may not result in
        /// the desired service name being used depending on the remap rules in use.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_service_names_and_types(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t* allocator, RclNative.rcl_names_and_types_t* service_names_and_types);

        /// <summary>
        /// Initialize a rcl_names_and_types_t object.
        /// </summary>
        /// <param name="names_and_types">object to be initialized</param>
        /// <param name="size">the number of names and sets of types to be stored</param>
        /// <param name="allocator">to be used to allocate and deallocate memory</param>
        /// <returns>`RCL_RET_OK` on success, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCL_RET_ERROR` when an unspecified error occurs.</returns>
        /// <remarks>
        /// This function initializes the string array for the names and allocates space
        /// for all the string arrays for the types according to the given size, but
        /// it does not initialize the string array for each set of types.
        /// However, the string arrays for each set of types is zero initialized.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_names_and_types_init(RclNative.rcl_names_and_types_t* names_and_types, RclNative.size_t size, RclNative.rcl_allocator_t* allocator);

        /// <summary>
        /// Finalize a rcl_names_and_types_t object.
        /// </summary>
        /// <param name="names_and_types">struct to be finalized</param>
        /// <returns>`RCL_RET_OK` if successful, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The object is populated when given to one of the rcl_get_*_names_and_types()
        /// functions.
        /// This function reclaims any resources allocated during population.The `names_and_types` parameter must not be `NULL`, and must point to an
        /// already allocated rcl_names_and_types_t struct that was previously
        /// passed to a successful rcl_get_*_names_and_types() function call.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Yes
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_names_and_types_fini(RclNative.rcl_names_and_types_t* names_and_types);

        /// <summary>
        /// Return a list of available nodes in the ROS graph.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">used to control allocation and deallocation of names</param>
        /// <param name="node_names">struct storing discovered node names</param>
        /// <param name="node_namespaces">struct storing discovered node namespaces</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if an error occurred while allocating memory, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `node_names` parameter must be allocated and zero initialized.
        /// `node_names` is the output for this function, and contains allocated memory.
        /// Note that entries in the array might contain `NULL` values.
        /// Use rcutils_get_zero_initialized_string_array() for initializing an empty
        /// rcutils_string_array_t struct.
        /// This `node_names` struct should therefore be passed to rcutils_string_array_fini()
        /// when it is no longer needed.
        /// Failing to do so will result in leaked memory.Example:```c
        /// rcutils_string_array_t node_names =
        /// rcutils_get_zero_initialized_string_array();
        /// rcl_ret_t ret = rcl_get_node_names(node, 
        /// &amp;node
        /// _names);
        /// if (ret != RCL_RET_OK) {
        /// // ... error handling
        /// }
        /// // ... use the node_names struct, and when done:
        /// rcutils_ret_t rcutils_ret = rcutils_string_array_fini(
        /// &amp;node
        /// _names);
        /// if (rcutils_ret != RCUTILS_RET_OK) {
        /// // ... error handling
        /// }
        /// ```&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_node_names(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t allocator, RclNative.rcutils_string_array_t* node_names, RclNative.rcutils_string_array_t* node_namespaces);

        /// <summary>
        /// Return a list of available nodes in the ROS graph, including their enclave names.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">used to control allocation and deallocation of names</param>
        /// <param name="node_names">struct storing discovered node names</param>
        /// <param name="node_namespaces">struct storing discovered node namespaces</param>
        /// <param name="enclaves">struct storing discovered node enclaves</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if an error occurred while allocating memory, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// An @ref rcl_get_node_names equivalent, but including in its output the enclave
        /// name the node is using.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] RMW implementation in use may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_node_names_with_enclaves(RclNative.rcl_node_t* node, RclNative.rcl_allocator_t allocator, RclNative.rcutils_string_array_t* node_names, RclNative.rcutils_string_array_t* node_namespaces, RclNative.rcutils_string_array_t* enclaves);

        /// <summary>
        /// Return the number of publishers on a given topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="count">number of publishers on the given topic</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`, and must not be an empty string.
        /// It should also follow the topic name rules.The `count` parameter must point to a valid bool.
        /// The `count` parameter is the output for this function and will be set.In the event that error handling needs to allocate memory, this function
        /// will try to use the node's allocator.The topic name is not automatically remapped by this function.
        /// If there is a publisher created with topic name `foo` and remap rule `foo:=bar` then calling
        /// this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`
        /// will return a count of 0.
        /// /sa rcl_remap_topic_name()&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood): link to the topic name rules.
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_count_publishers(RclNative.rcl_node_t* node, byte* topic_name, RclNative.size_t* count);

        /// <summary>
        /// Return the number of subscriptions on a given topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="count">number of subscriptions on the given topic</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`, and must not be an empty string.
        /// It should also follow the topic name rules.The `count` parameter must point to a valid bool.
        /// The `count` parameter is the output for this function and will be set.In the event that error handling needs to allocate memory, this function
        /// will try to use the node's allocator.The topic name is not automatically remapped by this function.
        /// If there is a subscriber created with topic name `foo` and remap rule `foo:=bar` then calling
        /// this with `topic_name` set to `bar` will return a count of 1, and with `topic_name` set to `foo`
        /// will return a count of 0.
        /// /sa rcl_remap_topic_name()&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | No
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <todo>
        /// TODO(wjwwood): link to the topic name rules.
        /// </todo>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_count_subscribers(RclNative.rcl_node_t* node, byte* topic_name, RclNative.size_t* count);

        /// <summary>
        /// Return a list of all publishers to a topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for
        /// the array inside publishers_info</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="no_mangle">if `true`, `topic_name` needs to be a valid middleware topic name,
        /// otherwise it should be a valid ROS topic name</param>
        /// <param name="publishers_info">a struct representing a list of publisher information</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`.When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name
        /// for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
        /// When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
        /// ROS topic name conventions.
        /// In either case, the topic name should always be fully qualified.Each element in the `publishers_info` array will contain the node name, node namespace,
        /// topic type, gid and the qos profile of the publisher.
        /// It is the responsibility of the caller to ensure that `publishers_info` parameter points
        /// to a valid struct of type rcl_topic_endpoint_info_array_t.
        /// The `count` field inside the struct must be set to 0 and the `info_array` field inside
        /// the struct must be set to null.The `allocator` will be used to allocate memory to the `info_array` member
        /// inside of `publishers_info`.
        /// Moreover, every const char * member inside of
        /// rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rmw_get_zero_initialized_topic_endpoint_info_array"/>
        /// <seealso cref="reclaim any allocated resources to `publishers_info` to avoid leaking memory.However, it is the responsibility of the caller tormw_topic_endpoint_info_set_node_name and the likes."/>
        /// <seealso cref="rmw_topic_endpoint_info_array_fini"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_publishers_info_by_topic(RclNative.rcl_node_t* node, RclNative.rcutils_allocator_t* allocator, byte* topic_name, bool no_mangle, RclNative.rcl_topic_endpoint_info_array_t* publishers_info);

        /// <summary>
        /// Return a list of all subscriptions to a topic.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="allocator">allocator to be used when allocating space for
        /// the array inside publishers_info</param>
        /// <param name="topic_name">the name of the topic in question</param>
        /// <param name="no_mangle">if `true`, `topic_name` needs to be a valid middleware topic name,
        /// otherwise it should be a valid ROS topic name</param>
        /// <param name="subscriptions_info">a struct representing a list of subscriptions information</param>
        /// <returns>`RCL_RET_OK` if the query was successful, or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_BAD_ALLOC` if memory allocation fails, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// The `node` parameter must point to a valid node.The `topic_name` parameter must not be `NULL`.When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic name
        /// for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
        /// When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
        /// ROS topic name conventions.
        /// In either case, the topic name should always be fully qualified.Each element in the `subscriptions_info` array will contain the node name, node namespace,
        /// topic type, gid and the qos profile of the subscription.
        /// It is the responsibility of the caller to ensure that `subscriptions_info` parameter points
        /// to a valid struct of type rcl_topic_endpoint_info_array_t.
        /// The `count` field inside the struct must be set to 0 and the `info_array` field inside
        /// the struct must be set to null.The `allocator` will be used to allocate memory to the `info_array` member
        /// inside of `subscriptions_info`.
        /// Moreover, every const char * member inside of
        /// rmw_topic_endpoint_info_t will be assigned a copied value on allocated memory.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        /// <seealso cref="rmw_get_zero_initialized_topic_endpoint_info_array"/>
        /// <seealso cref="reclaim any allocated resources to `subscriptions_info` to avoid leaking memory.However, it is the responsibility of the caller tormw_topic_endpoint_info_set_node_name and the likes."/>
        /// <seealso cref="rmw_topic_endpoint_info_array_fini"/>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_get_subscriptions_info_by_topic(RclNative.rcl_node_t* node, RclNative.rcutils_allocator_t* allocator, byte* topic_name, bool no_mangle, RclNative.rcl_topic_endpoint_info_array_t* subscriptions_info);

        /// <summary>
        /// Check if a service server is available for the given service client.
        /// </summary>
        /// <param name="node">the handle to the node being used to query the ROS graph</param>
        /// <param name="client">the handle to the service client being queried</param>
        /// <param name="is_available">set to true if there is a service server available, else false</param>
        /// <returns>`RCL_RET_OK` if the check was made successfully (regardless of the service readiness), or</returns>
        /// <returns>`RCL_RET_NODE_INVALID` if the node is invalid, or</returns>
        /// <returns>`RCL_RET_INVALID_ARGUMENT` if any arguments are invalid, or</returns>
        /// <returns>`RCL_RET_ERROR` if an unspecified error occurs.</returns>
        /// <remarks>
        /// This function will return true for `is_available` if there is a service server
        /// available for the given client.The `node` parameter must point to a valid node.The `client` parameter must point to a valid client.The given client and node must match, i.e. the client must have been created
        /// using the given node.The `is_available` parameter must not be `NULL`, and must point a bool variable.
        /// The result of the check will be stored in the `is_available` parameter.In the event that error handling needs to allocate memory, this function
        /// will try to use the node's allocator.&lt;hr&gt;Attribute          | Adherence
        /// ------------------ | -------------
        /// Allocates Memory   | Yes
        /// Thread-Safe        | No
        /// Uses Atomics       | No
        /// Lock-Free          | Maybe [1]
        /// &lt;i&gt;[1] implementation may need to protect the data structure with a lock&lt;/i&gt;
        /// </remarks>
        [DllImport("rcl", CallingConvention = CallingConvention.Cdecl)]
        public static extern RclNative.rcl_ret_t rcl_service_server_is_available(RclNative.rcl_node_t* node, RclNative.rcl_client_t* client, bool* is_available);
    }
}
